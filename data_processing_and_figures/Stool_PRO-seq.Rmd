---
title: "Stool_PRO-seq"
author: "Albert Vill"
date: "1/25/2022"
output: html_document
---

# RNA-seq vs PRO-seq correlations
## list bam files
```{r}
library(tidyverse)

files <- dput(scan(text = "US2_5Nov2020_PRO_rep1_dedup_QC_end.sort.bam US2_5Nov2020_RNA_rep1_QC_end.sort.bam US3_3Nov2020_PRO_rep1_dedup_QC_end.sort.bam US3_3Nov2020_RNA_rep1_QC_end.sort.bam US2_5Nov2020_PRO_rep2_dedup_QC_end.sort.bam US2_5Nov2020_RNA_rep2_QC_end.sort.bam US3_3Nov2020_PRO_rep2_dedup_QC_end.sort.bam US3_3Nov2020_RNA_rep2_QC_end.sort.bam", what = ""))
filenames <- c("US2_P1","US2_P2","US2_R1","US2_R2","US3_P1","US3_P2","US3_R1","US3_R2")
donor <- c(rep("US2",4),rep("US3",4))
lib_type <- c(rep("PRO-seq",2),rep("RNA-seq",2),rep("PRO-seq",2),rep("RNA-seq",2))
bam_list <- tibble(files, filenames, donor, lib_type)
```

## read in featurecounts files
```{r}
gettsv <- function(x){
  
  # x is the file path
  
  read_tsv(x, col_names = T, comment = '#')
  
}

US2_fcounts <- gettsv("/workdir/users/acv46/stool_PROSeq2/deseq/featureCounts/US2_allcontigs/US2_allcontigs_SENSE_q30.txt") 
US3_fcounts <- gettsv("/workdir/users/acv46/stool_PROSeq2/deseq/featureCounts/US3_allcontigs/US3_allcontigs_SENSE_q30.txt")


```

## read in scaffolds2bins, bin annotation files, checkM stats, kraken taxa
```{r}
# scaffold to bin mapping
US2_scaff2bin <- read_tsv("/workdir/users/acv46/mgmAssembly/US2_5Nov2020_CAB/DASTool/US2_5Nov2020_redo_DASTool_scaffolds2bin.txt", col_names = F) %>%
  `colnames<-`(c("contig","bin")) %>% mutate(contig = gsub("_cov.*", "", contig))
US3_scaff2bin <- read_tsv("/workdir/users/acv46/mgmAssembly/US3_3Nov2020_CAB/DASTool/US3_3Nov2020_DASTool_scaffolds2bin.txt", col_names = F) %>%
  `colnames<-`(c("contig","bin")) %>% mutate(contig = gsub("_cov.*", "", contig))

# gtdbtk taxa
US2_gtdbtk <- read_tsv("/workdir/users/acv46/mgmAssembly/US2_5Nov2020_CAB/DASTool/gtdbtk/gtdbtk.bac120.summary.tsv", col_names = T)[,c(1,2)] %>%
  separate(., classification,
           into = c("g_kingdom","g_phylum","g_class","g_order","g_family","g_genus","g_species"),
           sep = ";", fill = "right", extra = "drop") %>%
  mutate_all(str_replace_all, ".*__", "")
US3_gtdbtk <- read_tsv("/workdir/users/acv46/mgmAssembly/US3_3Nov2020_CAB/DASTool/gtdbtk/gtdbtk.bac120.summary.tsv", col_names = T)[,c(1,2)] %>%
  separate(., classification,
           into = c("g_kingdom","g_phylum","g_class","g_order","g_family","g_genus","g_species"),
           sep = ";", fill = "right", extra = "drop") %>%
  mutate_all(str_replace_all, ".*__", "")
colnames(US2_gtdbtk)[1] <- "bin"
colnames(US3_gtdbtk)[1] <- "bin"

# checkM relative abundance
abund_cols <- dput(scan(text = "bin mbp mgm_reads percent_reads percent_binned percent_community", what = ""))
US2_abund <- read_tsv("/workdir/users/acv46/mgmAssembly/US2_5Nov2020_CAB/DASTool/checkM/US2_5Nov2020_checkM_abundance.txt", col_names = T)
US3_abund <- read_tsv("/workdir/users/acv46/mgmAssembly/US3_3Nov2020_CAB/DASTool/checkM/US3_3Nov2020_checkM_abundance.txt", col_names = T)
colnames(US2_abund) <- abund_cols
colnames(US3_abund) <- abund_cols

# checkM lineage, completeness, and contamination
stats_cols <- dput(scan(text = "bin marker_lineage uid num_genomes num_markers num_marker_sets 0 1 2 3 4 5+ completeness contamination strain_heterogeneity", what = ""))
US2_stats <- read_table2("/workdir/users/acv46/mgmAssembly/US2_5Nov2020_CAB/DASTool/checkM/US2_5Nov2020_checkM_lineage.txt", comment = "-", col_names = T)
US3_stats <- read_table2("/workdir/users/acv46/mgmAssembly/US3_3Nov2020_CAB/DASTool/checkM/US3_3Nov2020_checkM_lineage.txt", comment = "-", col_names = T)
colnames(US2_stats) <- stats_cols
colnames(US3_stats) <- stats_cols

# kraken taxa 
# merged with bash
## while read bin; do head -n 9 ${bin}.report.txt | sed "s/^/${bin}\t/g" >> merged_reports.txt; done < bins.txt
kraken_cols <- dput(scan(text = "bin k_percent k_clade_frags k_taxa_frags k_rank_code k_taxid k_name", what = ""))
US2_kraken <- read_tsv("/workdir/users/acv46/stool_PROSeq2/kraken2/US2_5Nov2020/merged_reports.txt", col_names = F)
US3_kraken <- read_tsv("/workdir/users/acv46/stool_PROSeq2/kraken2/US3_3Nov2020/merged_reports.txt", col_names = F)
colnames(US2_kraken) <- kraken_cols
colnames(US3_kraken) <- kraken_cols
US2_kraken <- US2_kraken %>%
  pivot_wider(., id_cols = c(bin),
              names_from = k_rank_code,
              values_from = c(k_name,k_percent)) %>%
  select(-c(k_name_R, k_percent_R)) %>%
  mutate_all(str_replace_all, ".*__", "") %>%
  mutate_all(str_replace_all, "\\.fa", "")
US3_kraken <- US3_kraken %>%
  pivot_wider(., id_cols = c(bin),
              names_from = k_rank_code,
              values_from = c(k_name,k_percent)) %>%
  select(-c(k_name_U, k_percent_U)) %>%
  mutate_all(str_replace_all, ".*__", "") %>%
  mutate_all(str_replace_all, "\\.fa", "")

```

## correlation graphs for longest contigs
### function to subset featurecounts data for contigs of given length
```{r}
# subset featurecounts to contigs >= 50K bp

#library(tidyverse)

big_contigs <- function(df, bp) {
  
  # df = featurecounts dataframe
  # bp = min length in bp to include
  
  length <- apply(X = df,
                  MARGIN = 1,
                  FUN = function(x){str_split(as_vector(x[2]), '_', simplify = T)[4]}) %>%
    as.numeric()
  
  df$length <- length
  
  new <- df[which(df$length >= bp),]
  
  colnames(new) <- dput(scan(text = "Geneid Chr Start End Strand Length Name product gene Note ID Parent PRO1 PRO2 RNA1 RNA2 length", what = ""))
  
  new
  
}

US2_bigcontigs <- big_contigs(US2_fcounts, 50000)
US3_bigcontigs <- big_contigs(US3_fcounts, 50000)
```

### function to plot correlations (+1 modified)
```{r}
plot_corr <- function(df, dir) {
  
  require(stats)
  require(ggplot2)
  require(staplr)
  require(scales)
  require(tidyverse)
  
  # df is a featurecounts dataframe, HARD-CODED COLNAMES
  # dir is the directory to write pdfs
  
  setwd(dir = dir)
  
  # create label from df name and split df by contigs
  lab <- deparse(substitute(df))
  contigs <- unique(df$Chr)

  # create dataframe to sort by RNA-seq reads
  df$RNA_sum <- df$RNA1 + df$RNA2
  to_sort <- aggregate(df$RNA_sum, by=list(contig = df$Chr), FUN = sum)
  
  # plot for each contig individually
  sapply(contigs,
         function(contig) {
           
           # create and reorder contig dataframe so non-CDS elements are plotted last
           df_sub <- df[which(df$Chr == contig),]
           df_sub1 <- df_sub[which(df_sub$Geneid == "CDS"),]
           df_sub2 <- df_sub[-which(df_sub$Geneid == "CDS"),]
           df_sub <- rbind(df_sub1, df_sub2)
           # get values for the total number of reads plotted on each axis
           sumP <- sum(df_sub$PRO1, df_sub$PRO2)
           sumR <- sum(df_sub$RNA1, df_sub$RNA2)
           # get values for spearman and pearson correlations
           spearman <- cor.test(x = df_sub$PRO1 + df_sub$PRO2 + 1,
                                y = df_sub$RNA1 + df_sub$RNA2 + 1,
                                method = "spearman",
                                conf.level = 0.95)
           pearson <- cor.test(x = df_sub$PRO1 + df_sub$PRO2 + 1,
                                y = df_sub$RNA1 + df_sub$RNA2 + 1,
                                method = "pearson",
                                conf.level = 0.95)
           # create dotplot with detailed title text
           ps <- ggplot(data = df_sub,
                    aes(x = (PRO1 + PRO2 + 1) / sum(PRO1,PRO2) * 10^3 ,
                        y = (RNA1 + RNA2 + 1) / sum(RNA1,RNA2) * 10^3)) +
             geom_point(mapping = aes(colour = Geneid)) +
             scale_y_log10(breaks = trans_breaks("log10", function(x) 10^x),
                           labels = trans_format("log10", math_format(10^.x))) +
             scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x),
                           labels = trans_format("log10", math_format(10^.x))) +
             ggtitle(paste(contig, "\n",
                           "ρ = ", round(spearman$estimate, digits = 4), ", r = ", round(pearson$estimate, digits = 4), "\n",
                           paste(nrow(df_sub)), " features", "\n",
                           sumP, " PRO-seq reads", "\n",
                           sumR, " RNA-seq reads", 
                           sep = "")) +
             theme_classic() +
             xlab("Mapped PRO-seq transcripts (+1) per thousand") +
             ylab("Mapped RNA-seq transcripts (+1) per thousand") +
             geom_smooth(method = lm, 
                         se = T, 
                         fullrange = T) +
             annotation_logticks(sides = "bl")
           # save each plot as a pdf
           fname <- paste(lab, contig, "partial.pdf", sep = "_")
           ggsave(filename = fname,
                  plot = ps,
                  device = cairo_pdf,
                  dpi = 600,
                  width = 5,
                  height = 4.5)
           
         })
  
  # create ordered pdf list by number of RNA-seq reads
  colnames(to_sort) <- c("pdf","RNA")
  to_sort$pdf <- paste(lab, to_sort$pdf, "partial.pdf", sep = "_")
  pdflist <- arrange(to_sort, desc(RNA))$pdf
  # combine pdfs into a single file
  staple_pdf(input_files = pdflist,
             output_filepath = file.path(dir, paste(lab, "corr_PROvRNA.pdf", sep = "_")))
  # remove individual pdfs
  do.call(file.remove, list(pdflist))
  
}  
```

### apply function
```{r}
plot_corr(US2_bigcontigs, "/workdir/users/acv46/stool_PROSeq2/figures/correlation")
plot_corr(US3_bigcontigs, "/workdir/users/acv46/stool_PROSeq2/figures/correlation")
```

## correlation graphs for HQ bins
### create tibble with featurecounts data, contig data, bin data
```{r}
merge_data <- function(fcounts, scaff2bin, abund, stats, gtdbtk, kraken) {
  
  # fcounts is featurecounts data
  # scaff2bin is the file connecting scaffolds to bins
  # abund is the checkM relative abudance data
  # stats is checkM stats on Completeness and Contam
  # gtdbtk is the gtdbtk taxa data
  # kraken is the trimmed down Kraken2 output
  
  # consider merging bracken output as well
  
  subdat <- fcounts[,c(1:8,11,13:16)]
  colnames(subdat) <- dput(scan(text = "type contig start end strand lengths name product id PRO1 PRO2 RNA1 RNA2", what = ""))
  subdat <- dplyr::inner_join(scaff2bin, subdat, by = "contig")
  subdat <- dplyr::inner_join(abund[,c(1,2,5,6)], subdat, by = "bin")
  subdat <- dplyr::inner_join(gtdbtk, subdat, by = "bin")
  subdat <- dplyr::inner_join(stats[,c(1,13,14)], subdat, by = "bin")
  subdat <- dplyr::inner_join(kraken, subdat, by = "bin")
  subdat
  
}

# apply merge_data
US2_alldat <- merge_data(US2_fcounts, US2_scaff2bin, US2_abund, US2_stats, US2_gtdbtk, US2_kraken)
US3_alldat <- merge_data(US3_fcounts, US3_scaff2bin, US3_abund, US3_stats, US3_gtdbtk, US3_kraken)
# subset for taxonomic levels
pgs_names <- dput(scan(text = "bin k_name_P k_name_G k_name_S k_name_S1 k_percent_P k_percent_G k_percent_S k_percent_S1 completeness contamination g_phylum g_genus g_species mbp percent_binned percent_community contig type lengths name product id PRO1 PRO2 RNA1 RNA2", what = ""))
US2_bins <- US2_alldat[,pgs_names]
US3_bins <- US3_alldat[,pgs_names]  
```
### function to plot correlations (+1 modified)
```{r}
plot_corr <- function(df, dir) {
  
  require(stats)
  require(ggplot2)
  require(staplr)
  require(scales)
  require(tidyverse)
  
  # df is a featurecounts dataframe, HARD-CODED COLNAMES
  # dir is the directory to write pdfs
  
  setwd(dir = dir)
  
  # create label from df name and split df by contigs
  lab <- deparse(substitute(df)) #%>% gsub("_.*", "", .)
  bins <- unique(df$bin)

  # create dataframe to sort by RNA-seq counts
  df$RNA_sum <- df$RNA1 + df$RNA2
  #df$PRO_sum <- df$PRO1 + df$PRO2 + 1
  #df$log_diff <- log2(df$PRO_sum / df$RNA_sum)
  #to_sort <- aggregate(df$log_diff, by=list(bin = df$bin), FUN = median)
  to_sort <- aggregate(df$RNA_sum, by=list(bin = df$bin), FUN = sum)
  
  # plot for each contig individually
  sapply(bins,
         function(bin) {
           
           # create and reorder contig dataframe so non-CDS elements are plotted last
           df_sub <- df[which(df$bin == bin),]
           df_sub1 <- df_sub[which(df_sub$type == "CDS"),]
           df_sub2 <- df_sub[-which(df_sub$type == "CDS"),]
           df_sub <- rbind(df_sub1, df_sub2)
           # get values for the total number of reads plotted on each axis
           sumP <- sum(df_sub$PRO1, df_sub$PRO2)
           sumR <- sum(df_sub$RNA1, df_sub$RNA2)
           # get values for spearman and pearson correlations
           spearman <- cor.test(x = df_sub$PRO1 + df_sub$PRO2 + 1,
                                y = df_sub$RNA1 + df_sub$RNA2 + 1,
                                method = "spearman",
                                conf.level = 0.95)
           pearson <- cor.test(x = df_sub$PRO1 + df_sub$PRO2 + 1,
                                y = df_sub$RNA1 + df_sub$RNA2 + 1,
                                method = "pearson",
                                conf.level = 0.95)
           # create dotplot with detailed title text
           ps <- ggplot(data = df_sub,
                    aes(x = (PRO1 + PRO2 + 1) / sum(PRO1,PRO2) * 10^3 ,
                        y = (RNA1 + RNA2 + 1) / sum(RNA1,RNA2) * 10^3)) +
             geom_point(mapping = aes(colour = type)) +
             scale_y_log10(breaks = trans_breaks("log10", function(x) 10^x),
                           labels = trans_format("log10", math_format(10^.x))) +
             scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x),
                           labels = trans_format("log10", math_format(10^.x))) +
             ggtitle(paste("name = ", bin, ", ", paste(round(unique(df_sub$mbp), digits = 3)), " Mbp", "\n",
                           "ρ = ", round(spearman$estimate, digits = 4), ", r = ", round(pearson$estimate, digits = 4), "\n",
                           paste(nrow(df_sub)), " features", "\n",
                           paste(length(unique(df_sub$contig))), " contigs", "\n",
                           sumP, " PRO-seq reads", "\n",
                           sumR, " RNA-seq reads", "\n",
                           paste(unique(df_sub$completeness)), "% complete", "\n",
                           paste(unique(df_sub$contamination)), "% contaminated", "\n",
                           "GTDB-Tk: [p]_", paste(unique(df_sub$g_phylum)), "; [g]_", paste(unique(df_sub$g_genus)), "; [s]_", paste(unique(df_sub$g_species)), 
                           "\n",
                           "Kraken2 HumGut: [p]_", paste(unique(df_sub$k_name_P))," (", paste(unique(df_sub$k_percent_P)), "%); [g]_", 
                           paste(unique(df_sub$k_name_G)), " (", paste(unique(df_sub$k_percent_G)), "%); [s]_",  paste(unique(df_sub$k_name_S)), " (", 
                           paste(unique(df_sub$k_percent_S)), "%)",
                           "\n",
                           "checkm community abundance: ", paste(round(unique(df_sub$percent_community), digits = 3)),"%",
                           sep = "")) +
             theme_classic() +
             theme(plot.title = element_text(size = 5, family = "mono"),
                   axis.title.x = element_text(size = 7, family = "mono"),
                   axis.title.y = element_text(size = 7, family = "mono")) +
             xlab("Mapped PRO-seq transcripts (+1) per thousand") +
             ylab("Mapped RNA-seq transcripts (+1) per thousand") +
             geom_smooth(method = lm, 
                         se = T, 
                         fullrange = T) +
             annotation_logticks(sides = "bl")
           # save each plot as a pdf
           fname <- paste(lab, bin, "partial.pdf", sep = "_")
           ggsave(filename = fname,
                  plot = ps,
                  device = cairo_pdf,
                  dpi = 600,
                  width = 5,
                  height = 4.5)
           
         })
  
  # create ordered pdf list by number of RNA-seq reads
  colnames(to_sort) <- c("pdf","RNA")
  to_sort$pdf <- paste(lab, to_sort$pdf, "partial.pdf", sep = "_")
  pdflist <- arrange(to_sort, desc(RNA))$pdf
  # combine pdfs into a single file
  staple_pdf(input_files = pdflist,
             output_filepath = file.path(dir, paste(lab, "corr_PROvRNA.pdf", sep = "_")))
  # remove individual pdfs
  do.call(file.remove, list(pdflist))
  
}  
```

### apply function
```{r}
plot_corr(US2_bins, "/workdir/users/acv46/stool_PROSeq2/figures/correlation")
plot_corr(US3_bins, "/workdir/users/acv46/stool_PROSeq2/figures/correlation")
```

### function to make combine correlations as boxplots or violin plots
```{r}
plot_box <- function(df, dir, pal, pdf = F, fname, type) {
  
  # df is data, see above
  # dir is directory to generate pdf
  # pal is palette to use for coloration
  # pdf is a switch, T = print pdf
  # fname is basename for pdf file
  # type is "boxplot" or "violin"
  
  require(stats)
  require(ggplot2)
  require(tidyverse)
  #require(gridExtra)
  require(grid)
  require(scales)
  #require(gtable)
  #require(cowplot)
  #require(mmtable2)
  #require(gt)
  # note: mmtable2 requires htmltools v >= 0.5.1  
  
  df <- df %>% drop_na(k_name_S) %>% filter(completeness > 10) %>% filter(contamination < 10)
  
  PRO_norm <- sum(df$PRO1, df$PRO2) / 10^3
  RNA_norm <- sum(df$RNA1, df$RNA2) / 10^3
  
  df$PRO_sum <- df$PRO1 + df$PRO2 + 1
  df$RNA_sum <- df$RNA1 + df$RNA2 + 1
  
  df$lab <- paste0(df$k_name_S, " (", df$k_name_S1,")")
  
  # reorder based on median
  df$lab <- reorder(df$lab, (df$PRO_sum/PRO_norm)/(df$RNA_sum/RNA_norm), median)
  
  # create count labels
  df$i <- 1
  labs <- aggregate(i ~ lab, df, sum)
  labs_mbp <- unique(df[,c(30,15)])
  labs_per <- unique(df[,c(30,17)])
  
  if (type == "boxplot") {
  
    pb <- ggplot(data = df) +
      geom_boxplot(mapping = aes(x = lab,
                                y = (PRO_sum/PRO_norm)/(RNA_sum/RNA_norm),
                                fill = k_name_P,
                                color = k_name_P),
                   alpha = 0.6,
                   outlier.alpha = 0.5) +
      scale_y_log10(breaks = trans_breaks("log10", function(x) 10^x),
                             labels = trans_format("log10", math_format(10^.x))) +
      theme_classic() +
      theme(axis.title.x = element_text(size = 9),
            axis.title.y = element_text(size = 12),
            axis.text.x = element_text(size = 9),
            plot.margin = unit(c(1.5, 7, 0.5, 0.5), "cm"),
            legend.position = "") +
      guides(fill = guide_legend(nrow=5, byrow = TRUE)) +
      geom_hline(yintercept = 1,
                 linetype = "dashed") +
      geom_hline(yintercept = 10^5.8,
                 linetype = "solid") +
      geom_hline(yintercept = 10^6.8,
                 linetype = "solid") +
      geom_hline(yintercept = 10^7.8,
                 linetype = "solid") +
      geom_text(data = labs,
                aes(x = lab, y = 10^5.7, label = i),
                angle = 0, size = 3, hjust = 1) +
      geom_text(data = labs_mbp,
                aes(x = lab, y = 10^6.7, label = format(round(mbp, digits = 2), nsmall = 2)),
                angle = 0, size = 3, hjust = 1) +
      geom_text(data = labs_per,
                aes(x = lab, y = 10^7.7, label = format(round(percent_community, digits = 2), nsmall = 2)),
                angle = 0, size = 3, hjust = 1) +
      geom_text(aes(x = nrow(labs) + 1, y = 10^5.2, label = "Features"),
                angle = 45, size = 3.5, vjust = 0.5, hjust = 0) +
      geom_text(aes(x = nrow(labs) + 1, y = 10^6.2, label = "Mbp"),
                angle = 45, size = 3.5, vjust = 0.5, hjust = 0) +
      geom_text(aes(x = nrow(labs) + 1, y = 10^7.2, label = "Community %"),
                angle = 45, size = 3.5, vjust = 0.5, hjust = 0) +
      scale_fill_manual(values = pal, name = "Phylum") +
      scale_color_manual(values = pal, name = "Phylum") +
      xlab("") +
      ylab("Normalized PRO-seq enrichment") +
      coord_flip(clip = "off", ylim = c(10^-4, 10^4))
    
    # for (j in 1:nrow(labs))  {
    #   pb <- pb + annotation_custom(
    #     grob = textGrob(label = labs$i[j], hjust = 0, gp = gpar(cex = 1.5)),
    #     ymin = j,      # Vertical position of the textGrob
    #     ymax = j,
    #     xmin = 10^5.5,         # Note: The grobs are positioned outside the plot area
    #     xmax = 10^5.5)
    #   }  
    
  # # create metadata table
    # tb1 <- df[c(4,13,15)] %>% table() %>% as_tibble %>% filter_at(., vars(n), all_vars((.) != 0)) %>%
    #   transform(., mbp = as.numeric(mbp), percent_community = as.numeric(percent_community), n = as.numeric(n)) %>% 
    #    mutate_if(is.numeric, round, digits = 2)
     
  # # create second ggplot object
  #   pt <- grid.table(tb1)
  # 
  #   plot_grid(pb, pt, labels = "AUTO")
    
    setwd(dir = dir)
    
    if (isTRUE(pdf)) {
    
      ggsave(filename = paste0(fname,"_boxplot.png"),
                    plot = pb,
                    device = "png",
                    dpi = 600,
                    width = 9,
                    height = 6)
        
    }
  
  } else if (type == "violin") {
    
    pb <- ggplot(data = df) +
      geom_violin(mapping = aes(x = k_name_S,
                                y = (PRO_sum/PRO_norm)/(RNA_sum/RNA_norm),
                                fill = k_name_P)) +
      scale_y_log10(breaks = trans_breaks("log10", function(x) 10^x),
                             labels = trans_format("log10", math_format(10^.x))) +
      theme_classic() +
      theme(axis.title.x = element_text(size = 12),
            axis.title.y = element_text(size = 12),
            axis.text.x = element_text(size = 12),
            plot.margin=unit(c(1,1,1,1),"cm")) +
      geom_hline(yintercept = 1) +
      # geom_text(data = labs,
      #           aes(x = k_name_S, y = 10^7, label = i)) +
      geom_text(data = labs,
                aes(x = k_name_S, y = 10^6, label = i), angle = 0, size = 3) +
      scale_fill_manual(values = pal, name = "Phylum") +
      xlab("") +
      ylab("Normalized PRO-seq enrichment") +
      coord_flip()
    
    setwd(dir = dir)
    
    if (isTRUE(pdf)) {
    
      ggsave(filename = paste0(fname,"_violin.pdf"),
                    plot = pb,
                    device = cairo_pdf,
                    dpi = 600,
                    width = 7,
                    height = 5)
        
    }
  }
  
  pb
} 


pal1 <- c("#f3de2c","#e57a44","#4c2a85","#00cfc1","#d84797")
pal2 <- c("#337ca0","#3ec300","#fffc31","#fe9000","#e13700")
pal3 <- c("#e08dac","#6a7fdb","#ee7b30","#45cb85","#ede580")
pal4 <- c("#ffc857","#56a3a6","#e9724c","#c5283d","#4e4187")
  
US2box <- plot_box(US2_bins, dir = "/workdir/users/acv46/stool_PROSeq2/figures/correlation", pal = pal4, type = "boxplot", 
         fname = "US2_perFeature_fillPhyla_bySpecies_v5_noLegend", pdf = F)
US3box <- plot_box(US3_bins, dir = "/workdir/users/acv46/stool_PROSeq2/figures/correlation", pal = pal4, type = "boxplot",
         fname = "US3_perFeature_fillPhyla_bySpecies_v5_noLegend", pdf = F)

US2box
US3box
```

### ggsave
```{r}
#library(Cairo)
setwd("/workdir/users/acv46/stool_PROSeq2/figures/correlation")
# pdf(file = "US2_bins_corr_PROvRNA_v6.pdf",
#        useDingbats = F,
#        width = 7,
#        height = 5)
# 
# print(US2box)
# dev.off()
# 
# pdf(file = "US3_bins_corr_PROvRNA_v6.pdf",
#        useDingbats = F,
#        width = 7,
#        height = 5)
# 
# US3box
# dev.off()

ggsave(filename = "US2_bins_corr_PROvRNA_v6_newfcounts.pdf",
       plot = US2box,
       device = cairo_pdf,
       dpi = 300,
       width = 7,
       height = 7)

ggsave(filename = "US3_bins_corr_PROvRNA_v6_newfcounts.pdf",
       plot = US3box,
       device = cairo_pdf,
       dpi = 300,
       width = 7,
       height = 7)
```

### function to make combine correlations as dotplots, overlayed
```{r}
plot_box2 <- function(df, dir, pal, pdf = F, fname, type) {
  
  # df is data, see above
  # dir is directory to generate pdf
  # pal is palette to use for coloration
  # pdf is a switch, T = print pdf
  # fname is basename for pdf file
  # type is "boxplot" or "violin"
  
  require(stats)
  require(ggplot2)
  require(tidyverse)
  #require(gridExtra)
  require(grid)
  #require(gtable)
  #require(cowplot)
  #require(mmtable2)
  #require(gt)
  # note: mmtable2 requires htmltools v >= 0.5.1  
  
  df <- df %>% drop_na(k_name_S) %>% filter(completeness > 10) %>% filter(contamination < 10)
  
  PRO_norm <- sum(df$PRO1, df$PRO2) / 10^3
  RNA_norm <- sum(df$RNA1, df$RNA2) / 10^3
  
  df$PRO_sum <- df$PRO1 + df$PRO2 + 1
  df$RNA_sum <- df$RNA1 + df$RNA2 + 1
  
  df$lab <- paste0(df$k_name_S, " (", df$k_name_S1,")")
  
  # reorder based on median
  df$lab <- reorder(df$lab, (df$PRO_sum/PRO_norm)/(df$RNA_sum/RNA_norm), median)
  
  # create count labels
  df$i <- 1
  labs <- aggregate(i ~ lab, df, sum)
  labs_mbp <- unique(df[,c(30,15)])
  labs_per <- unique(df[,c(30,17)])
  
  if (type == "boxplot") {
  
    pb <- ggplot(data = df[which(df$type != "CDS"),]) +
      # geom_boxplot(mapping = aes(x = lab,
      #                           y = (PRO_sum/PRO_norm)/(RNA_sum/RNA_norm)),
      #              alpha = 0,
      #              outlier.shape = NA,
      #              color = "gray30") +
      geom_boxplot(mapping = aes(color = type,
                                 fill = type,
                                 x = k_name_S,
                                 y = (PRO_sum/PRO_norm)/(RNA_sum/RNA_norm)),
               position = "dodge",
               alpha = 0.6,
               size = 0.4) +
      scale_y_log10(breaks = trans_breaks("log10", function(x) 10^x),
                             labels = trans_format("log10", math_format(10^.x))) +
      theme_classic() +
      theme(axis.title.x = element_text(size = 9),
            axis.title.y = element_text(size = 12),
            axis.text.x = element_text(size = 9),
            #plot.margin = unit(c(3, 8, 1, 1), "cm"),
            legend.position = "right") +
      guides(fill = guide_legend(nrow=5, byrow = TRUE)) +
      geom_hline(yintercept = 1,
                 linetype = "dashed") +
      geom_hline(yintercept = 10^5.6,
                 linetype = "solid") +
      geom_hline(yintercept = 10^7.1,
                 linetype = "solid") +
      geom_hline(yintercept = 10^8.6,
                 linetype = "solid") +
      geom_text(data = labs,
                aes(x = lab, y = 10^5.5, label = i),
                angle = 0, size = 3, hjust = 1) +
      geom_text(data = labs_mbp,
                aes(x = lab, y = 10^7, label = format(round(mbp, digits = 2), nsmall = 2)),
                angle = 0, size = 3, hjust = 1) +
      geom_text(data = labs_per,
                aes(x = lab, y = 10^8.5, label = format(round(percent_community, digits = 2), nsmall = 2)),
                angle = 0, size = 3, hjust = 1) +
      geom_text(aes(x = nrow(labs) + 1, y = 10^5, label = "Features"),
                angle = 45, size = 3.5, vjust = 0.5, hjust = 0) +
      geom_text(aes(x = nrow(labs) + 1, y = 10^6.5, label = "Mbp"),
                angle = 45, size = 3.5, vjust = 0.5, hjust = 0) +
      geom_text(aes(x = nrow(labs) + 1, y = 10^8, label = "Community %"),
                angle = 45, size = 3.5, vjust = 0.5, hjust = 0) +
      #scale_fill_manual(values = pal, name = "Phylum") +
      scale_color_manual(values = pal, name = "Type") +
      xlab("") +
      ylab("Normalized PRO-seq enrichment") +
      coord_flip(clip = "off", ylim = c(10^-4, 10^4))
    
    # for (j in 1:nrow(labs))  {
    #   pb <- pb + annotation_custom(
    #     grob = textGrob(label = labs$i[j], hjust = 0, gp = gpar(cex = 1.5)),
    #     ymin = j,      # Vertical position of the textGrob
    #     ymax = j,
    #     xmin = 10^5.5,         # Note: The grobs are positioned outside the plot area
    #     xmax = 10^5.5)
    #   }  
    
  # # create metadata table
    # tb1 <- df[c(4,13,15)] %>% table() %>% as_tibble %>% filter_at(., vars(n), all_vars((.) != 0)) %>%
    #   transform(., mbp = as.numeric(mbp), percent_community = as.numeric(percent_community), n = as.numeric(n)) %>% 
    #    mutate_if(is.numeric, round, digits = 2)
     
  # # create second ggplot object
  #   pt <- grid.table(tb1)
  # 
  #   plot_grid(pb, pt, labels = "AUTO")
    
    setwd(dir = dir)
    
    if (isTRUE(pdf)) {
    
      ggsave(filename = paste0(fname,"_boxplot.png"),
                    plot = pb,
                    device = "png",
                    dpi = 600,
                    width = 9,
                    height = 10)
        
    }
  
  } 
  
  pb
} 


pal1 <- c("#f3de2c","#e57a44","#4c2a85","#00cfc1","#d84797")
pal2 <- c("#337ca0","#3ec300","#fffc31","#fe9000","#e13700")
pal3 <- c("#e08dac","#6a7fdb","#ee7b30","#45cb85","#ede580")
pal4 <- c("#ffc857","#56a3a6","#e9724c","#c5283d","#4e4187")
  
plot_box2(US2_bins, dir = "/workdir/users/acv46/stool_PROSeq2/figures/correlation", pal = pal4, type = "boxplot", 
         fname = "US2_perFeature_fillPhyla_bySpecies_v5_noLegend", pdf = F)
plot_box2(US3_bins, dir = "/workdir/users/acv46/stool_PROSeq2/figures/correlation", pal = pal4, type = "boxplot",
         fname = "US3_perFeature_fillPhyla_bySpecies_v5_noLegend", pdf = F)
```
### function to make boxplots with rRNA barplots annotations
```{r}
plot_box <- function(df, dir, pal, pdf = F, fname, type) {
  
  # df is data, see above
  # dir is directory to generate pdf
  # pal is palette to use for coloration
  # pdf is a switch, T = print pdf
  # fname is basename for pdf file
  # type is "boxplot" or "violin"
  
  require(stats)
  require(ggplot2)
  require(tidyverse)
  #require(gridExtra)
  require(grid)
  require(ggpubr)
  #require(gtable)
  #require(cowplot)
  #require(mmtable2)
  #require(gt)
  # note: mmtable2 requires htmltools v >= 0.5.1  
  
  df <- df %>% drop_na(k_name_S) %>% filter(completeness > 50) %>% filter(contamination < 10)
  
  PRO_norm <- sum(df$PRO1, df$PRO2) / 10^3
  RNA_norm <- sum(df$RNA1, df$RNA2) / 10^3
  
  df$PRO_sum <- df$PRO1 + df$PRO2 + 1
  df$RNA_sum <- df$RNA1 + df$RNA2 + 1
  
  #df$lab <- paste0(df$k_name_S, " (", df$k_name_S1,")")
  df$lab <- paste0(df$k_name_S)
  
  # reorder based on median
  df$lab <- reorder(df$lab, (df$PRO_sum/PRO_norm)/(df$RNA_sum/RNA_norm), median)
  
  # create count labels
  df$i <- 1
  labs <- aggregate(i ~ lab, df, sum)
  labs_mbp <- unique(df[,c(30,15)])
  labs_per <- unique(df[,c(30,17)])
  labs_complete <- unique(df[,c(30,10)])
  labs_contam <- unique(df[,c(30,11)])
  
  if (type == "boxplot") {
  
    pb <- ggplot(data = df) +
      geom_boxplot(mapping = aes(x = lab,
                                y = (PRO_sum/PRO_norm)/(RNA_sum/RNA_norm),
                                fill = k_name_P,
                                color = k_name_P),
                   alpha = 0.6,
                   outlier.alpha = 0.5) +
      scale_y_log10(breaks = trans_breaks("log10", function(x) 10^x),
                             labels = trans_format("log10", math_format(10^.x))) +
      theme_classic() +
      theme(axis.title.x = element_text(size = 11),
            axis.title.y = element_text(size = 11),
            axis.text.x = element_text(size = 11),
            #axis.text.y = element_blank(),
            #plot.margin = unit(c(1.5, 7, 0.5, 0.5), "cm"),
            legend.position = "right") +
      guides(fill = guide_legend(nrow=5, byrow = TRUE)) +
      geom_hline(yintercept = 1,
                 linetype = "dashed") +
      # geom_text(data = labs,
      #           aes(x = lab, y = 10^5.7, label = i),
      #           angle = 0, size = 3, hjust = 1) +
      # geom_text(data = labs_mbp,
      #           aes(x = lab, y = 10^6.7, label = format(round(mbp, digits = 2), nsmall = 2)),
      #           angle = 0, size = 3, hjust = 1) +
      scale_fill_manual(values = c("Bacteroidota" = pal[2],
                                   "Firmicutes_A" = pal[3],
                                   "Actinobacteriota" = pal[1],
                                   "Firmicutes_C" = pal[4],
                                   "Proteobacteria" = pal[5]),
                        name = "Phylum") +
      scale_color_manual(values = c("Bacteroidota" = pal[2],
                                   "Firmicutes_A" = pal[3],
                                   "Actinobacteriota" = pal[1],
                                   "Firmicutes_C" = pal[4],
                                   "Proteobacteria" = pal[5]),
                        name = "Phylum") +
      xlab("") +
      ylab("Normalized PRO-seq enrichment") +
      coord_flip(clip = "off", ylim = c(10^-4, 10^4))
    
    pbar1 <- ggplot() + 
      geom_bar(data = labs_per,
               aes(x = lab, y = percent_community),
               stat = "identity") +
      theme_classic() +
      theme(axis.text.y = element_blank(),
            axis.title.y = element_blank(),
            axis.ticks.y = element_blank(),
            axis.title.x = element_text(size = 11),
            axis.text.x = element_text(size = 11)) +
      ylab("% Community") +
      scale_y_continuous(breaks = c(0,round(max(labs_per$percent_community),0))) +
      coord_flip(clip = "off")
    
    pbar2 <- ggplot() + 
      geom_bar(data = labs_complete,
               aes(x = lab, y = completeness),
               stat = "identity") +
      theme_classic() +
      theme(axis.text.y = element_blank(),
            axis.title.y = element_blank(),
            axis.ticks.y = element_blank(),
            axis.title.x = element_text(size = 11),
            axis.text.x = element_text(size = 11)) +
      ylab("% Complete") +
      scale_y_continuous(breaks = c(0,100)) +
      coord_flip(clip = "off")
    
    pbar3 <- ggplot() + 
      geom_bar(data = labs_contam,
               aes(x = lab, y = contamination),
               stat = "identity") +
      theme_classic() +
      theme(axis.text.y = element_blank(),
            axis.title.y = element_blank(),
            axis.ticks.y = element_blank(),
            axis.title.x = element_text(size = 11),
            axis.text.x = element_text(size = 11)) +
      ylab("% Contam") +
      scale_y_continuous(breaks = c(0,round(max(labs_contam$contamination),0))) +
      coord_flip(clip = "off")
    
    setwd(dir = dir)
    
    if (isTRUE(pdf)) {
    
      ggsave(filename = paste0(fname,"_boxplot.png"),
                    plot = pb,
                    device = "png",
                    dpi = 600,
                    width = 9,
                    height = 6)
    }
  
  ggarrange(pb,pbar1,pbar2,pbar3,
            widths = c(6,1,1,1),
            nrow = 1)
 
  }
  
}


pal1 <- c("#f3de2c","#e57a44","#4c2a85","#00cfc1","#d84797")
pal2 <- c("#337ca0","#3ec300","#fffc31","#fe9000","#e13700")
pal3 <- c("#e08dac","#6a7fdb","#ee7b30","#45cb85","#ede580")
pal4 <- c("#ffc857","#56a3a6","#e9724c","#c5283d","#4e4187")
  
US2box <- plot_box(US2_bins, dir = "/workdir/users/acv46/stool_PROSeq2/figures/correlation", pal = pal4, type = "boxplot", 
         fname = "US2_perFeature_fillPhyla_bySpecies_v5_noLegend", pdf = F)
US3box <- plot_box(US3_bins, dir = "/workdir/users/acv46/stool_PROSeq2/figures/correlation", pal = pal4, type = "boxplot",
         fname = "US3_perFeature_fillPhyla_bySpecies_v5_noLegend", pdf = F)

US2box
US3box
```

### ggsave
```{r}
setwd("/workdir/users/acv46/stool_PROSeq2/figures/correlation/")

ggsave_pngpdf <- function(plot,name) {

  ggsave(filename = paste0(name, "_bins_PROvRNA_bars_v11_nolab.png"),
         plot = plot, width = 4.5, height = 3, dpi = 600)
  ggsave(filename = paste0(name, "_bins_PROvRNA_bars_v11.pdf"),
         plot = plot, width = 4.5, height = 3, useDingbats = F)

}

ggsave_pngpdf(US2box, "US2")
ggsave_pngpdf(US3box, "US3")
```


## iRep and GRID correlations 

### read in data 
```{r}
# requires "alldat" data generated above
read_grid <- function(griddat) {
  
  require(tidyverse)
  read_delim(file = griddat,
             delim = "\t",
             col_names = T) %>%
    select(c("Genome","GRiD"))
  
}

setwd("/workdir/users/acv46/stool_PROSeq2/deseq/grid")
US2_grid <- read_grid("US2_5Nov2020_out/US2_5Nov2020.interleaved.GRiD.txt")
US3_grid <- read_grid("US3_3Nov2020_out/US3_3Nov2020.interleaved.GRiD.txt")
```

### plot GRiD against median PRO-seq signal
```{r}
get_grid <- function(df, griddat) {
  
  # df is "sample_bins" dataframe
  # grid is grid data
  
  require(stats)
  require(ggplot2)
  require(tidyverse)
  
  PRO_norm <- sum(df$PRO1, df$PRO2) / 10^3
  RNA_norm <- sum(df$RNA1, df$RNA2) / 10^3
  
  df$PRO_sum <- df$PRO1 + df$PRO2 + 1
  df$RNA_sum <- df$RNA1 + df$RNA2 + 1
  
  df$normval <- (df$PRO_sum/PRO_norm)/(df$RNA_sum/RNA_norm)
  
  fd <- df %>% 
        group_by(bin) %>% 
        summarise(medval = mean(normval))
  
  fd$grid <- griddat[match(fd$bin, griddat$Genome),2] %>% as_vector() %>% unname()
  
  fd$samp <- deparse(substitute(griddat)) %>% gsub("_.*","",.) %>% rep(nrow(fd))
  
  fd

} 
  
US2_gdat <- get_grid(US2_bins, US2_grid)
US3_gdat <- get_grid(US3_bins, US3_grid)

gdat <- rbind(US2_gdat,US3_gdat)

ggplot(data = gdat,
       mapping = aes(y = log10(medval),
                     x = grid,
                     color = samp,
                     fill = samp)) +
  geom_smooth(method = "lm",
              alpha = 0.1) +
  geom_point(size = 3) +
  theme_classic() +
  xlab("Growth Rate Index") +
  ylab("log10(median PRO-seq enrichment)") +
  labs(color = "Sample", fill = "Sample") +
  theme(axis.text = element_text(size=12),
        axis.title = element_text(size=14),
        legend.text = element_text(size = 14),
        legend.title = element_text(size = 15))
```

# CRISPR spacers
```{r}
# plot coverage across CRISPR array
# demarcate spacers and repeats
# add a sequence logo representing repeat sequence
```

## read in minced gff data
```{r}
require(tidyverse)

read_minced <- function(gff) {
  
  cnames <- dput(scan(text = "contig source type start end score strand phase attributes", what = ""))
  
  df1 <- read_tsv(file = gff,
           col_names = cnames,
           comment = "#") %>% 
    separate(., "attributes", into = c("id","number","drop1","drop2"), fill = "right", sep = ";") %>%
    mutate_all(str_replace_all, ".*=", "")
  
  df1 <- df1[which(is.na(df1$drop1)),]
  df1 <- df1[,c(1:10)]
  
  
}

US2_crispr <- read_minced("/workdir/users/acv46/stool_PROSeq2/phage/minced_out/standalone/US2/US2.gff")
US3_crispr <- read_minced("/workdir/users/acv46/stool_PROSeq2/phage/minced_out/standalone/US3/US3.gff")
```

## read in repeat and spacer sequences
```{r}

read_mess <- function(file) {
  
  # edit in shell first
  # grep -v "POSITION" US3.txt | awk 'NF' | grep -v 'Repeats' | grep -v '\-\-' | sed "s/CRISPR /CRISPR_/g" | sed "s/Range.*//g" > US3_edit.txt
  
  require(stringr)
  require(dplyr)

  df1 <- read.table(file = file, header = F, fill = T)

  crispy <- df1 %>% group_by(grp = cumsum(str_detect(V1, 'CRISPR'))) %>% 
    mutate(CRISPR = dplyr::first(V1)) %>%
    dplyr::slice(-1) %>%
    ungroup %>%
    type.convert(as.is = TRUE) %>%
    select(CRISPR, everything(), -grp)
  
  crispy <- crispy[,1:4]
  colnames(crispy) <- c("id","position","repeat","spacer")
  
  print(crispy, quote = F)
  
  
}

US2_seqs <- read_mess("/workdir/users/acv46/stool_PROSeq2/phage/minced_out/standalone/US2/US2_edit.txt")
US3_seqs <- read_mess("/workdir/users/acv46/stool_PROSeq2/phage/minced_out/standalone/US3/US3_edit.txt")

```

## read in Cas genes
```{r}
# read in prokka-annotated Cas genes from allcontigs gtfs
# subset from full gtf with bash
# grep -i "CRISPR" US3_allcontigs_CUSTOM_FType.gtf | grep "CDS" > US3_CAS_genes.gtf

# require(rtracklayer)
# 
# read_cas <- function(gtf) {
#   
#   df <- rtracklayer::import(gtf)
#   df <- as.data.frame(df)
#   colnames(df)[1] <- "contig"
#   
#   df
#   
# }

read_gtf <- function(file) {
  
  require(tidyverse)
  cnames <- c("seqname","source","feature","start","end","score","strand","frame","attribute")
  
  # read in raw gtf as tsv and remove comment rows
  messy <- read_tsv(file, col_names = F, comment = "#") %>%
    `colnames<-`(cnames)
  
  # get the unique attribute types
  # this assumes there are no spaces in the attribute names
  att_names <- messy %>%
    select(attribute) %>%
    apply(., MARGIN = 1, FUN = str_split, pattern = '"; ') %>%
    unlist() %>% trimws() %>% trimws(whitespace = ";") %>%
    sub(" .*$", "", .) %>% unique()
  
  att_names <- att_names[att_names != ""]
    
  # for each attribute type, create column
  # apply over gtf to fill in rows where attribute type is found
  for (att in att_names) {
    
    colatt <- apply(messy, MARGIN = 1, function(x) {

      var <- str_extract(string = x[9],
                         pattern = sprintf('";\\s+%1$s[^;]+|^%1$s[^;]+;[^"]+"', att)) %>% 
        trimws(whitespace = '["; ]+', which = 'left') %>% 
        str_extract('(?<=")[^"]+(?=")')
      
    })
    
    messy <- messy %>% add_column("{att}" := colatt)
    
  }
  
  # remove original attribute column
  messy %>% select(-c(attribute))
  
}

setwd("/workdir/users/acv46/stool_PROSeq2/deseq/prokka")

US2_cas <- read_gtf("/workdir/users/acv46/stool_PROSeq2/deseq/prokka/US2_allcontigs/US2_CAS_genes.gtf")
US3_cas <- read_gtf("/workdir/users/acv46/stool_PROSeq2/deseq/prokka/US3_allcontigs/US3_CAS_genes.gtf")
```
## read in promoter data
```{r}
# annotated with NNPP2.2
# see script at /workdir/users/acv46/stool_PROSeq2/scripts/get_promoters.sh

require(tidyverse)

read_nnpp22 <- function(file) {
  
  cnames <- dput(scan(text = "contig number start end signal sequence score", what = ""))
  
  df1 <- read_delim(file = file,
           col_names = cnames,
           delim = " ") %>%
    arrange(contig) %>%
    filter(score > 0.95)
  
  df1$strand <- sign(df1$end - df1$start)
  
  df1
  
}

US2_promoter <- read_nnpp22("/workdir/users/acv46/stool_PROSeq2/promoters/US2_promoters.txt")
US3_promoter <- read_nnpp22("/workdir/users/acv46/stool_PROSeq2/promoters/US3_promoters.txt")
```

## read in bin2scaffold and taxa data
```{r}
# see peak calling and motifs section for code to create _bindat objects
```

## read in coverage data, subset for contigs with crispr arrays, then delete large dataframe
```{r}
get_coverage <- function(file, vector) {

  # file is the coverage file
  # vector is a vector of contigs for positive subsetting
  
  coverage <- read_delim(file = file,
                         delim = "\t",
                         col_names = T)
  
  colnames(coverage) <- c("contig","position","PRO_minus","PRO_plus","RNA_minus","RNA_plus")
  
  PROsum <- sum(coverage$PRO_minus + coverage$PRO_plus)
  RNAsum <- sum(coverage$RNA_minus + coverage$RNA_plus)
  
  name <- dput(file) %>% str_replace("_.*", "")
  
  coverage_sub <- coverage[coverage$contig %in% vector,]
  
  # flip for PRO-seq
  
  coverage_sub$PRO_plus_norm <-  (coverage_sub$PRO_minus * 10^6) / PROsum 
  coverage_sub$PRO_minus_norm <-  -(coverage_sub$PRO_plus * 10^6) / PROsum
  coverage_sub$RNA_minus_norm <- -(coverage_sub$RNA_minus * 10^6) / RNAsum
  coverage_sub$RNA_plus_norm <-   (coverage_sub$RNA_plus * 10^6) / RNAsum
  
  coverage_sub$PRO_plus_raw <-  coverage_sub$PRO_minus 
  coverage_sub$PRO_minus_raw <-  -(coverage_sub$PRO_plus)
  coverage_sub$RNA_minus_raw <- -(coverage_sub$RNA_minus)
  coverage_sub$RNA_plus_raw <-   coverage_sub$RNA_plus
  
  coverage_sub <- coverage_sub[-c(3:6)] %>% pivot_longer(cols = c("PRO_plus_raw","PRO_minus_raw","RNA_minus_raw","RNA_plus_raw",
                                                         "PRO_plus_norm","PRO_minus_norm","RNA_minus_norm","RNA_plus_norm"))
  
  coverage_sub
  
}

setwd("/workdir/users/acv46/stool_PROSeq2/deseq/bam/pileup")
US2_cov <- get_coverage("US2_coverage_q30.txt", unique(US2_crispr$contig))
US3_cov <- get_coverage("US3_coverage_q30.txt", unique(US3_crispr$contig))
US2_cov_PRO <- US2_cov[grepl("PRO", US2_cov$name),] %>% arrange(desc(name))
US3_cov_PRO <- US3_cov[grepl("PRO", US3_cov$name),] %>% arrange(desc(name))
US2_cov_raw <- US2_cov[grepl("raw", US2_cov$name),] %>% arrange(desc(name))
US3_cov_raw <- US3_cov[grepl("raw", US3_cov$name),] %>% arrange(desc(name))

#rm(US2_cov)
#rm(US3_cov)

```

## read in coverage data: 3', 5', and full intervals for all libraries, q>=30
```{r}
get_coverage <- function(file, vector) {

  # file is the coverage file
  # vector is a vector of contigs for positive subsetting
  
  coverage <- read_delim(file = file,
                         delim = "\t",
                         col_names = T)
  
  # make sure column names are correct
  
  cols <- dput(scan(text = "contig position PRO_m_3 PRO_m_5 PRO_m_full PRO_p_3 PRO_p_5 PRO_p_full RNA_m_full RNA_p_full", what = ""))
  
  colnames(coverage) <- cols
  name <- dput(file) %>% str_replace("_.*", "")
  coverage_sub <- coverage[coverage$contig %in% vector,]
  coverage_sub <- coverage_sub %>% pivot_longer(cols = cols[-c(1:2)])
  coverage_sub$end <- coverage_sub$name %>% sub(".*_", "", .)
  coverage_sub$type <- coverage_sub$name %>% sub("_.*", "", .) %>% paste0(.,"-seq")
  coverage_sub <- coverage_sub %>% dplyr::mutate(., value = ifelse(grepl("_m_", name), value * -1, value))
  coverage_sub$strand <- NA
  coverage_sub <- coverage_sub %>% dplyr::mutate(., strand = ifelse(grepl("_m_", name), "minus", "plus"))
  coverage_sub
  
  # facet grid by end and type, plot plus and minus on same plot
  
  
}

samps <- c("PRO_m_3","PRO_m_5","PRO_p_3","PRO_p_5","PRO_m_full","PRO_p_full","RNA_m_full","RNA_p_full")

setwd("/workdir/users/acv46/stool_PROSeq2/deseq/bam/pileup")
US2_cov_all <- get_coverage("US2_coverage_q30_correct3.txt", unique(US2_crispr$contig))
US3_cov_all <- get_coverage("US3_coverage_q30_correct3.txt", unique(US3_crispr$contig))
# US2_cov_all_PRO <- US2_cov_all[grepl("PRO", US2_cov_all$name),] %>% arrange(desc(name))
# US3_cov_all_PRO <- US3_cov_all[grepl("PRO", US3_cov_all$name),] %>% arrange(desc(name))
US2_cov_set <- US2_cov_all %>% filter(name %in% samps) %>%
  mutate(nlab = ifelse(end == "full", paste0(type), paste0(type, " ", end, "' end")))
US3_cov_set <- US3_cov_all %>% filter(name %in% samps) %>%
  mutate(nlab = ifelse(end == "full", paste0(type), paste0(type, " ", end, "' end")))

# US2_cov_all_raw <- US2_cov_all[grepl("raw", US2_cov$name),] %>% arrange(desc(name))
# US3_cov_all_raw <- US3_cov_all[grepl("raw", US3_cov$name),] %>% arrange(desc(name))
# rm(US2_cov_all)
# rm(US3_cov_all)
```

## read in coverage data: troubleshoot
```{r}
# splice together files with full and end data

s1cols <- dput(scan(text = "contig position PRO_m_3 PRO_m_5 PRO_p_3 PRO_p_5 PRO_p_full PRO_m_full RNA_p_full RNA_m_full", what = ""))

get_coverage <- function(file, vector, samps) {

  # file is the coverage file
  # vector is a vector of contigs for positive subsetting
  
  coverage <- read_delim(file = file,
                         delim = " ",
                         col_names = T)
  
  # make sure column names are correct
  
  colnames(coverage) <- s1cols
  
  coverage_sub <- coverage %>%
    pivot_longer(cols = -c("contig","position"), names_to = "name") %>%
    #filter(name %in% samps) %>%
    filter(contig %in% vector) %>%
    mutate(end = sub(".*_", "", name)) %>%
    mutate(type = sub("_.*", "", name) %>% paste0(.,"-seq")) %>%
    mutate(., value = ifelse(grepl("_m_", name), value * -1, value)) %>%
    # flip RNA-seq
    mutate(., value = ifelse(type == "RNA-seq", value * -1, value)) %>%
    mutate(strand = NA) %>%
    mutate(strand = ifelse(grepl("_m_", name), "minus", "plus")) %>%
    mutate(nlab = ifelse(end == "full", paste0(type), paste0(type, " ", end, "' end")))
    # full_join(., groupsums) %>%
    # mutate(normval = 10^9 * (value / gsum))
  
  coverage_sub
  
}

setwd("/workdir/users/acv46/stool_PROSeq2/deseq/bam/pileup")
samps <- c("PRO_m_3","PRO_m_5","PRO_p_3","PRO_p_5","PRO_m_full","PRO_p_full","RNA_m_full","RNA_p_full")
# get "tRNA_all_goodbins" object from "visualize coverage across tRNA arrays in all contigs (US2 + US3)" block below
# US2_contigs_tRNA <- tRNA_all_goodbins %>% filter(samp == "US2") %>% select(contig) %>% unique %>% as_vector
# US3_contigs_tRNA <- tRNA_all_goodbins %>% filter(samp == "US3") %>% select(contig) %>% unique %>% as_vector
# see /workdir/users/acv46/stool_PROSeq2/script/get_groupsums.sh
# US2_groupsum <- read_delim("US2_groupsums.txt", col_names = c("type","end","gsum")) %>%
#   filter(end == "full") %>% select(type,gsum)
# US3_groupsum <- read_delim("US3_groupsums.txt", col_names = c("type","end","gsum")) %>%
#   filter(end == "full") %>% select(type,gsum)

US2_cov_set <- get_coverage(file = "US2_coverage_q30_splice2.txt",
                            vector = unique(US2_crispr$contig) %>% as_vector(),
                            samps = samps)
US3_cov_set <- get_coverage(file = "US3_coverage_q30_splice1.txt",
                            vector = unique(US3_crispr$contig) %>% as_vector(),
                            samps = samps)
```

## plot crispr arrays with coverage
```{r}
# plot coverage along array
# include geom_rect for repeats
# plot logo of repeat below trace

plot_crispr <- function(seqs, crispr, cas, cov, prom, buffer, lab) {
  
  require(dplyr)
  
  # function takes the four tibbles generated in the above chunks
  # get list of CRISPR array identifiers
  arrays <- unique(seqs$id)
  
  # plot for each contig individually
  sapply(arrays,
         function(array) {
           
           # create data to plot repeat ranges as geom_rect
           
           contig <- crispr[which(crispr$id == array),]$contig %>% unique()
           contig_size <- cov[which(cov$contig == contig),]$position %>% max()
           xmin <- crispr[which(crispr$id == array),]$start %>% min() %>% as.numeric() - buffer
           xmax <- crispr[which(crispr$id == array),]$end %>% max() %>% as.numeric() + buffer
           # xmin <- c(cas[which(cas$contig == contig),]$start,
           #           crispr[which(crispr$id == array),]$start) %>% min() %>% as.numeric() - buffer
           # xmax <- c(cas[which(cas$contig == contig),]$end,
           #           crispr[which(crispr$id == array),]$end) %>% max() %>% as.numeric() + buffer
           
           if (xmin < 1) {
             xmin <- 1
           }
           
           if (xmax > contig_size) {
             xmax <- contig_size
           }
           
           cov_array <- cov[which(cov$contig == contig),] %>% filter(position <= xmax & position >= xmin)
           ymax <- max(abs(cov_array$value))
           
           breaks <- seq(xmin, xmax, by = round((xmax - xmin)/7, digits = 0))
           
           repeats <- data.frame(x1 = crispr[which(crispr$id == array),]$start,
                               x2 = crispr[which(crispr$id == array),]$end,
                               y1 = -ymax * 0.2,
                               y2 = ymax * 0.2, 
                               stringsAsFactors = F)

           whole <- data.frame(x1 = min(repeats$x1),
                               x2 = max(repeats$x2),
                               y1 = -ymax * 0.3,
                               y2 = ymax * 0.3, 
                               stringsAsFactors = F)
           
           # if (nrow(cas[which(cas$contig == contig),]) > 0){
           # 
           #   casbounds <- data.frame(x1 = cas[which(cas$contig == contig),]$start,
           #                           x2 = cas[which(cas$contig == contig),]$end,
           #                           label = cas[which(cas$contig == contig),]$gene,
           #                           y1 = -ymax * 0.3,
           #                           y2 = ymax * 0.3,
           #                           stringsAsFactors = F)
           # 
           # }
           
           # if (nrow(prom[which(prom$contig == contig),]) > 0){
           # 
           #   prombounds <- data.frame(x1 = prom[which(prom$contig == contig),]$start,
           #                           x2 = prom[which(prom$contig == contig),]$end,
           #                           strand = prom[which(prom$contig == contig),]$strand,
           #                           y1 = -ymax * 0.3,
           #                           y2 = ymax * 0.3,
           #                           stringsAsFactors = F)
           # 
           # }
           
           pc <- ggplot() +
             geom_line(data = cov[which(cov$contig == contig),],
                       mapping = aes(x = factor(position), y = value, color = name, group = 1)) +
             scale_x_discrete(breaks = breaks) +
             coord_cartesian(xlim = c(xmin, xmax),
                             ylim = c(-ymax - (0.02 * ymax), ymax + (0.02 * ymax))) +
             geom_rect(data = whole,
                       mapping = aes(xmin = x1, xmax = x2, ymin = y1, ymax = y2),
                       fill = "yellow",
                       alpha = 0.2) +
             geom_rect(data = repeats,
                       mapping = aes(xmin = x1, xmax = x2, ymin = y1, ymax = y2),
                       fill = "blue",
                       alpha = 0.2) +
             theme_classic() +
             ggtitle(paste("contig = ", contig))+
             geom_hline(yintercept = 0, color = "black")
           

             print(pc)

           
           # save each plot as a pdf
           # fname <- paste(lab, contig, "partial.pdf", sep = "_")
           # ggsave(filename = fname,
           #        plot = pc,
           #        device = cairo_pdf,
           #        dpi = 600,
           #        width = 6,
           #        height = 4)
           
         })
  
   # create ordered pdf list by number of RNA-seq reads
   # pdflist <- list.files(path = ".", pattern = paste(lab))
   # # combine pdfs into a single file
   # staple_pdf(input_files = pdflist,
   #            output_filepath = file.path(".",paste(lab, "crispr_merged.pdf", sep = "_")))
   # # remove individual pdfs
   # do.call(file.remove, list(pdflist))
  
}
```

### apply plotting function
```{r}
library(staplr)
setwd("/workdir/users/acv46/stool_PROSeq2/figures/crispr")
plot_crispr(seqs = US2_seqs, crispr = US2_crispr, cas = US2_cas, cov = US2_cov_all_raw, prom = US2_promoter, buffer = 10, lab = "US2")
plot_crispr(seqs = US3_seqs, crispr = US3_crispr, cas = US3_cas, cov = US3_cov_all_raw, prom = US3_promoter, buffer = 10, lab = "US3")
```

## plot 3' and 5' PRO-seq read ends across crispr array, highlight repeat cleavage site, best example
```{r}
# plot coverage along array
# include geom_rect for repeats
# plot logo of repeat below trace

plot_crispr2 <- function(seqs, crispr, id, strand, cutpos, cas, cov, prom, buffer, samp, bindat) {
  
  # same as function above, but utilizes 3' and 5' coverage data
  # id is the specific crispr ID
  # strand is the direction of transcription inferred from the PRO-seq data
  # cutpos is the stem loop cleavage site in each repeat
  ## relative to positive strand and 5' end of repeat
  ## interpreted using http://rna.tbi.univie.ac.at//cgi-bin/RNAWebSuite/RNAfold.cgi
  
  require(tidyverse)
  require(ggplot2)
  require(ggseqlogo)
  require(patchwork)
  require(gggenes)
  
  # function takes the four tibbles generated in the above chunks
  # get list of CRISPR array identifiers
  array <- id
  
  # plot for each contig individually
           
  # create data to plot repeat ranges as geom_rect
  
  con <- crispr[which(crispr$id == array),]$contig %>% unique()
  contig_size <- cov[which(cov$contig == con),]$position %>% max()
  xmin <- crispr[which(crispr$id == array),]$start %>% min() %>% as.numeric() - buffer
  xmax <- crispr[which(crispr$id == array),]$end %>% max() %>% as.numeric() + buffer
  # xmin <- c(cas[which(cas$contig == contig),]$start,
  #           crispr[which(crispr$id == array),]$start) %>% min() %>% as.numeric() - buffer
  # xmax <- c(cas[which(cas$contig == contig),]$end,
  #           crispr[which(crispr$id == array),]$end) %>% max() %>% as.numeric() + buffer
  
  message(paste0("CRISPR is ", id))
  message(paste0("contig is ", con))
  
  if (xmin < 1) {
   xmin <- 1
  }
  
  if (xmax > contig_size) {
   xmax <- contig_size
  }
  
  cov_array <- cov[which(cov$contig == con),] %>% filter(position <= xmax & position >= xmin)
  ymax <- max(abs(cov_array$value))
  
  breaks <- seq(round(xmin,-2), round(xmax,-2),
                by = round((round(xmax,-2) - round(xmin,-2))/5, digits = -2))
  breaks <- breaks[which(breaks >= xmin & breaks <= xmax)]
  
  repseq <- seqs %>% filter(id == array)
  repcrisp <- crispr %>% filter(id == array)
  
  spec <- bindat %>%
   filter(contig == con) %>%
   select(g_species) %>% unlist()
  
  message(paste0("species is ", spec))
  
  if (strand == "plus"){
   
   cuts <- data.frame(xend = as.numeric(repcrisp$start) + cutpos,
                      x = as.numeric(repcrisp$start) + cutpos,
                      yend = -1 * ymax*0.2,
                      y = -1 * ymax*0.4,
                      stringsAsFactors = F,
                      nlab = "PRO-seq 5' end")
   
   repeats <- data.frame(x1 = crispr[which(crispr$id == array),]$start,
                     x2 = crispr[which(crispr$id == array),]$end,
                     y1 = -ymax * 0.2,
                     y2 = ymax * 0.2, 
                     stringsAsFactors = F)
   
   promoters <- prom %>% filter(contig == con) %>%
     filter(start < min(repeats$x1)) %>%
     arrange(desc(start)) %>% slice_head()
   
  } else if (strand == "minus"){
   
   cuts <- data.frame(xend = as.numeric(repcrisp$end) - cutpos,
                      x = as.numeric(repcrisp$end) - cutpos,
                      yend = ymax * 0.2,
                      y = ymax * 0.4,
                      stringsAsFactors = F,
                      nlab = "PRO-seq 5' end")
   
   repeats <- data.frame(x1 = crispr[which(crispr$id == array),]$end,
                     x2 = crispr[which(crispr$id == array),]$start,
                     y1 = -ymax * 0.2,
                     y2 = ymax * 0.2, 
                     stringsAsFactors = F)
   
  }
  
  plotcov <- cov %>% filter(contig == con)
  
  pc <- ggplot() +
   geom_line(data = plotcov,
             mapping = aes(x = factor(position), y = value, group = 1),
             color = "#ff0000") +
   #scale_color_manual(values=c("#0d00ff","#ff0000")) +
   facet_grid(factor(nlab, levels = c("RNA-seq","PRO-seq","PRO-seq 3' end","PRO-seq 5' end")) ~ .) +
   scale_x_discrete(breaks = breaks,
                    labels = sprintf("%.1f", (breaks / 1000))) +
   coord_cartesian(xlim = c(xmin, xmax),
                   ylim = c(-ymax - (0.02 * ymax), ymax + (0.02 * ymax))) +
   geom_rect(data = repeats,
             mapping = aes(xmin = x1, xmax = x2, ymin = y1, ymax = y2),
             fill = "black",
             alpha = 0.2) +
    geom_segment(data = promoters,
                 mapping = aes(x = start, xend = start, y = 0, yend = 0.5 * ymax),
                 size = 1) +
    geom_segment(data = promoters,
                 mapping = aes(x = start, xend = end, y = 0.5 * ymax, yend = 0.5 * ymax),
                 lineend = "butt", linejoin = "mitre",
                 size = 1, arrow = arrow(length = unit(0.2, "cm"))) +
   geom_segment(data = cuts,
                mapping = aes(x = x, y = y, xend = xend, yend = yend),
                size = 1,
                arrow = arrow(length = unit(0.05, "npc")),
                lineend = "butt", linejoin = "mitre", color = "black") +
   theme_bw() +
   ggtitle(paste0(samp, ", ", spec)) +
   geom_hline(yintercept = 0, color = "black") +
   ylab("Per-base read depth") +
    xlab("Position (kb)") +
   theme(axis.title.x = element_text(size = 10),
         axis.title.y = element_text(size = 10),
         title = element_text(size = 10),
         panel.grid.major = element_blank(),
         panel.grid.minor = element_blank(),
         strip.background = element_blank(),
         strip.text = element_blank()) +
   geom_text(data = plotcov,
             mapping = aes(x = xmin + ((xmax - xmin) %/% 60),
                           y = -ymax * 0.8,
                           label = nlab),
               hjust = 0, size = 3.5,
               check_overlap = TRUE)
  
  # REPEAT LOGO
  
  cs1 <- make_col_scheme(chars=c('A', 'T', 'C', 'G'),
                         cols=c('#F7B32B', '#255C99', '#109648', '#D62839'))
  
  get_logo <- function(seqs, crispr, strand){
   
   repvec <- seqs %>% 
     filter(id == crispr) %>% 
     pull(`repeat`) %>%
     gsub("T","U",.)
   
   replen <- nchar(repvec[1])
   
   logo <- ggseqlogo(repvec, method = "probability", font = "roboto_medium", col_scheme = cs1) +
     ylab("prob") +
     theme(axis.title.x = element_blank(),
           axis.text.y = element_text(size = 6),
           #axis.ticks.y = element_blank(),
           axis.title.y = element_text(size = 10),
           aspect.ratio = 1/8)
   
   logo$scales$scales[[1]] <- scale_x_continuous(breaks = seq(0,replen,by=8)[-1],
                                               labels = seq(0,replen,by=8)[-1])
   # logo$scales$scales[[2]] <- scale_y_continuous(breaks = c(0,1.5),
   #                                              labels = c(0,1.5))
   
   logo
   
   }
  
  pd <- get_logo(seqs, id)
  
  # CAS GENES COVERAGE
  
  casplot <- cas %>% filter(seqname == con) %>% 
    select(seqname, gene, start, end, strand) %>%
    mutate(gene = str_remove(gene, pattern = "_.*$"))
  
  xmin2 <- min(casplot$start) - buffer
  xmax2 <- max(casplot$end) + buffer
  
  if (xmin2 < 1) {
   xmin2 <- 1
  }
  
  if (xmax2 > contig_size) {
   xmax2 <- contig_size
  }
  
  cov_array2 <- cov[which(cov$contig == con),] %>% filter(position <= xmax2 & position >= xmin2)
  ymax2 <- max(abs(cov_array2$value))
  
  breaks2 <- seq(round(xmin2,-2), round(xmax2,-2),
                by = round((round(xmax2,-2) - round(xmin2,-2))/5, digits = -2))
  breaks2 <- breaks2[which(breaks2 >= xmin2 & breaks2 <= xmax2)]
    
  plotcov2 <- cov %>% filter(contig == con) %>%
    filter(nlab %in% c("PRO-seq"))
  
  genebox <- data.frame(x1 = casplot$start,
                     x2 = casplot$end,
                     y1 = -ymax2 * 0.3,
                     y2 = -ymax2 * 0.5,
                     gene = c("cas5d","cas1-cas2",""),
                     stringsAsFactors = F)
  
  pe <- ggplot() +
   geom_line(data = plotcov2,
             mapping = aes(x = factor(position), y = value, group = 1),
             color = "#ff0000") +
   #scale_color_manual(values=c("#0d00ff","#ff0000")) +
   facet_grid(factor(nlab, levels = c("PRO-seq")) ~ .) +
   scale_x_discrete(breaks = breaks2,
                    labels = sprintf("%.1f", (breaks2 / 1000))) +
   coord_cartesian(xlim = c(xmin2, xmax2),
                   ylim = c(-ymax2 - (0.02 * ymax2), ymax2 + (0.02 * ymax2))) +
   # geom_rect(data = repeats,
   #           mapping = aes(xmin = x1, xmax = x2, ymin = y1, ymax = y2),
   #           fill = "blue",
   #           alpha = 0.2) +
   # geom_segment(data = cuts,
   #              mapping = aes(x = x, y = y, xend = xend, yend = yend),
   #              size = 1,
   #              arrow = arrow(length = unit(0.05, "npc")),
   #              lineend = "butt", linejoin = "mitre", color = "black") +
   theme_bw() +
   geom_hline(yintercept = 0, color = "black") +
   ylab("Per-base read depth") +
    xlab("Position (kb)") +
   theme(axis.title.x = element_text(size = 10),
         axis.title.y = element_text(size = 10),
         panel.grid.major = element_blank(),
         panel.grid.minor = element_blank(),
         strip.background = element_blank(),
         strip.text = element_blank()) +
   geom_text(data = plotcov2,
             mapping = aes(x = xmax2 - ((xmax2 - xmin2) %/% 60),
                           y = 0.8 * ymax2,
                           label = nlab),
             size = 3.5,
             check_overlap = TRUE,
             hjust = 1) +
    geom_rect(data = genebox,
             mapping = aes(xmin = x1, xmax = x2, ymin = y1, ymax = y2, fill = gene),
             alpha = 0.8) +
    theme(legend.position = "none") +
    geom_text(data = genebox,
              mapping = aes(x = x1, y = y2, label = gene),
              size = 3.5, vjust = 1.5, hjust = 0) +
    theme(aspect.ratio = 1/3)
    
  
  # GGGENES plots
  
  # pf <- cas %>% filter(seqname == con) %>%
  #   select(seqname, gene, start, end, strand) %>%
  #   mutate(gene = str_remove(gene, pattern = "_.*$")) %>%
  #   ggplot(data = .,
  #          mapping = aes(xmin = start,
  #                        xmax = end,
  #                        y = seqname,
  #                        fill = gene,
  #                        label = gene)) +
  #   geom_gene_arrow(arrowhead_width = grid::unit(4, "mm"),
  #                   arrowhead_height = grid::unit(4, "mm"),
  #                   arrow_body_height = grid::unit(4, "mm")) +
  #   geom_text(mapping = aes(x = start),
  #             angle = 0, hjust = 0, vjust = 2, size = 5) +
  #   #scale_fill_manual(values = pal) +
  #   theme_genes() +
  #   theme(legend.position = "none",
  #         axis.text.y = element_blank(),
  #         #axis.ticks.y = element_blank(),
  #         axis.title.x = element_blank(),
  #         axis.text.x = element_blank(),
  #         axis.ticks.x = element_blank(),
  #         axis.title.y = element_blank(),
  #         aspect.ratio = 1/5)
  
  (pc + theme(plot.margin = unit(c(0,10,0,0), "pt"))) +
    ((pd + theme(plot.margin = unit(c(0,5,0,0), "pt"))) / (pe + theme(plot.margin = unit(c(5,5,0,0), "pt"))))
  
  # save each plot as a pdf
  # fname <- paste(nlab, contig, "partial.pdf", sep = "_")
  # ggsave(filename = fname,
  #        plot = pc,
  #        device = cairo_pdf,
  #        dpi = 600,
  #        width = 6,
  #        height = 4)
  
  
   # create ordered pdf list by number of RNA-seq reads
   # pdflist <- list.files(path = ".", pattern = paste(nlab))
   # # combine pdfs into a single file
   # staple_pdf(input_files = pdflist,
   #            output_filepath = file.path(".",paste(nlab, "crispr_merged.pdf", sep = "_")))
   # # remove individual pdfs
   # do.call(file.remove, list(pdflist))
  
}
```

### apply plotting function
```{r}
library(staplr)
setwd("/workdir/users/acv46/stool_PROSeq2/figures/crispr")

# good examples
plot_US2_6 <- plot_crispr2(seqs = US2_seqs, crispr = US2_crispr, id = "CRISPR6", strand = "plus", cutpos = 21, 
            cas = US2_cas, cov = US2_cov_set, prom = US2_promoter, buffer = 100, samp = "US2", bindat = US2_bindat)

plot_US2_14 <- plot_crispr2(seqs = US2_seqs, crispr = US2_crispr, id = "CRISPR14", strand = "minus", cutpos = 21,
            cas = US2_cas, cov = US2_cov_set, prom = US2_promoter, buffer = 100)
# plot_crispr2(seqs = US3_seqs, crispr = US3_crispr, id = "CRISPR3", strand = "minus", cutpos = 17, 
#             cas = US3_cas, cov = US3_cov_set, prom = US3_promoter, buffer = 10, lab = "US3")
# plot_crispr2(seqs = US3_seqs, crispr = US3_crispr, id = "CRISPR5", strand = "plus", cutpos = 18, 
#             cas = US3_cas, cov = US3_cov_set, prom = US3_promoter, buffer = 10, lab = "US3")
# 
# # with RNA signal
# plot_crispr2(seqs = US3_seqs, crispr = US3_crispr, id = "CRISPR7", strand = "plus", cutpos = 18, 
#             cas = US3_cas, cov = US3_cov_set, prom = US3_promoter, buffer = 10, lab = "US3")
# plot_crispr2(seqs = US3_seqs, crispr = US3_crispr, id = "CRISPR17", strand = "plus", cutpos = 18, 
#             cas = US3_cas, cov = US3_cov_set, prom = US3_promoter, buffer = 10, lab = "US3")
# 
# # test different coverage fjles
# plot_crispr2(seqs = US3_seqs, crispr = US3_crispr, id = "CRISPR18", strand = "plus", cutpos = 18, 
#             cas = US3_cas, cov = US3_cov_set, prom = US3_promoter, buffer = 10, lab = "US3")
# plot_crispr2(seqs = US3_seqs, crispr = US3_crispr, id = "CRISPR18", strand = "plus", cutpos = 18, 
#             cas = US3_cas, cov = US3_cov_raw, prom = US3_promoter, buffer = 10, lab = "US3")
# plot_crispr2(seqs = US3_seqs, crispr = US3_crispr, id = "CRISPR18", strand = "plus", cutpos = 18, 
#             cas = US3_cas, cov = US3_cov_PRO, prom = US3_promoter, buffer = 10, lab = "US3")
# 
# # other examples
# plot_crispr2(seqs = US2_seqs, crispr = US2_crispr, id = "CRISPR8", strand = "plus", cutpos = 18, 
#             cas = US2_cas, cov = US2_cov_set, prom = US2_promoter, buffer = 10, lab = "US2")
# plot_crispr2(seqs = US3_seqs, crispr = US3_crispr, id = "CRISPR11", strand = "plus", cutpos = 18, 
#             cas = US3_cas, cov = US3_cov_set, prom = US3_promoter, buffer = 10, lab = "US3")
```

### ggsave
```{r}
setwd("/workdir/users/acv46/stool_PROSeq2/figures/crispr")

ggsave(filename = "US2_CRISPR6_v4.pdf",
       plot = plotme,
       device = "pdf",
       dpi = 600,
       width = 7,
       height = 5,
       useDingbats = F)
```


## plot 3' and 5' PRO-seq read ends across crispr array, other good examples
```{r}
# plot coverage along array
# include geom_rect for repeats
# plot logo of repeat below trace

plot_crispr3 <- function(seqs, crispr, id, strand, cutpos, cas, cov, prom, buffer, samp, bindat) {
  
  # same as function above, but utilizes 3' and 5' coverage data
  # id is the specific crispr ID
  # strand is the direction of transcription inferred from the PRO-seq data
  # cutpos is the stem loop cleavage site in each repeat
  ## relative to positive strand and 5' end of repeat
  ## interpreted using http://rna.tbi.univie.ac.at//cgi-bin/RNAWebSuite/RNAfold.cgi
  
  require(tidyverse)
  require(ggplot2)
  require(ggseqlogo)
  require(patchwork)
  require(gggenes)
  
  # function takes the four tibbles generated in the above chunks
  # get list of CRISPR array identifiers
  array <- id
  
  # plot for each contig individually
           
  # create data to plot repeat ranges as geom_rect
  
  con <- crispr[which(crispr$id == array),]$contig %>% unique()
  contig_size <- cov[which(cov$contig == con),]$position %>% max()
  xmin <- crispr[which(crispr$id == array),]$start %>% min() %>% as.numeric() - buffer
  xmax <- crispr[which(crispr$id == array),]$end %>% max() %>% as.numeric() + buffer
  
  message(paste0("CRISPR is ", id))
  message(paste0("contig is ", con))
  
  if (xmin < 1) {
   xmin <- 1
  }
  
  if (xmax > contig_size) {
   xmax <- contig_size
  }
  
  cov_array <- cov[which(cov$contig == con),] %>% filter(position <= xmax & position >= xmin)
  ymax <- max(abs(cov_array$value))
  
  breaks <- seq(round(xmin,-2), round(xmax,-2),
                by = round((round(xmax,-2) - round(xmin,-2))/5, digits = -2))
  breaks <- breaks[which(breaks >= xmin & breaks <= xmax)]
  
  repseq <- seqs %>% filter(id == array)
  repcrisp <- crispr %>% filter(id == array)
  
  spec <- bindat %>%
   filter(contig == con) %>%
   select(g_species) %>% unlist()
  
  message(paste0("species is ", spec))
  
  if (strand == "plus"){
   
   cuts <- data.frame(xend = as.numeric(repcrisp$start) + cutpos,
                      x = as.numeric(repcrisp$start) + cutpos,
                      yend = -1 * ymax * 0.2,
                      y = -1 * ymax * 0.4,
                      stringsAsFactors = F,
                      nlab = "PRO-seq 5' end")
   
   repeats <- data.frame(x1 = crispr %>% filter(id == array) %>% select(start) %>% unlist() %>% as.numeric(),
                     x2 = crispr %>% filter(id == array) %>% select(end) %>% unlist() %>% as.numeric(),
                     y1 = -ymax * 0.2,
                     y2 = ymax * 0.2, 
                     stringsAsFactors = F)
   
   textpos <- -1
   
   # promoters <- prom %>% filter(contig == con) %>%
   #   filter(start < min(repeats$x1)) %>%
   #   arrange(desc(start)) %>% slice_head()
   
  } else if (strand == "minus"){
   
   cuts <- data.frame(xend = as.numeric(repcrisp$end) - cutpos,
                      x = as.numeric(repcrisp$end) - cutpos,
                      yend = ymax * 0.2,
                      y = ymax * 0.4,
                      stringsAsFactors = F,
                      nlab = "PRO-seq 5' end")
   
   repeats <- data.frame(x1 = crispr %>% filter(id == array) %>% select(end) %>% unlist() %>% as.numeric(),
                     x2 = crispr %>% filter(id == array) %>% select(start) %>% unlist() %>% as.numeric(),
                     y1 = -ymax * 0.2,
                     y2 = ymax * 0.2,
                     stringsAsFactors = F)
   
   textpos <- 1
   
  }
  
  plotcov <- cov %>% filter(contig == con)
  
  pc <- ggplot(data = plotcov) +
   geom_area(mapping = aes(x = position, y = value, linetype = strand),
             color = "#ff0000",
             fill = "#ff0000") +
   facet_grid(factor(nlab, levels = c("RNA-seq","PRO-seq","PRO-seq 3' end","PRO-seq 5' end")) ~ .) +
   geom_text(mapping = aes(x = xmin + ((xmax - xmin) %/% 60),
                           y = textpos * ymax * 0.8,
                           label = nlab),
               hjust = 0, size = 3.5,
               check_overlap = TRUE) + 
   geom_rect(data = repeats,
             mapping = aes(xmin = x1, xmax = x2, ymin = y1, ymax = y2),
             fill = "black",
             alpha = 0.2,
             inherit.aes = FALSE) +
   scale_x_continuous(breaks = breaks,
                    labels = sprintf("%.1f", (breaks / 1000))) +
   coord_cartesian(xlim = c(xmin, xmax),
                   ylim = c(-ymax - (0.02 * ymax), ymax + (0.02 * ymax))) +
   # geom_segment(data = cuts,
   #              mapping = aes(x = x, y = y, xend = xend, yend = yend),
   #              size = 1,
   #              arrow = arrow(length = unit(0.05, "npc")),
   #              lineend = "butt", linejoin = "mitre", color = "black") +
   scale_linetype_manual(values = c(1,1)) +
   theme_bw() +
   ggtitle(paste0(samp, ", ", spec)) +
   geom_hline(yintercept = 0, color = "black") +
   ylab("Per-base read depth") +
    xlab("Position (kb)") +
   theme(axis.title.x = element_text(size = 10),
         axis.title.y = element_text(size = 10),
         title = element_text(size = 10),
         panel.grid.major = element_blank(),
         panel.grid.minor = element_blank(),
         strip.background = element_blank(),
         strip.text = element_blank(),
         legend.position = "none") 
  
  # REPEAT LOGO
  
  cs1 <- make_col_scheme(chars=c('A', 'T', 'C', 'G'),
                         cols=c('#F7B32B', '#255C99', '#109648', '#D62839'))
  
  get_logo <- function(seqs, crispr, strand){
   
   repvec <- seqs %>% 
     filter(id == crispr) %>% 
     pull(`repeat`) %>%
     gsub("T","U",.)
   
   replen <- nchar(repvec[1])
   
   logo <- ggseqlogo(repvec, method = "probability", font = "roboto_medium", col_scheme = cs1) +
     ylab("prob") +
     theme(axis.title.x = element_blank(),
           axis.text.y = element_text(size = 6),
           #axis.ticks.y = element_blank(),
           axis.title.y = element_text(size = 10),
           aspect.ratio = 1/8)
   
   logo$scales$scales[[1]] <- scale_x_continuous(breaks = seq(0,replen,by=8)[-1],
                                               labels = seq(0,replen,by=8)[-1])

   
   logo
   
   }
  
  pd <- get_logo(seqs, id)

  (pc + theme(plot.margin = unit(c(0,10,0,0), "pt"))) /
    ((pd + theme(plot.margin = unit(c(0,5,0,0), "pt"))))
  
  # save each plot as a pdf
  # fname <- paste(nlab, contig, "partial.pdf", sep = "_")
  # ggsave(filename = fname,
  #        plot = pc,
  #        device = cairo_pdf,
  #        dpi = 600,
  #        width = 6,
  #        height = 4)
  
  
   # create ordered pdf list by number of RNA-seq reads
   # pdflist <- list.files(path = ".", pattern = paste(nlab))
   # # combine pdfs into a single file
   # staple_pdf(input_files = pdflist,
   #            output_filepath = file.path(".",paste(nlab, "crispr_merged.pdf", sep = "_")))
   # # remove individual pdfs
   # do.call(file.remove, list(pdflist))
  
}
```

### apply plotting function
```{r}
library(staplr)
setwd("/workdir/users/acv46/stool_PROSeq2/figures/crispr")

# good examples
US2_C6 <- plot_crispr3(seqs = US2_seqs, crispr = US2_crispr, id = "CRISPR6", strand = "plus", cutpos = 21,
            cas = US2_cas, cov = US2_cov_set, prom = US2_promoter, buffer = 100, samp = "US2", bindat = US2_bindat)

US2_C14 <- plot_crispr3(seqs = US2_seqs, crispr = US2_crispr, id = "CRISPR14", strand = "minus", cutpos = 21,
            cas = US2_cas, cov = US2_cov_set, prom = US2_promoter, buffer = 100, samp = "US2", bindat = US2_bindat)

US3_C3 <- plot_crispr3(seqs = US3_seqs, crispr = US3_crispr, id = "CRISPR3", strand = "minus", cutpos = 17,
            cas = US3_cas, cov = US3_cov_set, prom = US3_promoter, buffer = 100, samp = "US3", bindat = US3_bindat)

US3_C5 <- plot_crispr3(seqs = US3_seqs, crispr = US3_crispr, id = "CRISPR5", strand = "plus", cutpos = 18,
            cas = US3_cas, cov = US3_cov_set, prom = US3_promoter, buffer = 100, samp = "US3", bindat = US3_bindat)

US3_C11 <- plot_crispr3(seqs = US3_seqs, crispr = US3_crispr, id = "CRISPR11", strand = "minus", cutpos = 18,
            cas = US3_cas, cov = US3_cov_set, prom = US3_promoter, buffer = 100, samp = "US3", bindat = US3_bindat)

US2_C6
US2_C14
US3_C3
US3_C5
US3_C11

# setwd("/workdir/users/acv46/stool_PROSeq2/figures/crispr")
# ggsave(plot = US2_C6, filename = "US2_CRISPR6_trace_v2.pdf",
#        device = "pdf",
#        dpi = 600,
#        width = 5,
#        height = 5,
#        useDingbats = F)
# ggsave(plot = US2_C14, filename = "US2_CRISPR14_trace_v2.pdf",
#        device = "pdf",
#        dpi = 600,
#        width = 5,
#        height = 5,
#        useDingbats = F)
# ggsave(plot = US3_C3, filename = "US3_CRISPR3_trace_v2.pdf",
#        device = "pdf",
#        dpi = 600,
#        width = 5,
#        height = 5,
#        useDingbats = F)
# ggsave(plot = US3_C5, filename = "US3_CRISPR5_trace_v2.pdf",
#        device = "pdf",
#        dpi = 600,
#        width = 5,
#        height = 5,
#        useDingbats = F)
# ggsave(plot = US3_C11, filename = "US3_CRISPR11_trace_v2.pdf",
#        device = "pdf",
#        dpi = 600,
#        width = 5,
#        height = 5,
#        useDingbats = F)


```

### ggsave
```{r}
setwd("/workdir/users/acv46/stool_PROSeq2/figures/crispr")

ggsave(filename = "US2_CRISPR6_v4.pdf",
       plot = plotme,
       device = "pdf",
       dpi = 600,
       width = 7,
       height = 5,
       useDingbats = F)
```


## sequence logos for selected CRISPR repeats
```{r, fig.height=1.5, fig.width=8}
#install.packages("ggseqlogo")
require(ggseqlogo)
require(tidyverse)

get_logo <- function(seqs, crispr, strand){
  
  # input is _seqs dataframe, CRISPR ID, and strand
  
  repvec <- seqs %>% 
    filter(id == crispr) %>% 
    pull(`repeat`) %>%
    gsub("T","U",.)
  
  ggseqlogo(repvec, method = "prob") +
    theme(plot.margin = unit(c(0.2,0.2,0.2,0.2),"cm"))
  
  # can visualize MSA with msa()
  #msa(repvec, type = "rna")
  
}

get_logo(US2_seqs, "CRISPR6")
get_logo(US2_seqs, "CRISPR14")
get_logo(US3_seqs, "CRISPR3")
get_logo(US3_seqs, "CRISPR5")
```



# Antismash BGCs

## read in antismash outputs
```{r}
# genbank files parsed with bash script
# see /workdir/users/acv46/stool_PROSeq2/scripts/parse_antismash_gbk.sh

library(tidyverse)

readas <- function(file) {
  
  cols <- c("rename","contig_start","contig_end","contig","gene_start","gene_end","name","strand")
  bgc <- read_tsv(file = file, na = "NA",
           col_names = cols) %>% select(-rename)
  
  # get contig-wise gene positions
  bgc$gene_start <- bgc$gene_start + bgc$contig_start
  bgc$gene_end <- bgc$gene_end + bgc$contig_start
  
  bgc

}

setwd("/workdir/users/acv46/stool_PROSeq2/antismash")
US2_bgc <- readas("US2_5Nov2020_out/US2_antismash_summary.txt")
US3_bgc <- readas("US3_3Nov2020_out/US3_antismash_summary.txt")
```

## read in promoter data
```{r}

# see functions generating "_promoters" objects for CRISPR spacers analysis

```

## read in coverage data, subset for contigs with BGCs, then delete large dataframe
```{r}
get_coverage <- function(file, vector) {

  # file is the coverage file
  # vector is a vector of contigs for positive subsetting
  
  coverage <- read_delim(file = file,
                         delim = "\t",
                         col_names = T)
  
  colnames(coverage) <- c("contig","position","PRO_minus","PRO_plus","RNA_minus","RNA_plus")
  
  PROsum <- sum(coverage$PRO_minus + coverage$PRO_plus)
  RNAsum <- sum(coverage$RNA_minus + coverage$RNA_plus)
  
  name <- dput(file) %>% str_replace("_.*", "")
  
  coverage_sub <- coverage[coverage$contig %in% vector,]
  
  # flip for PRO-seq
  
  coverage_sub$PRO_plus_norm <-  (coverage_sub$PRO_minus * 10^6) / PROsum 
  coverage_sub$PRO_minus_norm <-  -(coverage_sub$PRO_plus * 10^6) / PROsum
  coverage_sub$RNA_minus_norm <- -(coverage_sub$RNA_minus * 10^6) / RNAsum
  coverage_sub$RNA_plus_norm <-   (coverage_sub$RNA_plus * 10^6) / RNAsum
  
  coverage_sub$PRO_plus_raw <-  coverage_sub$PRO_minus 
  coverage_sub$PRO_minus_raw <-  -(coverage_sub$PRO_plus)
  coverage_sub$RNA_minus_raw <- -(coverage_sub$RNA_minus)
  coverage_sub$RNA_plus_raw <-   coverage_sub$RNA_plus
  
  coverage_sub <- coverage_sub[-c(3:6)] %>% pivot_longer(cols = c("PRO_plus_raw","PRO_minus_raw","RNA_minus_raw","RNA_plus_raw",
                                                         "PRO_plus_norm","PRO_minus_norm","RNA_minus_norm","RNA_plus_norm"))
  
  coverage_sub
  
}

setwd("/workdir/users/acv46/stool_PROSeq2/deseq/bam/pileup")
US2_cov <- get_coverage("US2_coverage_q30.txt", unique(US2_bgc$contig))
US3_cov <- get_coverage("US3_coverage_q30.txt", unique(US3_bgc$contig))
US2_cov_PRO <- US2_cov[grepl("PRO", US2_cov$name),] %>% arrange(desc(name))
US3_cov_PRO <- US3_cov[grepl("PRO", US3_cov$name),] %>% arrange(desc(name))
US2_cov_raw <- US2_cov[grepl("raw", US2_cov$name),] %>% arrange(desc(name))
US3_cov_raw <- US3_cov[grepl("raw", US3_cov$name),] %>% arrange(desc(name))

#rm(US2_cov)
#rm(US3_cov)

```



## function to plot coverage across BGCs
```{r}
# plot coverage along array
# include geom_rect for repeats
# plot logo of repeat below trace

plot_bgc <- function(bgc, cov, prom, buff, lab) {
  
  require(dplyr)
  
  # function takes the four tibbles generated in the above chunks
  # get list of CRISPR array identifiers
  # assumes 1 bgc per contig -- true for my data
  cons <- unique(bgc$contig)
  
  # plot for each contig individually
  sapply(cons,
         function(con) {
           
           # create data to plot gene ranges as geom_rect
           
           bgcdat <- bgc %>% filter(contig == con)
           csize <- bgcdat$contig_end %>% unique()
           xmin <- bgcdat$gene_start %>% min() %>% as.numeric() - buff
           xmax <- bgcdat$gene_end %>% max() %>% as.numeric() + buff
           
           if (xmin < 1) {
             xmin <- 1
           }
           
           if (xmax > csize) {
             xmax <- csize
           }
           
           cov_array <- cov[which(cov$contig == con),] %>% filter(position <= xmax & position >= xmin)
           ymax <- max(abs(cov_array$value))
           
           breaks <- seq(xmin, xmax, by = round((xmax - xmin)/7, digits = 0))
           
           genes <- data.frame(x1 = bgcdat$gene_start,
                               x2 = bgcdat$gene_end,
                               y1 = 0,
                               y2 = bgcdat$strand * ymax * 0.2,
                               stringsAsFactors = F)
           
          labels <- data.frame(x = (bgcdat$gene_start + bgcdat$gene_end)/2,
                               y = bgcdat$strand * ymax * 0.25,
                               stringsAsFactors = F,
                               name = bgcdat$name,
                               rot = bgcdat$strand * 90)
          
          lines <- data.frame(x1 = bgcdat$gene_end,
                               x2 = bgcdat$gene_end,
                               y1 = 0,
                               y2 = bgcdat$strand * ymax * 0.2,
                               stringsAsFactors = F)
    
           pc <- ggplot() +
             geom_line(data = cov[which(cov$contig == con),],
                       mapping = aes(x = factor(position), y = value, colour = name, group = 1)) +
             scale_x_discrete(breaks = breaks) +
             coord_cartesian(xlim = c(xmin, xmax),
                             ylim = c(-ymax - (0.02 * ymax), ymax + (0.02 * ymax))) +
             geom_rect(data = genes,
                       mapping = aes(xmin = x1, xmax = x2, ymin = y1, ymax = y2),
                       fill = "blue",
                       alpha = 0.2) +
             geom_text(data = labels,
                       mapping = aes(x = x, y = y, label = name, angle = rot),
                       hjust=0, vjust=0, size=3) +
             geom_segment(data = lines,
                          mapping = aes(x = x1, y = y1, xend = x2, yend = y2),
                          size = 0.1) +
             theme_classic() +
             ggtitle(paste("contig = ", con))

          print(pc)

           
           fname <- paste(lab, con, "partial.pdf", sep = "_")
           ggsave(filename = fname,
                  plot = pc,
                  device = cairo_pdf,
                  dpi = 600,
                  width = 6,
                  height = 4)
           
         })
  
   # create ordered pdf list by number of RNA-seq reads
   pdflist <- list.files(path = ".", pattern = paste(lab))
   # combine pdfs into a single file
   staple_pdf(input_files = pdflist,
              output_filepath = file.path(".",paste(lab, "bgc_merged.pdf", sep = "_")))
   # remove individual pdfs
   do.call(file.remove, list(pdflist))
  
}
```

## apply plotting function
```{r}
library(staplr)
setwd("/workdir/users/acv46/stool_PROSeq2/figures/bgc")
plot_bgc(bgc = US2_bgc, cov = US2_cov_raw, prom = US2_promoter, buff = 10, lab = "US2_v2")
plot_bgc(bgc = US3_bgc, cov = US3_cov_raw, prom = US3_promoter, buff = 10, lab = "US3_v2")
```
# VIBRANT prophage

## read in prophage data
```{r}
# see /workdir/users/acv46/stool_PROSeq2/scripts/vibrant2propagate.sh
# and /workdir/users/acv46/stool_PROSeq2/scripts/parse_vibrant_gbk.sh

library(tidyverse)

readp <- function(file) {
  
  cols <- c("contig","phage","contig_start","contig_end","gname","gene_start","gene_end","product","strand")
  phage <- read_tsv(file = file, na = "NA",
           col_names = cols)
  
  # get contig-wise gene positions
  phage$gene_start <- phage$gene_start + phage$contig_start - 1
  phage$gene_end <- phage$gene_end + phage$contig_start - 1 
  
  phage

}

setwd("/workdir/users/acv46/stool_PROSeq2/phage/vibrant")
US2_phage <- readp("US2_phage_summary.txt")
US3_phage <- readp("US3_phage_summary.txt")

```

## read in coverage data, subset for contigs with phage, then delete large dataframe
```{r}
get_coverage <- function(file, vector) {

  # file is the coverage file
  # vector is a vector of contigs for positive subsetting
  
  coverage <- read_delim(file = file,
                         delim = "\t",
                         col_names = T)
  
  # make sure column names are correct
  
  # flip RNA-seq plus and minus
  cols <- dput(scan(text = "contig position PRO_m_3 PRO_m_5 PRO_m_full PRO_p_3 PRO_p_5 PRO_p_full RNA_p_full RNA_m_full", what = ""))
  
  colnames(coverage) <- cols
  name <- dput(file) %>% str_replace("_.*", "")
  coverage_sub <- coverage[coverage$contig %in% vector,]
  coverage_sub <- coverage_sub %>% pivot_longer(cols = cols[-c(1:2)])
  coverage_sub$end <- coverage_sub$name %>% sub(".*_", "", .)
  coverage_sub$type <- coverage_sub$name %>% sub("_.*", "", .) %>% paste0(.,"-seq ",coverage_sub$end) %>% sub("3", "3' end", .)
  coverage_sub <- coverage_sub %>% dplyr::mutate(., value = ifelse(grepl("_m_", name), value * -1, value))
  coverage_sub <- coverage_sub %>% dplyr::mutate(., strand = ifelse(grepl("_m_", name), "minus", "plus"))
  coverage_sub
  
  # facet grid by end and type, plot plus and minus on same plot
  
  
}

samps <- c("PRO_m_3","PRO_m_5","PRO_p_3","PRO_p_5","PRO_m_full","PRO_p_full","RNA_p_full","RNA_m_full")
minimal <- c("PRO_m_full","PRO_p_full","PRO_m_3","PRO_p_3","RNA_p_full","RNA_m_full")

setwd("/workdir/users/acv46/stool_PROSeq2/deseq/bam/pileup")
US2_cov_all <- get_coverage("US2_coverage_q30_correct2.txt", unique(US2_phage$contig))
US3_cov_all <- get_coverage("US3_coverage_q30_correct2.txt", unique(US3_phage$contig))
# US2_cov_all_PRO <- US2_cov_all[grepl("PRO", US2_cov_all$name),] %>% arrange(desc(name))
# US3_cov_all_PRO <- US3_cov_all[grepl("PRO", US3_cov_all$name),] %>% arrange(desc(name))
US2_cov_set <- US2_cov_all[which(US2_cov_all$name %in% samps),]
US3_cov_set <- US3_cov_all[which(US3_cov_all$name %in% samps),]
US2_cov_min <- US2_cov_all[which(US2_cov_all$name %in% minimal),]
US3_cov_min <- US3_cov_all[which(US3_cov_all$name %in% minimal),]

# multiply RNA-seq reads by total PRO/RNA ratio
# ratio is simply total PRO-seq reads div by total RNA-seq reads

US2_ratio <- (120446779 + 89209651) / (23147082 + 19605905)
US3_ratio <- (125460161 + 117275362) / (21327596 + 21646500)
US2_cov_min_norm <- US2_cov_min %>% dplyr::mutate(., value = ifelse(grepl("RNA_", name), value * US2_ratio, value))
US3_cov_min_norm <- US3_cov_min %>% dplyr::mutate(., value = ifelse(grepl("RNA_", name), value * US3_ratio, value))

```

## function to plot coverage across prophage
```{r}
# plot coverage along array
# include geom_rect for repeats
# plot logo of repeat below trace

plot_phage <- function(phagedat, cov, buff, lab) {
  
  require(dplyr)
  require(gggenes)
  require(ggpubr)
  
  # function takes the four tibbles generated in the above chunks
  # get list of CRISPR array identifiers
  # assumes 1 phage per phage-containing metagenomic contig -- true for my data
  cons <- unique(phagedat$contig)
  basepal <- c('#e41a1c','#377eb8','#4daf4a','#984ea3','#ff7f00','#ffff33')
  
  # plot for each contig individually
  sapply(cons,
         function(con) {
           
           # create data to plot gene ranges as geom_rect
           
           pdat <- phagedat %>% filter(contig == con)
           
      
           
           csize <- pdat$contig_end %>% unique()
           xmin <- pdat$gene_start %>% min() %>% as.numeric() - buff
           xmax <- pdat$gene_end %>% max() %>% as.numeric() + buff
           
           if (xmin < 1) {
             xmin <- 1
           }
           
           if (xmax > csize) {
             xmax <- csize
           }
           
           cov_array <- cov[which(cov$contig == con),] %>% filter(position <= xmax & position >= xmin)
           ymax <- max(abs(cov_array$value))
           
           breaks <- seq(xmin, xmax, by = round((xmax - xmin)/7, digits = 0))
           
           labels <- data.frame(x = (pdat$gene_start + pdat$gene_end)/2,
                               y = pdat$strand * ymax * 0.25,
                               stringsAsFactors = F,
                               name = pdat$product,
                               rot = pdat$strand * 90) %>%
             mutate_if(is.character, list(~na_if(.,"hypothetical protein")))
           
           boxes <- data.frame(x1 = pdat$gene_start,
                               x2 = pdat$gene_end,
                               y1 = 0,
                               y2 = pdat$strand * ymax * 0.2,
                               stringsAsFactors = F)
           
           lines <- data.frame(x1 = pdat$gene_end,
                               x2 = pdat$gene_end,
                               y1 = 0,
                               y2 = pdat$strand * ymax * 0.2,
                               stringsAsFactors = F)
           
           genes <- pdat %>% dplyr::mutate(., start = ifelse(strand == 1, gene_start, gene_end)) %>% 
             dplyr::mutate(., end = ifelse(strand == 1, gene_end, gene_start)) %>% 
             select(-c(contig_start,contig_end,gene_start,gene_end,contig,gname)) %>%
             mutate(index = paste0("gene",1:n()))
           
           pal <- rep_len(basepal, nrow(genes))
           
           pc <- ggplot() +
             geom_line(data = cov[which(cov$contig == con),],
                       mapping = aes(x = factor(position), y = value, group = 1),
                       color = "red") +
             facet_grid(type ~ .) + 
             scale_x_discrete(breaks = breaks) +
             coord_cartesian(xlim = c(xmin, xmax),
                             ylim = c(-ymax - (0.02 * ymax), ymax + (0.02 * ymax))) +
             geom_rect(data = boxes,
                       mapping = aes(xmin = x1, xmax = x2, ymin = y1, ymax = y2),
                       fill = "blue",
                       alpha = 0.2) +
             geom_segment(data = lines,
                          mapping = aes(x = x1, y = y1, xend = x2, yend = y2),
                          size = 0.1) +
             # geom_text(data = labels,
             #           mapping = aes(x = x, y = y, label = name, angle = rot),
             #           hjust=0, vjust=0, size=2.5) +
             theme_classic() +
             geom_hline(yintercept = 0, color = "black") +
             ggtitle(paste0(lab, ", contig = ", con)) +
             xlab("") +
             ylab("Normalized per-base read depth")
           
           geneplot <- ggplot(genes,
                              aes(xmin = start,
                                  xmax = end,
                                  y = phage,
                                  fill = index,
                                  label = product)) +
             geom_gene_arrow(arrowhead_height = unit(3, "mm"),
                             arrowhead_width = unit(1, "mm")) +
             facet_wrap(~ phage, scales = "free", ncol = 1) +
             scale_fill_manual(values = pal) +
             theme_genes() +
             theme(legend.position = "none",
                   axis.text.y = element_blank(),
                   #axis.ticks.y = element_blank(),
                   axis.title.x = element_blank(),
                   axis.text.x = element_blank(),
                   axis.ticks.x = element_blank()) +
             ylab(" ") 
           
           print(ggarrange(pc, geneplot, ncol = 1, nrow = 2, heights = c(3, 0.5)))

           fname <- paste(lab, con, "partial.pdf", sep = "_")
           ggsave(filename = fname,
                  plot = pc,
                  device = cairo_pdf,
                  dpi = 600,
                  width = 6,
                  height = 4)
           
         })
  
   # create ordered pdf list by number of RNA-seq reads
   pdflist <- list.files(path = ".", pattern = paste(lab)) %>% .[grep("partial.pdf",.)]
   # combine pdfs into a single file
   staple_pdf(input_files = pdflist,
              output_filepath = file.path(".",paste(lab, "prophage_merged_v2.pdf", sep = "_")))
   # remove individual pdfs
   do.call(file.remove, list(pdflist))
  
}
```

## apply plotting function
```{r}
library(staplr)
setwd("/workdir/users/acv46/stool_PROSeq2/figures/phage")
plot_phage(phagedat = US2_phage, cov = US2_cov_min, buff = 0, lab = "US2")
plot_phage(phagedat = US3_phage, cov = US3_cov_min, buff = 0, lab = "US3")
```
## plot specific regions within prophage
```{r}
# plot coverage along array
# include geom_rect for repeats
# plot logo of repeat below trace

plot_phage2 <- function(phagedat, con, cov, buff, gene_set, lab) {
  
  require(dplyr)
  require(gggenes)
  require(ggpubr)
  
  # function takes the four tibbles generated in the above chunks
  # get list of CRISPR array identifiers
  # assumes 1 phage per phage-containing metagenomic contig -- true for my data
  # con is the contig of interest
  # gene_set is range of row numbers in pdat to subset
  
  basepal <- c('#e41a1c','#377eb8','#4daf4a','#984ea3','#ff7f00','#ffff33')
  
  # plot for each contig individually
           
           # create data to plot gene ranges as geom_rect
           
           pdat <- phagedat %>% filter(contig == con)
           
           if (!is.na(gene_set)) {
             
             pdat <- pdat[gene_set,]
             
           }
           
           csize <- pdat$contig_end %>% unique()
           xmin <- pdat$gene_start %>% min() %>% as.numeric() - buff
           xmax <- pdat$gene_end %>% max() %>% as.numeric() + buff
           
           if (xmin < 1) {
             xmin <- 1
           }
           
           if (xmax > csize) {
             xmax <- csize
           }
           
           cov_array <- cov[which(cov$contig == con),] %>% filter(position <= xmax & position >= xmin)
           ymax <- max(abs(cov_array$value))
           
           breaks <- seq(xmin, xmax, by = round((xmax - xmin)/7, digits = 0))
           
           labels <- data.frame(x = (pdat$gene_start + pdat$gene_end)/2,
                               y = pdat$strand * ymax * 0.25,
                               stringsAsFactors = F,
                               name = pdat$product,
                               rot = pdat$strand * 90) %>%
             mutate_if(is.character, list(~na_if(.,"hypothetical protein")))
           
           boxes <- data.frame(x1 = pdat$gene_start,
                               x2 = pdat$gene_end,
                               y1 = 0,
                               y2 = pdat$strand * ymax * 0.2,
                               stringsAsFactors = F)
           
           lines <- data.frame(x1 = pdat$gene_end,
                               x2 = pdat$gene_end,
                               y1 = 0,
                               y2 = pdat$strand * ymax * 0.2,
                               stringsAsFactors = F)
           
           genes <- pdat %>% mutate(., start = ifelse(strand == 1, gene_start, gene_end)) %>% 
             mutate(., end = ifelse(strand == 1, gene_end, gene_start)) %>% 
             select(-c(contig_start,contig_end,gene_start,gene_end,contig,gname)) %>%
             mutate(index = paste0("gene",1:n())) %>%
             mutate(num = 1:n()) %>%
             mutate(., labposx = ifelse(strand == 1, start, end)) %>%
             mutate(., labang = ifelse(strand == 1, 10, -10)) %>%
             mutate(., labposy = ifelse(strand == 1, ((num - 1) %% 3 + 2), -1 * ((num - 1) %% 3 + 2)))
           
           pal <- rep_len(basepal, nrow(genes))
           
           pc <- ggplot() +
             geom_line(data = cov[which(cov$contig == con),],
                       mapping = aes(x = factor(position), y = value, group = 1),
                       color = "red") +
             facet_grid(type ~ .) + 
             scale_x_discrete(breaks = breaks) +
             coord_cartesian(xlim = c(xmin, xmax),
                             ylim = c(-ymax - (0.02 * ymax), ymax + (0.02 * ymax))) +
             geom_rect(data = boxes,
                       mapping = aes(xmin = x1, xmax = x2, ymin = y1, ymax = y2),
                       fill = "blue",
                       alpha = 0.2) +
             # geom_text(data = labels,
             #           mapping = aes(x = x, y = y, label = name, angle = rot),
             #           hjust=0, vjust=0, size=2.5) +
             geom_segment(data = lines,
                          mapping = aes(x = x1, y = y1, xend = x2, yend = y2),
                          size = 0.1) +
             theme_classic() +
             geom_hline(yintercept = 0, color = "black") +
             ggtitle(paste0(lab, ", contig = ", con)) +
             theme(axis.title.x = element_blank(),
                   axis.text.x = element_blank(),
                   axis.ticks.x = element_blank(),
                   strip.text.y = element_text(size = 8)) +
             ylab("Normalized per-base read depth")
           
           geneplot <- ggplot(genes,
                              aes(xmin = start,
                                  xmax = end,
                                  y = phage,
                                  fill = index,
                                  label = product)) +
             geom_gene_arrow(arrowhead_height = unit(3, "mm"),
                             arrowhead_width = unit(1, "mm")) +
             geom_text(mapping = aes(x = labposx, vjust = labposy),
                       size = 2.5, inherit.aes = T, hjust = 0) +
             #geom_gene_label(align = "left", angle = 30, hjust = -0.2, size = 3) +
             #facet_wrap(~ phage, scales = "free", ncol = 1) +
             scale_fill_manual(values = pal) +
             theme_genes() +
             theme(legend.position = "none",
                   axis.text.y = element_blank(),
                   axis.ticks.y = element_blank(),
                   axis.title.x = element_blank()) +
             ylab(" ")
           
           print(ggarrange(pc, geneplot, ncol = 1, nrow = 2, heights = c(2, 0.8)))

           # fname <- paste(lab, con, "partial.pdf", sep = "_")
           # ggsave(filename = fname,
           #        plot = pc,
           #        device = cairo_pdf,
           #        dpi = 600,
           #        width = 6,
           #        height = 4)
           
         }
  
   # # create ordered pdf list by number of RNA-seq reads
   # pdflist <- list.files(path = ".", pattern = paste(lab))
   # # combine pdfs into a single file
   # staple_pdf(input_files = pdflist,
   #            output_filepath = file.path(".",paste(lab, "prophage_merged.pdf", sep = "_")))
   # # remove individual pdfs
   # do.call(file.remove, list(pdflist))
 
```
## apply plotting function
```{r}
library(staplr)
setwd("/workdir/users/acv46/stool_PROSeq2/figures/phage")
phagea <- plot_phage2(phagedat = US2_phage, con  = "NODE_879_length_15380", cov = US2_cov_min_norm, buff = 0, gene_set = c(14:15), lab = "US2")
phageb <- plot_phage2(phagedat = US3_phage, con  = "NODE_37_length_95110", cov = US3_cov_min_norm, buff = 0, gene_set = c(15:22), lab = "US3")
phagec <- plot_phage2(phagedat = US3_phage, con  = "NODE_16_length_131929", cov = US3_cov_min_norm, buff = 0, gene_set = c(2:5), lab = "US3")
phagee <- plot_phage2(phagedat = US3_phage, con  = "NODE_16_length_131929", cov = US3_cov_min_norm, buff = 0, gene_set = c(2:11), lab = "US3")
phagef <- plot_phage2(phagedat = US3_phage, con  = "NODE_252_length_32982", cov = US3_cov_min_norm, buff = 0, gene_set = c(13:16), lab = "US3")
phageg <- plot_phage2(phagedat = US3_phage, con  = "NODE_252_length_32982", cov = US3_cov_min_norm, buff = 0, gene_set = c(39:44), lab = "US3")
```
### ggsave
```{r}
setwd("/workdir/users/acv46/stool_PROSeq2/figures/phage")
ggsave(filename = "US2_NODE_879_genes14-15_v2.pdf",
                  plot = phagea,
                  device = cairo_pdf,
                  dpi = 600,
                  width = 7,
                  height = 5)
ggsave(filename = "US3_NODE_37_genes15-22_v2.pdf",
                  plot = phageb,
                  device = cairo_pdf,
                  dpi = 600,
                  width = 7,
                  height = 5)
ggsave(filename = "US3_NODE_16_genes2-5_v2.pdf",
                  plot = phagec,
                  device = cairo_pdf,
                  dpi = 600,
                  width = 7,
                  height = 5)
```

## focus on one phage, NODE_87_length_71267
```{r}
library(staplr)
setwd("/workdir/users/acv46/stool_PROSeq2/figures/phage")
phaged1 <- plot_phage2(phagedat = US2_phage, con  = "NODE_87_length_71267", cov = US2_cov_min_norm, buff = 0, gene_set = c(9:12), lab = "US2")
phaged2 <- plot_phage2(phagedat = US2_phage, con  = "NODE_87_length_71267", cov = US2_cov_min_norm, buff = 0, gene_set = c(40:44), lab = "US2")
phaged3 <- plot_phage2(phagedat = US2_phage, con  = "NODE_87_length_71267", cov = US2_cov_min_norm, buff = 0, gene_set = c(75:78), lab = "US2")
```

### ggsave
```{r}
setwd("/workdir/users/acv46/stool_PROSeq2/figures/phage")
ggsave(filename = "US2_NODE_87_genes9-12_v2.pdf",
                  plot = phaged1,
                  device = cairo_pdf,
                  dpi = 600,
                  width = 7,
                  height = 5)
ggsave(filename = "US2_NODE_87_genes40-44_v2.pdf",
                  plot = phaged2,
                  device = cairo_pdf,
                  dpi = 600,
                  width = 7,
                  height = 5)
ggsave(filename = "US2_NODE_87_genes75-78_v2.pdf.pdf",
                  plot = phaged3,
                  device = cairo_pdf,
                  dpi = 600,
                  width = 7,
                  height = 5)
```
# MAPQ and mapped read length histograms
## read in mapq disributions and plot
```{r}
require(readr)
require(purrr)
require(scales)
get_mapq <- function(file) {
  
  data <- read_tsv(file = file,
                   col_names = c("count","score"))
  
  data$count <- (data$count / sum(data$count)) * 100 
  data$sample <- unlist(base::strsplit(x = file, split = "_"))[[1]]
  data$lib_type <- paste0(unlist(base::strsplit(x = file, split = "_"))[[2]], "-seq")
  
  data
  
}


setwd("/workdir/users/acv46/stool_PROSeq2/deseq/bam/pileup/stats")
US2_PRO_mapq <- get_mapq("US2_PRO_mapq.txt")
US3_PRO_mapq <- get_mapq("US3_PRO_mapq.txt")
US2_RNA_mapq <- get_mapq("US2_RNA_mapq.txt")
US3_RNA_mapq <- get_mapq("US3_RNA_mapq.txt")

mapq_dat <- list(US2_PRO_mapq, US2_RNA_mapq, US3_PRO_mapq, US3_RNA_mapq) %>%
  do.call(rbind,.)

mq <- ggplot() + 
  geom_bar(data = mapq_dat,
          mapping = aes(x = score, y = count),
          stat = "identity") +
  facet_grid(sample ~ lib_type) + 
  # scale_y_log10(breaks = trans_breaks("log10", function(x) 10^x),
  #             labels = trans_format("log10", math_format(10^.x))) +
  theme_bw() +
  theme(axis.text.x = element_text(size = 12),
        axis.text.y = element_text(size = 12)) +
  ylab("Library Percent") +
  xlab("MAPQ score") +
  ggtitle("MAPQ score distributions for metagenomic libraries")

mq
```

## read in seq length distributions and plot
```{r}
require(readr)
require(purrr)
require(scales)
get_readdist <- function(file) {
  
  data <- read_tsv(file = file,
                   col_names = c("count","length"))
  
  data$count <- (data$count / sum(data$count)) * 100 
  data$sample <- unlist(base::strsplit(x = file, split = "_"))[[1]]
  data$lib_type <- paste0(unlist(base::strsplit(x = file, split = "_"))[[2]], "-seq")
  
  data <- data %>% filter(length > 1)
  
  data
  
}


setwd("/workdir/users/acv46/stool_PROSeq2/deseq/bam/pileup/stats")
US2_PRO_readlen <- get_readdist("US2_PRO_mappedReadLength.txt")
US3_PRO_readlen <- get_readdist("US3_PRO_mappedReadLength.txt")
US2_RNA_readlen <- get_readdist("US2_RNA_mappedReadLength.txt")
US3_RNA_readlen <- get_readdist("US3_RNA_mappedReadLength.txt")

readlen_dat <- list(US2_PRO_readlen, US2_RNA_readlen, US3_PRO_readlen, US3_RNA_readlen) %>%
  do.call(rbind,.)

ml <- ggplot() + 
  geom_bar(data = readlen_dat,
          mapping = aes(x = length, y = count),
          stat = "identity") +
  facet_grid(sample ~ lib_type) + 
  # scale_y_log10(breaks = trans_breaks("log10", function(x) 10^x),
  #             labels = trans_format("log10", math_format(10^.x))) +
  theme_bw() +
  theme(axis.text.x = element_text(size = 12),
        axis.text.y = element_text(size = 12)) +
  ylab("Library Percent") +
  xlab("Read Length") +
  ggtitle("Length distributions for mapped reads")

ml
```

## ggsave plots
```{r}
setwd("/workdir/users/acv46/stool_PROSeq2/figures/read_stats")
ggsave(plot = mq, filename = "mapq_dist_mgm.pdf", width = 6, height = 4, device = "pdf", useDingbats = F)
ggsave(plot = ml, filename = "length_dist_mgm.pdf", width = 6, height = 4, device = "pdf", useDingbats = F)
```


# Invertons

## read in inverton data
```{r}
library(tidyverse)

# ran PhaseFinder with parameters requiring zero mismatches in inverted repeats
# function subsets for invertons with non-zero ratios and at least x span reads

read_invert <- function(file) {

  read_tsv(file = file,
           col_names = T,
           na = "NA") %>%
    mutate(contig = gsub("_cov_.*:.*","",ID)) %>%
    mutate(rep1_start = ) %>% 
    mutate(coords = gsub(".*:","",ID)) %>% 
    separate(coords, c("rep1_start", "rep1_stop", "rep2_start", "rep2_stop")) %>%
    filter(Span_ratio > 0 | Pe_ratio > 0) %>%
    filter(Span_F + Span_R >= 10 | Pe_F + Pe_R >= 10)
    
}

setwd("/workdir/users/acv46/stool_PROSeq2/invertons/out_mismatch0")
US2_invert <- read_invert("US2_5Nov2020_out.ratio.txt")
US3_invert <- read_invert("US3_3Nov2020_out.ratio.txt")
# US2_invert_PRO <- read_invert("US2_5Nov2020_PRO_out.ratio.txt")
# US2_invert_RNA <- read_invert("US2_5Nov2020_RNA_out.ratio.txt")
# US3_invert_PRO <- read_invert("US3_3Nov2020_PRO_out.ratio.txt")
# US3_invert_RNA <- read_invert("US3_3Nov2020_RNA_out.ratio.txt")
```

### merge metagenomic and transcriptomic PhaseFinder results
```{r}
library(tidyverse)

# ran PhaseFinder with parameters requiring zero mismatches in inverted repeats
# function subsets for invertons with non-zero ratios and at least x span reads

read_invert2 <- function(mgm, pro, rna) {

  fm <- read_tsv(file = mgm,
           col_names = T,
           na = "NA") %>% select(c(1,2,3,5,6))
  
  colnames(fm) <- unlist(str_split("ID pf_mgm pr_mgm sf_mgm sr_mgm", pattern = " "))
  
  print(fm)
  
  fr <- read_tsv(file = rna,
           col_names = T,
           na = "NA") %>% select(c(1,2,3,5,6))
  
  colnames(fr) <- unlist(str_split("ID pf_rna pr_rna sf_rna sr_rna", pattern = " "))
  
  fp <- read_tsv(file = pro,
           col_names = T,
           na = "NA") %>% select(c(1,2,3,5,6))
  
  colnames(fp) <- unlist(str_split("ID pf_pro pr_pro sf_pro sr_pro", pattern = " "))
  
  print(fm)
  print(fr)
  print(fp)
  
  fjoin <- list(fm, fr, fp) %>% reduce(inner_join, by = "ID")
  
  fjoin
  
    # mutate(contig = gsub("_cov_.*:.*","",ID)) %>%
    # mutate(rep1_start = ) %>% 
    # mutate(coords = gsub(".*:","",ID)) %>% 
    # separate(coords, c("rep1_start", "rep1_stop", "rep2_start", "rep2_stop")) %>%
    # filter(Span_ratio > 0 | Pe_ratio > 0) %>%
    # filter(Span_F + Span_R >= 10 | Pe_F + Pe_R >= 10)
    
}

setwd("/workdir/users/acv46/stool_PROSeq2/invertons/out_mismatch0")
US2_invert_all <- read_invert2("US2_5Nov2020_out.ratio.txt","US2_5Nov2020_PRO_out.ratio.txt","US2_5Nov2020_RNA_out.ratio.txt")
US3_invert_all <- read_invert2("US3_3Nov2020_out.ratio.txt","US3_3Nov2020_PRO_out.ratio.txt","US3_3Nov2020_RNA_out.ratio.txt")

```

## read in gtf data
```{r}
require(rtracklayer)
require(tidyr)

# ran PhaseFinder with parameters requiring zero mismatches in inverted repeats
# function subsets for invertons with non-zero ratios and at least x span reads

read_gtf <- function(file) {

  rtracklayer::import(file) %>%
    as_tibble() %>% select(dput(scan(text = "seqnames start end width strand source type ID product feature_type eC_number Name", what = ""))) %>%
    `colnames<-`(dput(scan(text = "contig start end width strand source type ID product feature_type eC_number Name", what = ""))) %>%
    mutate(Name = sub("_.*","",Name))
    
}

setwd("/workdir/users/acv46/stool_PROSeq2/deseq/prokka")
US2_gtf <- read_gtf("US2_allcontigs/US2_allcontigs_CUSTOM_FType.gtf")
US3_gtf <- read_gtf("US3_allcontigs/US3_allcontigs_CUSTOM_FType.gtf")
```

## read in scaffolds2bins, bin annotation files, checkM stats, kraken taxa
```{r}
# scaffold to bin mapping
US2_scaff2bin <- read_tsv("/workdir/users/acv46/mgmAssembly/US2_5Nov2020_CAB/DASTool/US2_5Nov2020_redo_DASTool_scaffolds2bin.txt", col_names = F) %>%
  `colnames<-`(c("contig","bin")) %>% mutate(contig = gsub("_cov.*", "", contig))
US3_scaff2bin <- read_tsv("/workdir/users/acv46/mgmAssembly/US3_3Nov2020_CAB/DASTool/US3_3Nov2020_DASTool_scaffolds2bin.txt", col_names = F) %>%
  `colnames<-`(c("contig","bin")) %>% mutate(contig = gsub("_cov.*", "", contig))

# gtdbtk taxa
US2_gtdbtk <- read_tsv("/workdir/users/acv46/mgmAssembly/US2_5Nov2020_CAB/DASTool/gtdbtk/gtdbtk.bac120.summary.tsv", col_names = T)[,c(1,2)] %>%
  separate(., classification,
           into = c("g_kingdom","g_phylum","g_class","g_order","g_family","g_genus","g_species"),
           sep = ";", fill = "right", extra = "drop") %>%
  mutate_all(str_replace_all, ".*__", "")
US3_gtdbtk <- read_tsv("/workdir/users/acv46/mgmAssembly/US3_3Nov2020_CAB/DASTool/gtdbtk/gtdbtk.bac120.summary.tsv", col_names = T)[,c(1,2)] %>%
  separate(., classification,
           into = c("g_kingdom","g_phylum","g_class","g_order","g_family","g_genus","g_species"),
           sep = ";", fill = "right", extra = "drop") %>%
  mutate_all(str_replace_all, ".*__", "")
colnames(US2_gtdbtk)[1] <- "bin"
colnames(US3_gtdbtk)[1] <- "bin"

# checkM relative abundance
abund_cols <- dput(scan(text = "bin mbp mgm_reads percent_reads percent_binned percent_community", what = ""))
US2_abund <- read_tsv("/workdir/users/acv46/mgmAssembly/US2_5Nov2020_CAB/DASTool/checkM/US2_5Nov2020_checkM_abundance.txt", col_names = T)
US3_abund <- read_tsv("/workdir/users/acv46/mgmAssembly/US3_3Nov2020_CAB/DASTool/checkM/US3_3Nov2020_checkM_abundance.txt", col_names = T)
colnames(US2_abund) <- abund_cols
colnames(US3_abund) <- abund_cols

# checkM lineage, completeness, and contamination
stats_cols <- dput(scan(text = "bin marker_lineage uid num_genomes num_markers num_marker_sets 0 1 2 3 4 5+ completeness contamination strain_heterogeneity", what = ""))
US2_stats <- read_table2("/workdir/users/acv46/mgmAssembly/US2_5Nov2020_CAB/DASTool/checkM/US2_5Nov2020_checkM_lineage.txt", comment = "-", col_names = T)
US3_stats <- read_table2("/workdir/users/acv46/mgmAssembly/US3_3Nov2020_CAB/DASTool/checkM/US3_3Nov2020_checkM_lineage.txt", comment = "-", col_names = T)
colnames(US2_stats) <- stats_cols
colnames(US3_stats) <- stats_cols

# kraken taxa 
# merged with bash
## while read bin; do head -n 9 ${bin}.report.txt | sed "s/^/${bin}\t/g" >> merged_reports.txt; done < bins.txt
kraken_cols <- dput(scan(text = "bin k_percent k_clade_frags k_taxa_frags k_rank_code k_taxid k_name", what = ""))
US2_kraken <- read_tsv("/workdir/users/acv46/stool_PROSeq2/kraken2/US2_5Nov2020/merged_reports.txt", col_names = F)
US3_kraken <- read_tsv("/workdir/users/acv46/stool_PROSeq2/kraken2/US3_3Nov2020/merged_reports.txt", col_names = F)
colnames(US2_kraken) <- kraken_cols
colnames(US3_kraken) <- kraken_cols
US2_kraken <- US2_kraken %>%
  pivot_wider(., id_cols = c(bin),
              names_from = k_rank_code,
              values_from = c(k_name,k_percent)) %>%
  select(-c(k_name_R, k_percent_R)) %>%
  mutate_all(str_replace_all, ".*__", "") %>%
  mutate_all(str_replace_all, "\\.fa", "")
US3_kraken <- US3_kraken %>%
  pivot_wider(., id_cols = c(bin),
              names_from = k_rank_code,
              values_from = c(k_name,k_percent)) %>%
  select(-c(k_name_U, k_percent_U)) %>%
  mutate_all(str_replace_all, ".*__", "") %>%
  mutate_all(str_replace_all, "\\.fa", "")

```

## create tibble with all data
```{r}
merge_data <- function(invert, scaff2bin, abund, stats, gtdbtk, kraken) {
  
  # invert is inverton data
  # scaff2bin is the file connecting scaffolds to bins
  # abund is the checkM relative abudance data
  # stats is checkM stats on Completeness and Contam
  # gtdbtk is the gtdbtk taxa data
  # kraken is the trimmed down Kraken2 output
  
  # consider merging bracken output as well
  
  subdat <- invert
  #colnames(subdat) <- dput(scan(text = "type contig start end strand lengths name product id PRO1 PRO2 RNA1 RNA2", what = ""))
  subdat <- dplyr::inner_join(scaff2bin, subdat, by = "contig")
  subdat <- dplyr::inner_join(abund[,c(1,2,5,6)], subdat, by = "bin")
  subdat <- dplyr::inner_join(gtdbtk, subdat, by = "bin")
  subdat <- dplyr::inner_join(stats[,c(1,13,14)], subdat, by = "bin")
  subdat <- dplyr::inner_join(kraken, subdat, by = "bin")
  subdat
  
}

# apply merge_data
US2_invdat <- merge_data(US2_invert, US2_scaff2bin, US2_abund, US2_stats, US2_gtdbtk, US2_kraken)
US3_invdat <- merge_data(US3_invert, US3_scaff2bin, US3_abund, US3_stats, US3_gtdbtk, US3_kraken)
# subset for taxonomic levels
pgs_names <- dput(scan(text = "bin k_name_P k_name_G k_name_S k_name_S1 k_percent_P k_percent_G k_percent_S k_percent_S1 completeness contamination g_phylum g_genus g_species mbp percent_binned percent_community ID Pe_F Pe_R Pe_ratio Span_F Span_R Span_ratio contig rep1_start rep1_stop rep2_start rep2_stop", what = ""))
US2_invdat <- US2_invdat[,pgs_names]
US3_invdat <- US3_invdat[,pgs_names]  
```

## read in coverage data, subset for contigs with invertons, then delete large dataframe
```{r}
get_coverage <- function(file, vector) {

  # file is the coverage file
  # vector is a vector of contigs for positive subsetting
  
  coverage <- read_delim(file = file,
                         delim = "\t",
                         col_names = T)
  
  # make sure column names are correct
  
  # flip RNA-seq plus and minus
  cols <- dput(scan(text = "contig position PRO_m_3 PRO_m_5 PRO_m_full PRO_p_3 PRO_p_5 PRO_p_full RNA_p_full RNA_m_full", what = ""))
  
  colnames(coverage) <- cols
  name <- dput(file) %>% str_replace("_.*", "")
  coverage_sub <- coverage[coverage$contig %in% vector,]
  coverage_sub <- coverage_sub %>% pivot_longer(cols = cols[-c(1:2)])
  coverage_sub$end <- coverage_sub$name %>% sub(".*_", "", .)
  coverage_sub$type <- coverage_sub$name %>% sub("_.*", "", .) %>% paste0(.,"-seq ",coverage_sub$end) %>% sub("3", "3' end", .) %>% sub("5", "5' end", .)
  coverage_sub <- coverage_sub %>% dplyr::mutate(., value = ifelse(grepl("_m_", name), value * -1, value))
  coverage_sub <- coverage_sub %>% dplyr::mutate(., strand = ifelse(grepl("_m_", name), "minus", "plus"))
  coverage_sub
  
  # facet grid by end and type, plot plus and minus on same plot
  
  
}

samps <- c("PRO_m_3","PRO_m_5","PRO_p_3","PRO_p_5","PRO_m_full","PRO_p_full","RNA_p_full","RNA_m_full")
minimal <- c("PRO_m_full","PRO_p_full","PRO_m_3","PRO_p_3","RNA_p_full","RNA_m_full")
pro <- c("PRO_m_full","PRO_p_full","PRO_m_3","PRO_p_3","PRO_m_5","PRO_p_5","RNA_p_full","RNA_m_full")

setwd("/workdir/users/acv46/stool_PROSeq2/deseq/bam/pileup")
US2_cov_all <- get_coverage("US2_coverage_q30_correct2.txt", unique(US2_invdat$contig))
US3_cov_all <- get_coverage("US3_coverage_q30_correct2.txt", unique(US3_invdat$contig))
# US2_cov_all_PRO <- US2_cov_all[grepl("PRO", US2_cov_all$name),] %>% arrange(desc(name))
# US3_cov_all_PRO <- US3_cov_all[grepl("PRO", US3_cov_all$name),] %>% arrange(desc(name))
# US2_cov_set <- US2_cov_all[which(US2_cov_all$name %in% samps),]
# US3_cov_set <- US3_cov_all[which(US3_cov_all$name %in% samps),]
# US2_cov_min <- US2_cov_all[which(US2_cov_all$name %in% minimal),]
# US3_cov_min <- US3_cov_all[which(US3_cov_all$name %in% minimal),]
US2_cov_PRO <- US2_cov_all[which(US2_cov_all$name %in% pro),]
US3_cov_PRO <- US3_cov_all[which(US3_cov_all$name %in% pro),]

# multiply RNA-seq reads by total PRO/RNA ratio
# ratio is simply total PRO-seq reads div by total RNA-seq reads

US2_ratio <- (120446779 + 89209651) / (23147082 + 19605905)
US3_ratio <- (125460161 + 117275362) / (21327596 + 21646500)
# US2_cov_min_norm <- US2_cov_min %>% dplyr::mutate(., value = ifelse(grepl("RNA_", name), value * US2_ratio, value))
# US3_cov_min_norm <- US3_cov_min %>% dplyr::mutate(., value = ifelse(grepl("RNA_", name), value * US3_ratio, value))
US2_cov_pro_norm <- US2_cov_PRO %>% dplyr::mutate(., value = ifelse(grepl("RNA_", name), value * US2_ratio, value))
US3_cov_pro_norm <- US3_cov_PRO %>% dplyr::mutate(., value = ifelse(grepl("RNA_", name), value * US3_ratio, value))

rm(US2_cov_all)
rm(US3_cov_all)

```

## function to plot coverage across invertible regions
```{r}
# plot coverage along array
# include geom_rect for repeats
# plot logo of repeat below trace

plot_inv <- function(invdat, cov, buff, gtf, lab, version, splitnum) {

require(ggplot2)  
require(dplyr)
require(tidyr)
require(gggenes)
#require(ggpubr)
require(patchwork)
#require(staplr)
require(png)
require(grid)
require(gridExtra)
  
  ids <- unique(invdat$ID)
  basepal <- c('#e41a1c','#377eb8','#4daf4a','#984ea3','#ff7f00','#ffff33')
  basepal2 <- c("#e0607e","#aec5eb","#f4d35e","#ee964b","#3ab795")
  
  # plot for each contig individually
  sapply(ids,
         function(id) {
           
           # create data to plot gene ranges as geom_rect
           
           pdat <- invdat %>% filter(ID == id)
           con <- pdat$contig
           csize <- id %>% sub(".*_length_","",.) %>% sub("_cov_.*","",.) %>% as.numeric()
           xmin <- pdat$rep1_start %>% as.numeric() - buff
           xmax <- pdat$rep2_stop %>% as.numeric() + buff
           
           if (xmin < 1) {
             xmin <- 1
           }
           
           if (xmax > csize) {
             xmax <- csize
           }
           
           cov_array <- cov %>% filter(contig == con & position %in% c(xmin:xmax))
           ymax <- max(abs(cov_array$value))
           
           breaks <- seq(xmin, xmax, by = round((xmax - xmin)/5, digits = 0))
           
           tri1 <- data.frame(x = as.numeric(c(pdat$rep1_start, pdat$rep1_stop, pdat$rep1_start)),
                              y = c(0.2 * ymax, 0, -0.2 * ymax),
                              stringsAsFactors = F)
           
           tri2 <- data.frame(x = as.numeric(c(pdat$rep2_stop, pdat$rep2_start, pdat$rep2_stop)),
                              y = c(0.2 * ymax, 0, -0.2 * ymax),
                              stringsAsFactors = F)
           
           # arrow1 <- data.frame(x = as.numeric(pdat$rep1_start) + ((xmax - xmin) / 40),
           #                      xend = as.numeric(pdat$rep1_start),
           #                      y = -0.7 * ymax, type = "RNA-seq full")
           # arrow2 <- data.frame(x = as.numeric(pdat$rep2_stop) - ((xmax - xmin) / 40),
           #                      xend = as.numeric(pdat$rep2_stop),
           #                      y = -0.7 * ymax, type = "RNA-seq full")
           
           # fails if contig does not have any annotated genes
           
           numgenes <- gtf %>% filter(contig == con) %>% nrow()
           
           if (numgenes > 1) {
           
             genes <- gtf[,c(1:3,5,7,12,13,15)] %>% filter(contig == con) %>%
             dplyr::mutate(., gene_start = ifelse(strand == "+", start, end)) %>% 
             dplyr::mutate(., gene_end = ifelse(strand == "+", end, start)) %>%
             dplyr::mutate(., index = paste0("gene",1:n()))
             # dplyr::mutate(., labposx = ifelse(strand == 1, start, end)) %>%
             # dplyr::mutate(., labang = ifelse(strand == 1, 10, -10)) %>%
             # dplyr::mutate(., labposy = ifelse(strand == 1, ((num - 1) %% 3 + 2), -1 * ((num - 1) %% 3 + 2)))
           
             pal <- rep_len(basepal2, nrow(genes))
           
             pc <- ggplot() +
               geom_line(data = cov[which(cov$contig == con),],
                         mapping = aes(x = factor(position), y = value),
                         color = "red") +
               facet_grid(type ~ .) + 
               geom_text(data = cov[which(cov$contig == con),],
                         mapping = aes(x = xmin + ((xmax - xmin) %/% 60),
                                       y = ymax * 0.8,
                                       label = type),
                         hjust = 0, size = 2.5,
                         check_overlap = TRUE) +
               coord_cartesian(xlim = c(xmin, xmax),
                               ylim = c(-ymax - (0.02 * ymax), ymax + (0.02 * ymax)),
                               clip = "on") +
               theme_bw() +
               geom_hline(yintercept = 0, color = "black") +
               ggtitle(paste0(lab, ", contig = ", id, "\n",
                              "bin = ", pdat$bin, ", ",
                              pdat$k_name_S, " (",pdat$k_name_S1,")","\n",
                              "Pe_F = ", pdat$Pe_F,", Pe_R = ", pdat$Pe_R,
                              ", Span_F = ", pdat$Span_F,", Span_R = ", pdat$Span_R)) +
               xlab("") +
               ylab("Normalized per-base read depth") +
               theme(strip.background = element_blank(),
                     strip.text.y = element_blank(),
                     panel.grid.major = element_blank(),
                     panel.grid.minor = element_blank(),
                     axis.text.x = element_blank(),
                     axis.ticks.x = element_blank(),
                     plot.title = element_text(size = 8),
                     plot.margin = unit(c(0,0,0,0), "cm")) +
               geom_polygon(data = tri1,
                            mapping = aes(x = x, y = y),
                            fill = "blue",
                            alpha = 0.4,
                            inherit.aes = F) +
               geom_polygon(data = tri2,
                            mapping = aes(x = x, y = y),
                            fill = "blue",
                            alpha = 0.4,
                            inherit.aes = F) 
               # geom_segment(data = arrow1,
               #              mapping = aes(x = x, xend = xend, y = y, yend = y),
               #              arrow = arrow(length=unit(0.25,"cm")),
               #              show.legend = F) +
               # geom_segment(data = arrow2,
               #              mapping = aes(x = x, xend = xend, y = y, yend = y),
               #              arrow = arrow(length=unit(0.25,"cm")),
               #              show.legend = F) +
               # geom_text(data = arrow1,
               #              mapping = aes(x = xend - ((xmax - xmin) %/% 40),
               #                            y = y),
               #              label = pdat$Pe_R,
               #              show.legend = F) +
               # geom_text(data = arrow2,
               #              mapping = aes(x = xend + ((xmax - xmin) %/% 40),
               #                            y = y),
               #              label = pdat$Pe_F,
               #              show.legend = F)
             
             geneplot <- ggplot(genes,
                                aes(xmin = gene_start,
                                    xmax = gene_end,
                                    y = contig,
                                    fill = index,
                                    label = product)) +
               geom_gene_arrow(arrowhead_width = grid::unit(6, "mm"),
                               arrowhead_height = grid::unit(6, "mm"),
                               arrow_body_height = grid::unit(4, "mm")) +
               geom_gene_label() +
               # geom_text(mapping = aes(x = labposx, vjust = labposy),
               #         size = 2.5, inherit.aes = T, hjust = 0) +
               facet_wrap(~ contig, scales = "free", ncol = 1) +
               scale_fill_manual(values = pal) +
               theme_genes() +
               theme(legend.position = "none",
                     axis.text.y = element_blank(),
                     axis.ticks.y = element_blank(),
                     axis.title.x = element_blank()) +
               ylab(" ") +
               scale_x_continuous(breaks = breaks) +
               coord_cartesian(xlim = c(xmin, xmax))
             
             # use patchwork, ggarrange messes up vertical alingments
             
             merged2 <- pc / geneplot +
               plot_layout(ncol=1, nrow = 2,
                           heights = c(4.5,0.5))
             
             fname <- paste(lab, id, paste0("buff",buff), paste0("v",version), "partial.pdf", sep = "_")
             # ggsave(filename = fname,
             #    plot = merged2,
             #    device = "png",
             #    dpi = 600,
             #    width = 6,
             #    height = 4,
             #    useDingbats = FALSE)
             
             pdf(fname, useDingbats = FALSE,
                 height = 4,
                 width = 6)
             
             print(merged2)
             
             dev.off()
           
           } else {
           
             message(paste0(id, " -- less than 2 features annotated in corresponding contig"))
             
           }

           
        })
  
   # create list of individual pdfs
   pdflist <- list.files(path = ".", pattern = paste(lab)) %>% .[grep(paste0("v",version, "_partial.pdf"),.)]
   splitlist <- split(seq_along(pdflist), ceiling(seq_along(pdflist)/splitnum))
   
   # save composite pdfs as files comprised of splitnum individual plots, for easy opening
   sapply(splitlist, function(pdfset) {
     
     firstn <- pdfset[1]
     lastn  <- pdfset[length(pdfset)]
     
     staple_pdf(input_files = pdflist[pdfset],
                output_filepath = file.path(".",
                                            paste(lab, "invertons",
                                                  paste0("buff",buff),
                                                  paste0(firstn ,"-", lastn),
                                                  paste0("v",version,".pdf"),
                                                  sep = "_")))
     
   })
   
   # remove individual pdfs
   do.call(file.remove, list(pdflist))
  
}

```

## apply plotting function
```{r}
# version and lab are incorporated into the filename
# split gives the number of files to merge into each pdf part
setwd("/workdir/users/acv46/stool_PROSeq2/figures/invertons/")
#plot_inv(invdat = US2_invdat, cov = US2_cov_pro_norm, buff = 300, gtf = US2_gtf, lab = "US2", version = "7", splitnum = 25)
plot_inv(invdat = US3_invdat, cov = US3_cov_pro_norm, buff = 300, gtf = US3_gtf, lab = "US3", version = "7", splitnum = 25)
```

## scratch plot
```{r}
require(ggplot2)
require(dplyr)
require(tidyr)
require(gggenes)
#require(ggpubr)
require(patchwork)
require(staplr)

test_invplot <- function(invdat, cov, buff, gtf, lab) {

  ids <- unique(invdat$ID)
  basepal <- c('#e41a1c','#377eb8','#4daf4a','#984ea3','#ff7f00','#ffff33')
  basepal2 <- c("#e0607e","#aec5eb","#f4d35e","#ee964b","#3ab795")
  
  # plot for each contig individually
  sapply(ids,
         function(id) {
           
           # create data to plot gene ranges as geom_rect
           
           pdat <- invdat %>% filter(ID == id)
           con <- pdat$contig
           csize <- id %>% sub(".*_length_","",.) %>% sub("_cov_.*","",.) %>% as.numeric()
           xmin <- pdat$rep1_start %>% as.numeric() - buff
           xmax <- pdat$rep2_stop %>% as.numeric() + buff
           
           if (xmin < 1) {
             xmin <- 1
           }
           
           if (xmax > csize) {
             xmax <- csize
           }
           
           cov_array <- cov %>% filter(contig == con & position %in% c(xmin:xmax))
           ymax <- max(abs(cov_array$value))
           
           breaks <- seq(xmin, xmax, by = round((xmax - xmin)/5, digits = 0))
           
           tri1 <- data.frame(x = as.numeric(c(pdat$rep1_start, pdat$rep1_stop, pdat$rep1_start)),
                              y = c(0.2 * ymax, 0, -0.2 * ymax),
                              stringsAsFactors = F)
           
           tri2 <- data.frame(x = as.numeric(c(pdat$rep2_stop, pdat$rep2_start, pdat$rep2_stop)),
                              y = c(0.2 * ymax, 0, -0.2 * ymax),
                              stringsAsFactors = F)
           
           arrow1 <- data.frame(x = as.numeric(pdat$rep1_stop),
                                xend = as.numeric(pdat$rep1_start),
                                y = -0.7 * ymax, type = "RNA-seq full")
           arrow2 <- data.frame(x = as.numeric(pdat$rep2_start),
                                xend = as.numeric(pdat$rep2_stop),
                                y = -0.7 * ymax, type = "RNA-seq full")
           
           # fails if contig does not have any annotated genes
           
           numgenes <- gtf %>% filter(contig == con) %>% nrow()
           
           if (numgenes > 1) {
           
             genes <- gtf[,c(1:3,5,7,12,13,15)] %>% filter(contig == con) %>%
             dplyr::mutate(., gene_start = ifelse(strand == "+", start, end)) %>% 
             dplyr::mutate(., gene_end = ifelse(strand == "+", end, start)) %>%
             dplyr::mutate(., index = paste0("gene",1:n()))
           
             pal <- rep_len(basepal2, nrow(genes))
           
             pc <- ggplot() +
               geom_line(data = cov[which(cov$contig == con),],
                         mapping = aes(x = factor(position), y = value),
                         color = "red") +
               facet_grid(type ~ .) + 
               geom_text(data = cov[which(cov$contig == con),],
                         mapping = aes(x = xmin + ((xmax - xmin) %/% 60),
                                       y = ymax * 0.8,
                                       label = type),
                         hjust = 0, size = 3,
                         check_overlap = TRUE) +
               coord_cartesian(xlim = c(xmin, xmax),
                               ylim = c(-ymax - (0.02 * ymax), ymax + (0.02 * ymax)),
                               clip = "on") +
               theme_bw() +
               geom_hline(yintercept = 0, color = "black") +
               ggtitle(paste0(lab, ", contig = ", id, "\n",
                              "bin = ", pdat$bin, ", ",
                              pdat$k_name_S, " (",pdat$k_name_S1,")")) +
               xlab("") +
               ylab("Normalized per-base read depth") +
               theme(strip.background = element_blank(),
                     strip.text.y = element_blank(),
                     panel.grid.major = element_blank(),
                     panel.grid.minor = element_blank(),
                     axis.text.x = element_blank(),
                     axis.ticks.x = element_blank(),
                     plot.title = element_text(size = 8),
                     plot.margin = unit(c(0,0,0,0), "cm")) +
               geom_polygon(data = tri1,
                            mapping = aes(x = x, y = y),
                            fill = "blue",
                            alpha = 0.4,
                            inherit.aes = F) +
               geom_polygon(data = tri2,
                            mapping = aes(x = x, y = y),
                            fill = "blue",
                            alpha = 0.4,
                            inherit.aes = F) + 
               geom_segment(data = arrow1,
                            mapping = aes(x = x, xend = xend, y = y, yend = y),
                            arrow = arrow(length=unit(0.25,"cm")),
                            show.legend = F) +
               geom_segment(data = arrow2,
                            mapping = aes(x = x, xend = xend, y = y, yend = y),
                            arrow = arrow(length=unit(0.25,"cm")),
                            show.legend = F) +
               geom_text(data = arrow1,
                            mapping = aes(x = xend - ((xmax - xmin) %/% 50),
                                          y = y),
                            label = pdat$Pe_R,
                            show.legend = F) +
               geom_text(data = arrow2,
                            mapping = aes(x = xend + ((xmax - xmin) %/% 50),
                                          y = y),
                            label = pdat$Pe_F,
                            show.legend = F)
             
             geneplot <- ggplot(genes,
                                aes(xmin = gene_start,
                                    xmax = gene_end,
                                    y = contig,
                                    fill = index,
                                    label = product)) +
               geom_gene_arrow(arrowhead_width = grid::unit(6, "mm"),
                               arrowhead_height = grid::unit(6, "mm"),
                               arrow_body_height = grid::unit(4, "mm")) +
               geom_gene_label() +
               facet_wrap(~ contig, scales = "free", ncol = 1) +
               scale_fill_manual(values = pal) +
               theme_genes() +
               theme(legend.position = "none",
                     axis.text.y = element_blank(),
                     axis.ticks.y = element_blank(),
                     axis.title.x = element_blank()) +
               ylab(" ") +
               scale_x_continuous(breaks = breaks) +
               coord_cartesian(xlim = c(xmin, xmax))
             
             # ggarrange does not properly align plot areas
             
             # merged1 <- ggarrange(pc, geneplot, ncol = 1, nrow = 2,
             #                    heights = c(4, 0.5),
             #                    align = "v")
             # print(merged1)
             
             # use patchwork instead
             
             merged2 <- pc / geneplot +
               plot_layout(ncol=1, nrow = 2,
                           heights = c(4.5,0.5))
             
             print(merged2)
           
           } else {
           
             message(paste0(id, " -- less than 2 features annotated in corresponding contig"))
             
           }
           
        }
    )
  
}


test_invplot(head(US2_invdat, 3),
             US2_cov_pro_norm,
             300,
             US2_gtf,
             "US2")
```

# log-log replicate plots
```{r}
require(ggplot2)
require(tidyr)
require(dplyr)
require(stats)
require(ggpubr)

# uses US2/US3_bins objects from RNA-seq vs PRO-seq correlations
  
loglog_p <- function(bindat, color) {

  #bindat[,c(1,12:14,18:27)]
  
  plotdat <- bindat[,c(19,20:22,24:27)] %>%
    # mutate_at(vars(-c(type,name,product)), funs((./sum(.) * 10^6) + 0.01))
    mutate_at(vars(-c(type,name,product,lengths)), funs(10^6 * (((.) / (lengths / 10^3)) / sum(.))))
  
  count_mat <- bindat[,c(24:27)] %>%
  as.matrix()
  
  spearman <- cor(count_mat, method = "spearman")
  pearson <- cor(count_mat, method = "pearson")
  
  pc <- ggplot(data = plotdat,
               mapping = aes(x = log10(PRO1), y = log10(PRO2))) +
    geom_point(size = 1,
               alpha = 0.5,
               color = color) +
    geom_label(x = 0.25, y = 4.5, size = 4, label.size = NA, 
               label = paste0("ρ = ", round(spearman["PRO1","PRO2"],3),
                              "\n", "r = ", round(pearson["PRO1","PRO2"],3)),
               hjust = 0) +
    theme_classic() +
    theme(axis.title = element_blank(),
          axis.text = element_text(size = 10)) +
    xlim(0,5) +
    ylim(0,5) +
    geom_abline(slope = 1, color = "black", intercept = 0)
  
  print(pc)

}

loglog_r <- function(bindat, color) {

  #bindat[,c(1,12:14,18:27)]
  
  plotdat <- bindat[,c(19,20:22,24:27)] %>%
    # mutate_at(vars(-c(type,name,product)), funs((./sum(.) * 10^6) + 0.01))
    mutate_at(vars(-c(type,name,product,lengths)), funs(10^6 * (((.) / (lengths / 10^3)) / sum(.))))
  
  count_mat <- bindat[,c(24:27)] %>%
  as.matrix()
  
  spearman <- cor(count_mat, method = "spearman")
  pearson <- cor(count_mat, method = "pearson")
  
  pc <- ggplot(data = plotdat,
               mapping = aes(x = log10(RNA1), y = log10(RNA2))) +
    geom_point(size = 1,
               alpha = 0.5,
               color = color) +
    geom_label(x = 0.25, y = 4.5, size = 4, label.size = NA, 
               label = paste0("ρ = ", round(spearman["RNA1","RNA2"],3),
                              "\n", "r = ", round(pearson["RNA1","RNA2"],3)),
               hjust = 0) +
    theme_classic() +
    theme(axis.title = element_blank(),
          axis.text = element_text(size = 10)) +
    xlim(0,5) +
    ylim(0,5) +
    geom_abline(slope = 1, color = "black", intercept = 0)
  
  print(pc)

}
#'#e41a1c','#377eb8','#4daf4a','#984ea3','#ff7f00','#ffff33'

#"#E69F00" - PC
#"#D55E00" - PH
#"#7acfff" - RC
#"#0072B2"- RH

p2 <- loglog_p(bindat = US2_bins,
       color = "#E69F00")
r2 <- loglog_r(bindat = US2_bins,
       color = "#7acfff")

p3 <- loglog_p(bindat = US3_bins,
       color = "#E69F00")
r3 <- loglog_r(bindat = US3_bins,
       color = "#7acfff")



```
```{r}
ggsave_pngpdf <- function(plot,name) {

  ggsave(filename = paste0(name, "_loglog_v3_600dpi.png"),
         plot = plot, width = 2, height = 2, dpi = 600)
  # ggsave(filename = paste0(name, "_loglog_v2_dingbats.pdf"),
  #        plot = plot, width = 2, height = 2, useDingbats = T)

}

setwd("/workdir/users/acv46/stool_PROSeq2/figures/correlation/")

ggsave_pngpdf(p2, "US2_PRO")
ggsave_pngpdf(r2, "US2_RNA")
ggsave_pngpdf(p3, "US3_PRO")
ggsave_pngpdf(r3, "US3_RNA")


```
# rRNA abundance plots 

## subset gtf from Inverton analysis
```{r}
get_rRNA <- function(gtf) {
  
  gtf %>% filter(type == "rRNA") %>%
    select(c("contig","width","strand","ID","product")) %>%
    mutate(partial = ifelse(grepl("partial", product), "yes", "no")) %>%
    mutate(product = gsub(pattern = " (partial)",
                          replacement = "",
                          product, fixed = TRUE))
  
  
}

US2_rRNA <- get_rRNA(US2_gtf)
US3_rRNA <- get_rRNA(US3_gtf)
```

## import GRiD data
```{r}
get_grid <- function(file) {
  
  require(readr)
  dat <- read_tsv(file = file, col_names = T) %>% select(c(1,2))
  colnames(dat) <- c("bin", "GRiD")
  dat
  
}

US2_grid <- get_grid("/workdir/users/acv46/stool_PROSeq2/deseq/grid/US2_5Nov2020_out/US2_5Nov2020.interleaved.GRiD.txt")
US3_grid <- get_grid("/workdir/users/acv46/stool_PROSeq2/deseq/grid/US3_3Nov2020_out/US3_3Nov2020.interleaved.GRiD.txt")
```

## import bins2reads data
```{r}
get_reads <- function(file) {
  
  require(readr)
  dat <- read_tsv(file = file, col_names = F) %>% select(c(2,4:7))
  colnames(dat) <- c("bin", "RNA1_all", "RNA2_all", "PRO1_all", "PRO2_all")
  dat %>% group_by(bin) %>% 
  summarise_all(sum)
  
}

US2_bins2reads <- get_reads("/workdir/users/acv46/stool_PROSeq2/deseq/grid/bins2reads/US2_5Nov2020_bin2reads.txt")
US3_bins2reads <- get_reads("/workdir/users/acv46/stool_PROSeq2/deseq/grid/bins2reads/US3_3Nov2020_bin2reads.txt")
```

## read in featurecounts files and filter for feature IDs in rRNA set
```{r}
gettsv <- function(file){
  
  # x is the file path
  
  dat <- read_tsv(file = file,
                  col_names = T,
                  comment = '#') %>%
    select(c(11,13:16))
  colnames(dat) <- c("ID", "PRO1", "PRO2", "RNA1", "RNA2")
  dat
  
}

US2_fcounts <- gettsv("/workdir/users/acv46/stool_PROSeq2/deseq/featureCounts/US2_allcontigs/US2_allcontigs_SENSE_q30.txt") %>%
  filter(ID %in% US2_rRNA$ID)
US3_fcounts <- gettsv("/workdir/users/acv46/stool_PROSeq2/deseq/featureCounts/US3_allcontigs/US3_allcontigs_SENSE_q30.txt") %>%
  filter(ID %in% US3_rRNA$ID)
```

## create tibble with all data (see Inverton section for data-generating code)
```{r}
merge_data <- function(rRNA, scaff2bin, abund, stats, gtdbtk, kraken, grid, fcounts, bin2reads) {
  
  # rRNA is rRNA data
  # scaff2bin is the file connecting scaffolds to bins
  # abund is the checkM relative abudance data
  # stats is checkM stats on Completeness and Contam
  # gtdbtk is the gtdbtk taxa data
  # kraken is the trimmed down Kraken2 output
  # grid is GRiD data
  # fcoutns is featurecounts data
  # bin2reads is the file giving reads per bin per library
  
  #colnames(subdat) <- dput(scan(text = "type contig start end strand lengths name product id PRO1 PRO2 RNA1 RNA2", what = ""))
  subdat <- rRNA %>% dplyr::inner_join(scaff2bin, ., by = "contig") %>%
    dplyr::inner_join(abund %>% select(bin, mbp, percent_binned, percent_community), ., by = "bin") %>%
    dplyr::inner_join(gtdbtk, ., by = "bin") %>%
    dplyr::inner_join(stats %>% select(bin, completeness, contamination), ., by = "bin") %>%
    dplyr::inner_join(kraken %>% select(bin, k_name_P, k_name_G, k_name_S, k_name_S1), ., by = "bin") %>%
    dplyr::inner_join(grid, ., by = "bin") %>%
    dplyr::inner_join(fcounts, ., by = "ID") %>%
    dplyr::inner_join(bin2reads, ., by = "bin")
  
  subdat
  
}

# apply merge_data
US2_rdat <- merge_data(US2_rRNA, US2_scaff2bin, US2_abund, US2_stats, US2_gtdbtk, US2_kraken, US2_grid, US2_fcounts, US2_bins2reads)
US3_rdat <- merge_data(US3_rRNA, US3_scaff2bin, US3_abund, US3_stats, US3_gtdbtk, US3_kraken, US3_grid, US3_fcounts, US3_bins2reads)
US2_rdat$sample <- "US2"
US3_rdat$sample <- "US3"

# subset for taxonomic levels
# pgs_names <- dput(scan(text = "ID PRO1 PRO2 RNA1 RNA2 bin GRiD k_name_P k_name_G k_name_S k_name_S1 k_percent_P k_percent_G k_percent_S k_percent_S1 completeness contamination g_phylum g_genus g_species mbp percent_binned percent_community contig width strand product partial", what = ""))
# US2_rdat <- US2_rdat[,pgs_names]
# US3_rdat <- US3_rdat[,pgs_names]
```

## NOT USED -- get coverage across rRNA genes
```{r}
get_coverage <- function(file, vector) {

  # file is the coverage file
  # vector is a vector of contigs for positive subsetting
  
  coverage <- read_delim(file = file,
                         delim = "\t",
                         col_names = T)
  
  # make sure column names are correct
  
  # flip RNA-seq plus and minus
  cols <- dput(scan(text = "contig position PRO_m_3 PRO_m_5 PRO_m_full PRO_p_3 PRO_p_5 PRO_p_full RNA_p_full RNA_m_full", what = ""))
  
  colnames(coverage) <- cols
  name <- dput(file) %>% str_replace("_.*", "")
  coverage_sub <- coverage[coverage$contig %in% vector,]
  coverage_sub <- coverage_sub %>% pivot_longer(cols = cols[-c(1:2)])
  coverage_sub$end <- coverage_sub$name %>% sub(".*_", "", .)
  coverage_sub$type <- coverage_sub$name %>% sub("_.*", "", .) %>% paste0(.,"-seq ",coverage_sub$end) %>% sub("3", "3' end", .) %>% sub("5", "5' end", .)
  coverage_sub <- coverage_sub %>% dplyr::mutate(., value = ifelse(grepl("_m_", name), value * -1, value))
  coverage_sub <- coverage_sub %>% dplyr::mutate(., strand = ifelse(grepl("_m_", name), "minus", "plus"))
  coverage_sub
  
  # facet grid by end and type, plot plus and minus on same plot
  
  
}

samps <- c("PRO_m_3","PRO_m_5","PRO_p_3","PRO_p_5","PRO_m_full","PRO_p_full","RNA_p_full","RNA_m_full")
minimal <- c("PRO_m_full","PRO_p_full","PRO_m_3","PRO_p_3","RNA_p_full","RNA_m_full")
pro <- c("PRO_m_full","PRO_p_full","PRO_m_3","PRO_p_3","PRO_m_5","PRO_p_5","RNA_p_full","RNA_m_full")

setwd("/workdir/users/acv46/stool_PROSeq2/deseq/bam/pileup")
US2_cov_all <- get_coverage("US2_coverage_q30_correct2.txt", unique(US2_rdat$contig))
US3_cov_all <- get_coverage("US3_coverage_q30_correct2.txt", unique(US3_rdat$contig))
# US2_cov_all_PRO <- US2_cov_all[grepl("PRO", US2_cov_all$name),] %>% arrange(desc(name))
# US3_cov_all_PRO <- US3_cov_all[grepl("PRO", US3_cov_all$name),] %>% arrange(desc(name))
US2_cov_set <- US2_cov_all[which(US2_cov_all$name %in% samps),]
US3_cov_set <- US3_cov_all[which(US3_cov_all$name %in% samps),]
# US2_cov_min <- US2_cov_all[which(US2_cov_all$name %in% minimal),]
# US3_cov_min <- US3_cov_all[which(US3_cov_all$name %in% minimal),]
# US2_cov_PRO <- US2_cov_all[which(US2_cov_all$name %in% pro),]
# US3_cov_PRO <- US3_cov_all[which(US3_cov_all$name %in% pro),]

# multiply RNA-seq reads by total PRO/RNA ratio
# ratio is simply total PRO-seq reads div by total RNA-seq reads

US2_ratio <- (120446779 + 89209651) / (23147082 + 19605905)
US3_ratio <- (125460161 + 117275362) / (21327596 + 21646500)
# US2_cov_min_norm <- US2_cov_min %>% dplyr::mutate(., value = ifelse(grepl("RNA_", name), value * US2_ratio, value))
# US3_cov_min_norm <- US3_cov_min %>% dplyr::mutate(., value = ifelse(grepl("RNA_", name), value * US3_ratio, value))
US2_cov_norm <- US2_cov_set %>% dplyr::mutate(., value = ifelse(grepl("RNA_", name), value * US2_ratio, value))
US3_cov_norm <- US3_cov_set %>% dplyr::mutate(., value = ifelse(grepl("RNA_", name), value * US3_ratio, value))

rm(US2_cov_all)
rm(US3_cov_all)
```


## plot rRNA relative abundance
```{r}
require(ggplot2)

# number of clean reads
# US2.procount <- (120446779 + 89209651) / 10^6
# US3.procount <- (125460161 + 117275362) / 10^6
# US2.procount <- (23147082 + 19605905) / 10^6
# US3.procount <- (21327596 + 21646500) / 10^6



plot_rRNA <- function(data) {
  
  # reads mapping to rRNA featute
  ## divided by width of feature in kbp
  ## divided by millions of reads mapping to bin
  
  ggplot(data = data) +
    geom_point(mapping = aes(x = GRiD,
                             y = ((PRO1 + PRO2) / (width / 10^3)) / ((PRO1_all + PRO2_all) / 10^6),
                             shape = sample,
                             color = product),
               size = 3) + 
    theme_classic() + 
    ylab("rRNA reads per kb of transcript \nper million reads mapped to bin")
  
}

plot_rRNA(rbind(US2_rdat, US3_rdat))
```




# Pause site motif enrichment
## install memes package -- make sure memes library is loaded first 
```{r}
# install memes package
# relies on local install of MEME suite

library(memes)
check_meme_install()

# options(meme_bin = "/home/acv46/meme/bin/")
# if (!requireNamespace("remotes", quietly=TRUE))
#   install.packages("remotes")
# 
# # To temporarily bypass the R version 4.1 requirement, you can pull from the following branch:
# remotes::install_github("snystrom/memes", ref = "no-r-4")
```

## read in all metadata, merge, and subset for bins with > 90% complete, < 5% contam
```{r}
library(tidyverse)

# scaffold to bin mapping
US2_scaff2bin <- read_tsv("/workdir/users/acv46/mgmAssembly/US2_5Nov2020_CAB/DASTool/US2_5Nov2020_redo_DASTool_scaffolds2bin.txt", col_names = F) %>%
  `colnames<-`(c("contig","bin")) %>% mutate(contig = gsub("_cov.*", "", contig))
US3_scaff2bin <- read_tsv("/workdir/users/acv46/mgmAssembly/US3_3Nov2020_CAB/DASTool/US3_3Nov2020_DASTool_scaffolds2bin.txt", col_names = F) %>%
  `colnames<-`(c("contig","bin")) %>% mutate(contig = gsub("_cov.*", "", contig))

# gtdbtk taxa
US2_gtdbtk <- read_tsv("/workdir/users/acv46/mgmAssembly/US2_5Nov2020_CAB/DASTool/gtdbtk/gtdbtk.bac120.summary.tsv", col_names = T)[,c(1,2)] %>%
  separate(., classification,
           into = c("g_kingdom","g_phylum","g_class","g_order","g_family","g_genus","g_species"),
           sep = ";", fill = "right", extra = "drop") %>%
  mutate_all(str_replace_all, ".*__", "")
US3_gtdbtk <- read_tsv("/workdir/users/acv46/mgmAssembly/US3_3Nov2020_CAB/DASTool/gtdbtk/gtdbtk.bac120.summary.tsv", col_names = T)[,c(1,2)] %>%
  separate(., classification,
           into = c("g_kingdom","g_phylum","g_class","g_order","g_family","g_genus","g_species"),
           sep = ";", fill = "right", extra = "drop") %>%
  mutate_all(str_replace_all, ".*__", "")
colnames(US2_gtdbtk)[1] <- "bin"
colnames(US3_gtdbtk)[1] <- "bin"

# checkM relative abundance
abund_cols <- dput(scan(text = "bin mbp mgm_reads percent_reads percent_binned percent_community", what = ""))
US2_abund <- read_tsv("/workdir/users/acv46/mgmAssembly/US2_5Nov2020_CAB/DASTool/checkM/US2_5Nov2020_checkM_abundance.txt", col_names = T)
US3_abund <- read_tsv("/workdir/users/acv46/mgmAssembly/US3_3Nov2020_CAB/DASTool/checkM/US3_3Nov2020_checkM_abundance.txt", col_names = T)
colnames(US2_abund) <- abund_cols
colnames(US3_abund) <- abund_cols

# checkM lineage, completeness, and contamination
stats_cols <- dput(scan(text = "bin marker_lineage uid num_genomes num_markers num_marker_sets 0 1 2 3 4 5+ completeness contamination strain_heterogeneity", what = ""))
US2_stats <- read_table2("/workdir/users/acv46/mgmAssembly/US2_5Nov2020_CAB/DASTool/checkM/US2_5Nov2020_checkM_lineage.txt", comment = "-", col_names = T)
US3_stats <- read_table2("/workdir/users/acv46/mgmAssembly/US3_3Nov2020_CAB/DASTool/checkM/US3_3Nov2020_checkM_lineage.txt", comment = "-", col_names = T)
colnames(US2_stats) <- stats_cols
colnames(US3_stats) <- stats_cols

# kraken taxa 
# merged with bash
## while read bin; do head -n 9 ${bin}.report.txt | sed "s/^/${bin}\t/g" >> merged_reports.txt; done < bins.txt
kraken_cols <- dput(scan(text = "bin k_percent k_clade_frags k_taxa_frags k_rank_code k_taxid k_name", what = ""))
US2_kraken <- read_tsv("/workdir/users/acv46/stool_PROSeq2/kraken2/US2_5Nov2020/merged_reports.txt", col_names = F)
US3_kraken <- read_tsv("/workdir/users/acv46/stool_PROSeq2/kraken2/US3_3Nov2020/merged_reports.txt", col_names = F)
colnames(US2_kraken) <- kraken_cols
colnames(US3_kraken) <- kraken_cols
US2_kraken <- US2_kraken %>%
  pivot_wider(., id_cols = c(bin),
              names_from = k_rank_code,
              values_from = c(k_name,k_percent)) %>%
  select(-c(k_name_R, k_percent_R)) %>%
  mutate_all(str_replace_all, ".*__", "") %>%
  mutate_all(str_replace_all, "\\.fa", "")
US3_kraken <- US3_kraken %>%
  pivot_wider(., id_cols = c(bin),
              names_from = k_rank_code,
              values_from = c(k_name,k_percent)) %>%
  select(-c(k_name_U, k_percent_U)) %>%
  mutate_all(str_replace_all, ".*__", "") %>%
  mutate_all(str_replace_all, "\\.fa", "")

merge_data <- function(scaff2bin, abund, stats, gtdbtk, kraken) {
  
  # scaff2bin is the file connecting scaffolds to bins
  # abund is the checkM relative abudance data
  # stats is checkM stats on Completeness and Contam
  # gtdbtk is the gtdbtk taxa data
  # kraken is the trimmed down Kraken2 output
  
  #colnames(subdat) <- dput(scan(text = "type contig start end strand lengths name product id PRO1 PRO2 RNA1 RNA2", what = ""))
  subdat <- scaff2bin %>%
    dplyr::inner_join(abund %>% select(bin, mbp, percent_binned, percent_community), ., by = "bin") %>%
    dplyr::inner_join(gtdbtk, ., by = "bin") %>%
    dplyr::inner_join(stats %>% select(bin, completeness, contamination), ., by = "bin") %>%
    dplyr::inner_join(kraken %>% select(bin, k_name_P, k_name_G, k_name_S, k_name_S1), ., by = "bin") %>%
    drop_na(k_name_S) %>%
    filter(completeness > 90) %>%
    filter(contamination < 5)
  
  subdat
  
}

# apply merge_data
US2_bindat <- merge_data(US2_scaff2bin, US2_abund, US2_stats, US2_gtdbtk, US2_kraken)
US3_bindat <- merge_data(US3_scaff2bin, US3_abund, US3_stats, US3_gtdbtk, US3_kraken)
US2_bindat$sample <- "US2"
US3_bindat$sample <- "US3"

# setwd("/workdir/users/acv46/stool_PROSeq2/peakcallR")
# write_csv(US2_bindat, "US2_bindat.csv")
# write_csv(US3_bindat, "US3_bindat.csv")
```

## read in 3' PRO-seq coverage data (read in file if saved)
```{r}
# do not create new object, read in file with code below

library(tidyverse)
get_coverage <- function(file, vector) {

  # file is the coverage file
  # vector is a vector of contigs for positive subsetting
  
  coverage <- read_delim(file = file,
                         delim = "\t",
                         col_names = T)
  
  # make sure column names are correct
  
  # flip RNA-seq plus and minus
  cols <- dput(scan(text = "contig position PRO_m_3 PRO_m_5 PRO_m_full PRO_p_3 PRO_p_5 PRO_p_full RNA_p_full RNA_m_full", what = ""))
  
  colnames(coverage) <- cols
  name <- dput(file) %>% str_replace("_.*", "")
  coverage_sub <- coverage[coverage$contig %in% vector,]
  coverage_sub <- coverage_sub %>% pivot_longer(cols = cols[-c(1:2)])
  coverage_sub$end <- coverage_sub$name %>% sub(".*_", "", .)
  coverage_sub$type <- coverage_sub$name %>% sub("_.*", "", .) %>% paste0(.,"-seq ",coverage_sub$end) %>% sub("3", "3' end", .) %>% sub("5", "5' end", .)
  coverage_sub <- coverage_sub %>% dplyr::mutate(., value = ifelse(grepl("_m_", name), value * -1, value))
  coverage_sub <- coverage_sub %>% dplyr::mutate(., strand = ifelse(grepl("_m_", name), "minus", "plus"))
  coverage_sub
  
  # facet grid by end and type, plot plus and minus on same plot
  
  
}

pro <- c("PRO_m_3","PRO_p_3","PRO_m_5","PRO_p_5")
alt <- c("PRO_m_3","PRO_p_3","RNA_p_full","RNA_m_full")

setwd("/workdir/users/acv46/stool_PROSeq2/deseq/bam/pileup")
US2_cov_pro <- get_coverage("US2_coverage_q30_correct2.txt", unique(US2_bindat$contig)) %>% 
  filter(name %in% pro) %>% 
  select(contig, position, value, end, strand)
write_csv(x = US2_cov_pro,
          file = "/workdir/users/acv46/stool_PROSeq2/figures/motifs/US2_cov_pro_90_5_reduced.csv",
          na = "NA",
          col_names = T)
US3_cov_pro <- get_coverage("US3_coverage_q30_correct2.txt", unique(US3_bindat$contig)) %>%
  filter(name %in% pro) %>% 
  select(contig, position, value, end, strand)
write_csv(x = US3_cov_pro,
          file = "/workdir/users/acv46/stool_PROSeq2/figures/motifs/US3_cov_pro_90_5_reduced.csv",
          na = "NA",
          col_names = T)

# READ IN EXISTING COVVERAGE FILES, check if gzipped
US2_cov_pro <- read_csv("/workdir/users/acv46/stool_PROSeq2/figures/motifs/US2_cov_pro_90_5_reduced.csv", col_names = T)
US3_cov_pro <- read_csv("/workdir/users/acv46/stool_PROSeq2/figures/motifs/US3_cov_pro_90_5_reduced.csv", col_names = T)
```

## read in fasta and subset for contigs in bin set
```{r}
get_fasta <- function(file, contigs) {
  
  require(Biostrings)
  fasta <- readDNAStringSet(filepath = file,
                            format = "fasta")
  
  fasta <- fasta[which(names(fasta) %in% contigs)]
  fasta
  
}

US2_fasta <- get_fasta("/workdir/users/acv46/stool_PROSeq2/deseq/prokka/US2_allcontigs/US2_allcontigs.fna",
                       unique(US2_cov_pro$contig))
US3_fasta <- get_fasta("/workdir/users/acv46/stool_PROSeq2/deseq/prokka/US3_allcontigs/US3_allcontigs.fna",
                       unique(US3_cov_pro$contig))
```

## identify pause sites, filter by score, pull sequences
```{r}
# To do
## fix bind_rows call to get both minus and plus strand results
## incorporate GTF data for genetic context annotation of pause sites
## parallelize apply calls
## rewrite to use single apply call over bin-contig pair instead of two apply calls, for better pbapply reporting

# from Sun 2021 -- "ends of all uniquely mapped RNA reads (bottom lane) were determined and the read count for each 3′ end position was calculated and plotted (top lane). The genomic positions where 3’ end/3’ end median (51-bp window) read counts ratio (pause score) was ≥ 20 and read counts/10^6 reads was ≥ 10 satisfied our stringent definition for a pause site."

# main function to process each contig in the chosen bin set
get_motifs <- function(covdat, bindat, seqdat, gtf, end, range, mincov, minpause, context, method) {
  
  # INPUTS
  ## covdat is coverage data
  ## bindat is all metadata
  ## seqdat is genomic ranges object containing all sequence data
  ## gtf is a gtf annotation file
  ## end is either 3 or 5
  ## range is the context around a position to use in pause score calculation
  ## mincov is the minimum raw coverage value at a position to determine whether a pause score should be calculated
  ## minpause is the the minimum Z score for a position to call it as significantly paused
  ## context is the number of bases surrounding a significant peak
  
  require(tidyverse)
  require(stats)
  require(Biostrings)
  require(pbapply)
  
  # helper function to get pause site z score
  pause_score <- function(row, full, range, con_len, method){
    
    pos <- row[2] %>% as.numeric()
  
    # this code works with both circular and linear sequences
    fullrange <- sort(c(
      c(((pos - 1) - c(1:range)) %% con_len + 1),
      c(((pos - 1) + c(1:range)) %% con_len + 1)
      ))
    
    if (method == "mean") {
    
      mean <- full %>%
        filter(position %in% fullrange) %>%
        select(value) %>% abs() %>% 
        unlist() %>% mean()
    
      std <- full %>%
        filter(position %in% fullrange) %>%
        select(value) %>% abs() %>% 
        unlist() %>% sd()
    
      # calculate z score for pause sites passing raw cov threshold
      zscore <- (abs(as.numeric(row[4])) - mean) / std
    
      list(zscore, as.numeric(row[2]))
    
    } else if (method == "mad") {
  
      mean <- full %>%
        filter(position %in% fullrange) %>%
        select(value) %>% abs() %>% 
        unlist() %>% mean()
    
      mad <- full %>%
        filter(position %in% fullrange) %>%
        select(value) %>% abs() %>% 
        unlist() %>% mad()
    
      # calculate z score for pause sites passing raw cov threshold
      zscore <- (abs(as.numeric(row[4])) - mean) / mad
    
      list(zscore, as.numeric(row[2]))
      
    }
      
  }
  
  # for each bin, apply function to constituent contigs
  pblapply(bindat %>% select(bin) %>% unique() %>% unlist(),
         function(i) {
           pblapply(bindat %>% filter(bin == i) %>% select(contig) %>% unlist(),
                  function(j) {
                    
                    message(paste0("\n","Procesing bin ", i, ", contig ", j))
                    
                    # subset coverage data by contig and sequence end type
                    con_cov <- covdat %>%
                      filter(contig == j & end == end)
                    
                    con_len <- max(con_cov$position) 
                    index <- c((range + 1):(con_len - range - 1))
                    
                    # create separate datasets for plus and minus positions
                    # filter for minimum absolute 
                    # plus_set <- con_cov %>%
                    #   filter(strand == "plus" & abs(value) >= mincov & position %in% index)
                    
                    minus_set <- con_cov %>%
                      filter(strand == "minus" & abs(value) >= mincov & position %in% index)
                    
                    cseq <- seqdat[j][[1]]
                    
                    # get strand-wise z scores for peaks passing raw coverage threshold
                    # eliminate peaks with overlapping ranges by only keeping larger peak
                    ## this is needed to prevent the same sequence from being pulled more than once
                    
                    # plus strand
                    if (nrow(plus_set) > 0) {

                      plus_z <- tibble(z = rep(NA, nrow(plus_set)),
                                       position = rep(NA, nrow(plus_set)))
                      hold <- apply(X = plus_set,
                                    MARGIN = 1,
                                    FUN = pause_score,
                                    full = con_cov %>% filter(strand == "plus"),
                                    range = range,
                                    con_len = con_len,
                                    method = method)

                      plus_z$z <- do.call(rbind, hold)[,1] %>% unlist()
                      plus_z$position <- do.call(rbind, hold)[,2] %>% unlist()
                      plus_z <- plus_z %>%
                        mutate(startrng = position - context) %>%
                        mutate(endrng = position + context) %>%
                        arrange(startrng) %>%
                        filter(z >= minpause)

                      message(paste0("\n","--> plus strand has ", nrow(plus_z), " hits over Z-score threshold"))

                      plus_z$grp <- 1
                      if (nrow(plus_z) > 1) {
                        for (k in 2:nrow(plus_z)) {

                          if (plus_z$endrng[k - 1] >= plus_z$startrng[k]) {

                            plus_z$grp[k] <- plus_z$grp[k - 1]

                          } else {

                            plus_z$grp[k] <- plus_z$grp[k - 1] + 1

                          }
                        }
                      }

                      message(paste0("\n","----> plus strand has ", nrow(plus_z), " hits remaining after overlap removal"))

                      if (nrow(plus_z) > 0) {
                        plus_z <- plus_z %>%
                          group_by(grp) %>%
                          top_n(1, z) %>%
                          ungroup() %>%
                          mutate(bin = i) %>%
                          mutate(contig = j) %>%
                          mutate(strand = "plus")
                          plus_z$sequence <- apply(X = plus_z, MARGIN = 1,
                                                   FUN = function(x) {
                                                     cseq[x[3]:x[4]] %>%
                                                       as.character()
                                                     }
                                                   )

                        plus_z

                      }

                    } %>% bind_rows()
                    
                    # minus strand
                    if (nrow(minus_set) > 0) {

                      minus_z <- tibble(z = rep(NA, nrow(minus_set)),
                                        position = rep(NA, nrow(minus_set)))
                      hold <- apply(X = minus_set,
                                    MARGIN = 1,
                                    FUN = pause_score,
                                    full = con_cov %>% filter(strand == "minus"),
                                    range = range,
                                    con_len = con_len,
                                    method = method)

                      minus_z$z <- do.call(rbind, hold)[,1] %>% unlist()
                      minus_z$position <- do.call(rbind, hold)[,2] %>% unlist()
                      minus_z <- minus_z %>%
                        mutate(startrng = position - context) %>%
                        mutate(endrng = position + context) %>%
                        arrange(startrng) %>%
                        filter(z >= minpause)

                      message(paste0("\n","--> minus strand has ", nrow(minus_z), " hits over Z-score threshold"))

                      minus_z$grp <- 1
                      if (nrow(minus_z) > 1) {
                        for (k in 2:nrow(minus_z)) {

                          if (minus_z$endrng[k - 1] >= minus_z$startrng[k]) {

                            minus_z$grp[k] <- minus_z$grp[k - 1]

                          } else {

                            minus_z$grp[k] <- minus_z$grp[k - 1] + 1

                          }
                        }
                      }

                      message(paste0("\n","----> minus strand has ", nrow(minus_z), " hits remaining after overlap removal"))

                      if (nrow(minus_z) > 0) {
                        minus_z <- minus_z %>%
                          group_by(grp) %>%
                          top_n(1, z) %>%
                          ungroup() %>%
                          mutate(bin = i) %>%
                          mutate(contig = j) %>%
                          mutate(strand = "minus")
                          minus_z$sequence <- apply(X = minus_z, MARGIN = 1,
                                                   FUN = function(x) {
                                                     cseq[x[3]:x[4]] %>%
                                                       reverseComplement() %>%
                                                       as.character()
                                                     }
                                                   )

                        minus_z

                      }

                    } %>% bind_rows()
                    
                }) %>% bind_rows()
       
        }) %>% bind_rows()
  
  
}

```

## run get_motifs
```{r}
# testset <- US2_bindat %>% 
#   filter(bin %in% c("10_sub","13_sub")) %>%
#   group_by(bin) %>% 
#   filter(row_number() <= 10) %>% ungroup()

US2_results <- get_motifs(covdat = US2_cov_pro,
                          bindat = US2_bindat,
                          seqdat = US2_fasta,
                          gtf = NULL,
                          end = 3,
                          range = 25,
                          mincov = 10,
                          minpause = 5,
                          context = 20,
                          method = "mad")
write_csv(x = US2_results,
          file = "motifs/US2_peaks3_25r_10c_5z_20s_minus_mad.csv",
          col_names = T)

US3_results <- get_motifs(covdat = US3_cov_pro,
                          bindat = US3_bindat,
                          seqdat = US3_fasta,
                          gtf = NULL,
                          end = 3,
                          range = 25,
                          mincov = 10,
                          minpause = 5,
                          context = 20,
                          method = "mad")
write_csv(x = US3_results,
          file = "motifs/US3_peaks3_25r_10c_5z_20s_minus_mad.csv",
          col_names = T)
```

## motif sequence logos
### read in peak sequence data
```{r}
require(tidyverse)

pull_seqs <- function(plus,minus) {
  
  pl <- read_csv(file = plus, col_names = T)
  mi <- read_csv(file = minus, col_names = T)
  dat <- bind_rows(pl, mi)
  dat
  
}

setwd("/workdir/users/acv46/stool_PROSeq2/figures/motifs")
US2_peaks <- pull_seqs("US2_peaks3_25r_10c_5z_20s_plus_mean_std.csv", "US2_peaks3_25r_10c_5z_20s_minus_mean_std.csv")
US3_peaks <- pull_seqs("US3_peaks3_25r_10c_5z_20s_plus_mean_std.csv", "US3_peaks3_25r_10c_5z_20s_minus_mean_std.csv")
```

### read in gtf data, all genes
```{r}
read_gtf <- function(file) {
  
  require(tidyverse)
  cnames <- c("seqname","source","feature","start","end","score","strand","frame","attribute")
  
  # read in raw gtf as tsv and remove comment rows
  messy <- read_tsv(file, col_names = F, comment = "#") %>%
    `colnames<-`(cnames)
  
  # get the unique attribute types
  # this assumes there are no spaces in the attribute names
  att_names <- messy %>%
    select(attribute) %>%
    apply(., MARGIN = 1, FUN = str_split, pattern = '"; ') %>%
    unlist() %>% trimws() %>% trimws(whitespace = ";") %>%
    sub(" .*$", "", .) %>% unique()
  
  att_names <- att_names[att_names != ""]
    
  # for each attribute type, create column
  # apply over gtf to fill in rows where attribute type is found
  for (att in att_names) {
    
    colatt <- apply(messy, MARGIN = 1, function(x) {

      var <- str_extract(string = x[9],
                         pattern = sprintf('";\\s+%1$s[^;]+|^%1$s[^;]+;[^"]+"', att)) %>% 
        trimws(whitespace = '["; ]+', which = 'left') %>% 
        str_extract('(?<=")[^"]+(?=")')
      
    })
    
    messy <- messy %>% add_column("{att}" := colatt)
    
  }
  
  # remove original attribute column
  messy %>% select(-c(attribute))
  
}

setwd("/workdir/users/acv46/stool_PROSeq2/deseq/prokka")
US2_gtf <- read_gtf("US2_allcontigs/US2_allcontigs_CUSTOM_FType.gtf")
US3_gtf <- read_gtf("US3_allcontigs/US3_allcontigs_CUSTOM_FType.gtf")
#test <- read_gtf("/workdir/users/acv46/EC_PROSeq/GCF_000011125.1_ASM1112v1_genomic.gtf")
```

### read in coverage data
```{r}
#library(tidyverse)
get_coverage <- function(file, vector) {

  # file is the coverage file
  # vector is a vector of contigs for positive subsetting
  
  coverage <- read_delim(file = file,
                         delim = "\t",
                         col_names = T)
  
  # make sure column names are correct
  
  # flip RNA-seq plus and minus
  cols <- dput(scan(text = "contig position PRO_m_3 PRO_m_5 PRO_m_full PRO_p_3 PRO_p_5 PRO_p_full RNA_p_full RNA_m_full", what = ""))
  
  colnames(coverage) <- cols
  name <- dput(file) %>% str_replace("_.*", "")
  coverage_sub <- coverage[coverage$contig %in% vector,]
  coverage_sub <- coverage_sub %>% pivot_longer(cols = cols[-c(1:2)])
  coverage_sub$end <- coverage_sub$name %>% sub(".*_", "", .)
  coverage_sub$type <- coverage_sub$name %>% sub("_.*", "", .) %>% paste0(.,"-seq ",coverage_sub$end) %>% sub("3", "3' end", .) %>% sub("5", "5' end", .)
  coverage_sub <- coverage_sub %>% dplyr::mutate(., value = ifelse(grepl("_m_", name), value * -1, value))
  coverage_sub <- coverage_sub %>% dplyr::mutate(., strand = ifelse(grepl("_m_", name), "minus", "plus"))
  coverage_sub
  
  # facet grid by end and type, plot plus and minus on same plot
  
  
}

pro <- c("PRO_m_3","PRO_p_3","PRO_m_5","PRO_p_5")
alt <- c("PRO_m_3","PRO_p_3","PRO_m_full","PRO_p_full","RNA_m_full","RNA_p_full")

setwd("/workdir/users/acv46/stool_PROSeq2/deseq/bam/pileup")
US2_cov <- get_coverage("US2_coverage_q30_correct2.txt", unique(US2_bindat$contig)) %>% 
  filter(name %in% alt)
US3_cov <- get_coverage("US3_coverage_q30_correct2.txt", unique(US3_bindat$contig)) %>%
  filter(name %in% alt)
```

### subset peaks by the feature types they overlap
```{r}
peaks2features <- function(pdat, objdat) {
  
  # load tidyverse
  
  nump <- nrow(pdat)
  
  pdat$obj_type <- NA
  pdat$obj_product <- NA
  pdat$obj_gene <- NA
  pdat$obj_posleft <- NA
  pdat$obj_posright <- NA
  pdat$obj_strand <- NA
  pdat$obj_id <- NA

  # loop through peaks
  for (i in 1:nump) {

    if (i %% 10 == 0) {
      
      message(paste0("processing peak ", i, " of ", nump))
    
    }
    
    objdat_sub <- filter(objdat, seqname == pdat$contig[i])
    numo <- nrow(objdat_sub)
    
    # loop through objects
    if (numo >= 1) {
    
      for (j in 1:numo) {
        
        # use %in% for discrete range search
        # use dplyr::between() for continuous ranges
  
        #message(paste0("--> range ", objdat_sub$start[j], " - ", objdat_sub$end[j]))
        
        if (is.na(pdat$obj_type[i]) &&
            pdat$position[i] %in% objdat_sub$start[j]:objdat_sub$end[j]) {
  
          pdat$obj_type[i]     <- objdat_sub$feature[j]
          pdat$obj_product[i]  <- objdat_sub$product[j]
          pdat$obj_gene[i]     <- objdat_sub$gene[j]
          pdat$obj_id[i]     <- objdat_sub$ID[j]
          pdat$obj_posleft[i] <- objdat_sub$start[j]
          pdat$obj_posright[i]  <- objdat_sub$end[j]
          pdat$obj_strand[i]   <- objdat_sub$strand[j]
  
        } else if (pdat$position[i] %in% objdat_sub$start[j]:objdat_sub$end[j]) {
  
          pdat$obj_type[i]     <- paste0(pdat$obj_type[i],     ", ", objdat_sub$feature[j])
          pdat$obj_product[i]  <- paste0(pdat$obj_product[i],  ", ", objdat_sub$product[j])
          pdat$obj_gene[i]     <- paste0(pdat$obj_gene[i],     ", ", objdat_sub$gene[j])
          pdat$obj_id[i]       <- paste0(pdat$obj_id[i],       ", ", objdat_sub$ID[j])
          pdat$obj_posleft[i]  <- paste0(pdat$obj_posleft[i],  ", ", objdat_sub$start[j])
          pdat$obj_posright[i] <- paste0(pdat$obj_posright[i], ", ", objdat_sub$end[j])
          pdat$obj_strand[i]   <- paste0(pdat$obj_strand[i],   ", ", objdat_sub$strand[j])
  
        }
      }
    }
  }

  pdat %>% mutate(strand = ifelse(strand == "plus", "+", "-"))

}

require(tidyverse)
setwd("/workdir/users/acv46/stool_PROSeq2/figures/motifs")
US2_peaks_features <- peaks2features(US2_peaks, US2_gtf)
write_tsv(US2_peaks_features, "US2_peaks2features_v3.tsv")
US3_peaks_features <- peaks2features(US3_peaks, US3_gtf)
write_tsv(US3_peaks_features, "US3_peaks2features_v3.tsv")
```

### function to plot ggseqlogos
```{r}
# pal1 <- c("#f3de2c","#e57a44","#4c2a85","#00cfc1","#d84797")
# pal2 <- c("#337ca0","#3ec300","#fffc31","#fe9000","#e13700")
# pal3 <- c("#e08dac","#6a7fdb","#ee7b30","#45cb85","#ede580")
# pal4 <- c("#ffc857","#56a3a6","#e9724c","#c5283d","#4e4187")

get_logos <- function(peaks, bindat, cov, lab, name){
  
  require(ggseqlogo)
  require(patchwork)
  require(tidyverse)
  require(staplr)
  
  # input is _seqs dataframe, CRISPR nameand strand
  
  binnames <- peaks %>% select(bin) %>%
    unique() %>% as_vector()
  
  sapply(binnames, function(xbin) {
    
    # pull data for plot title
    
    numcontigs <- bindat %>% filter(bin == xbin) %>%
      select(contig) %>% nrow()
    
    phy <- bindat %>% filter(bin == xbin) %>%
      select(k_name_P) %>% unique()
    
    k_species <- bindat %>% filter(bin == xbin) %>%
      select(k_name_S) %>% unique()
    
    g_species <- bindat %>% filter(bin == xbin) %>%
      select(g_species) %>% unique()
    
    complete <- bindat %>% filter(bin == xbin) %>%
      select(completeness) %>% unique()
    
    contam <- bindat %>% filter(bin == xbin) %>%
      select(contamination) %>% unique()
    
    sample <- bindat %>% filter(bin == xbin) %>%
      select(sample) %>% unique()
    
    numpeaks <- peaks %>% filter(bin == xbin) %>% nrow()
    
    # # pull full seqs to plot
    # 
    # fullseqs <- peaks %>% filter(bin == xbin) %>%
    #   select(sequence) %>% as_vector()
    
    # pull seqs and trim to -11 to +5 range
    
    trimseqs <- peaks %>% filter(bin == xbin) %>%
      select(sequence) %>% as_vector() %>%
      str_sub(start = 10, end = 25)
    
    
    # pick top 3 genes per bin to display peaks
    ## based on peaks per kb and average z score
    
    topgenes <- peaks %>% filter(bin == xbin) %>%
      group_by(obj_id) %>%
      mutate(obj_length = as.numeric(obj_posright) - as.numeric(obj_posleft)) %>%
      mutate(numpks = length(obj_id)) %>%
      mutate(pks_per_kb = numpks / (obj_length / 1000)) %>%
      mutate(obj_z_avg = mean(z)) %>%
      filter(numpks >= 3 & pks_per_kb >= 2) %>% ungroup() %>%
      filter(obj_product != "hypothetical protein") %>% 
      select(position, strand, obj_posleft, obj_posright, contig, obj_product, obj_gene, contig, bin, obj_id) %>%
      mutate_if(., is.character, str_replace_all, pattern = "%2C", replacement = ",") %>%
      mutate(obj_gene = gsub(pattern = "_.*", "", obj_gene))
    
    uniq_objs <- topgenes %>% select(obj_id) %>% unique()
    
    if (peakdat[7] == "forward") {
    
    tpeak <- data.frame(xend = as.numeric(peakdat[5]),
                        x = as.numeric(peakdat[5]),
                        yend = -1 * ymax * 0.1,
                        y = -1 * ymax * 0.3,
                        index = "PRO-seq_3",
                        stringsAsFactors = F)
    
    } else if (peakdat[7] == "reverse") {
    
    tpeak <- data.frame(xend = as.numeric(peakdat[5]),
                        x = as.numeric(peakdat[5]),
                        yend = ymax * 0.1,
                        y = ymax * 0.3,
                        index = "PRO-seq_3",
                        stringsAsFactors = F)
    
    }
    
    # motif bits  
    p1 <- ggseqlogo(trimseqs,
                    #col_scheme = cs1,
                    method = "bits") +
      theme(plot.margin = unit(c(0.1,0.1,0.1,0.1),"cm"),
            plot.title = element_text(size = 10),
            aspect.ratio = 1/5,
            axis.text.x = element_blank()) +
      ggtitle(paste0(sample, ", bin = ", xbin, "\n", 
                     numcontigs, " contigs, ", numpeaks, " pause sites passing cutoff\n",
                     "phylum = ", phy, "\n",
                     "kraken species annotation = ", k_species, "\n",
                     "gtdbtk species annotation = ", g_species, "\n",
                     complete, "% complete, ", contam, "% contaminated"))
    
    # motif probability
    p2 <- ggseqlogo(trimseqs,
                    #col_scheme = cs1,
                    method = "prob") +
      theme(plot.margin = unit(c(0.1,0.1,0.1,0.1),"cm"),
            plot.title = element_text(size = 10),
            aspect.ratio = 1/5)
    
    p2$scales$scales[[1]] <- scale_x_continuous(breaks = c(1:16),
                                                labels = c(seq(from = -11, to = -1), c(1:5)))
    
    # peak traces
    p3 <- ggplot() +
             geom_area(data = plotcov,
                       mapping = aes(x = position, y = norm, fill = strand)) +
    facet_grid(index ~ treatment) +
    scale_fill_manual(values = c("blue","red")) +
    # coord_cartesian(xlim = c(xmin, xmax),
    #                 ylim = c(-ymax - (0.02 * ymax), ymax + (0.02 * ymax))) +
    # geom_rect(data = tbox,
    #           mapping = aes(xmin = x1, xmax = x2,
    #                         ymin = y1, ymax = y2),
    #           fill = "yellow",
    #           alpha = 0.2) +
    geom_segment(data = tpeak,
                 mapping = aes(x = x, y = y, xend = xend, yend = yend),
                 size = 1,
                 arrow = arrow(length = unit(0.05, "npc")),
                 lineend = "butt", linejoin = "mitre", color = "black") +
    theme_classic() +
    ggtitle(paste0(name, ", terminator ", peakdat[3],
                   " - ", peakdat[4], ", ", peakdat[7])) +
    geom_hline(yintercept = 0, color = "black")
    
    mergep <- p1 / p2
    
    fname <- paste(lab, xbin, phy, "partial.pdf", sep = "_")
             
    pdf(fname, useDingbats = FALSE,
        height = 4,
        width = 6)
             
    print(mergep)
             
    dev.off()
    
    })
  
  # create list of individual pdfs
  pdflist <- list.files(path = ".", pattern = paste(lab)) %>% .[grep(paste0("_partial.pdf"),.)]
   
  # save composite pdfs as files comprised of splitnum individual plots, for easy opening
  
  staple_pdf(input_files = pdflist,
             output_filepath = file.path(".", name))
   
  # remove individual pdfs
  do.call(file.remove, list(pdflist))
  
}

```

### run get_logos
```{r}
# subset peakdat
## peaks in CDS
## not within 100 nt of feature ends
## same strand as feature

US2_peaksub <- US2_peaks_features %>% filter(obj_type == "CDS") %>%
  filter(position > as.numeric(obj_posleft) & position < as.numeric(obj_posright)) %>%
  filter(strand == obj_strand)
US3_peaksub <- US3_peaks_features %>% filter(obj_type == "CDS") %>%
  filter(position > as.numeric(obj_posleft) & position < as.numeric(obj_posright)) %>%
  filter(strand == obj_strand)

# code to make histograms of sequence space between pause sites
for (i in unlist(unique(US2_peaksub %>% select(bin)))) {US2_peaksub %>% filter(bin == i) %>% group_by(obj_id) %>% filter(n() > 3) %>% mutate(diff = position - lag(position)) %>% mutate(avg = mean(diff, na.rm = T)) %>% select(avg) %>% ungroup %>% unique() %>% select(avg) %>% unlist() %>% as.numeric() %>% hist(main = paste0("Hist of ",bin))}

setwd("/workdir/users/acv46/stool_PROSeq2/figures/motifs")
get_logos(US2_peaksub, US2_bindat, US2_cov_pro, "US2", "US2_motifs_z_mean_sd_v3_CDS100.pdf")
get_logos(US3_peaksub, US3_bindat, US3_cov_pro, "US3", "US3_motifs_z_mean_sd_v3_CDS100.pdf")
```




## meme motif finding
# tRNA abundance plot
## Read in data, merge sense and antisense tables
```{r}
readin <- function(file){

  name <- read.table(file = file,
                     sep = "\t",
                     header = T,
                     fill = F,
                     quote = "")
  
  colnames(name) <- c("type","contig","start","end","strand","length","name","product","gene","note","id","parent","pro1","pro2","rna1","rna2")
  
  name
  
}

setwd("/workdir/users/acv46/stool_PROSeq2/deseq/featureCounts")

US2_goodbins_sense <- readin(file = "US2_goodbins/US2_goodbins_SENSE_q30.txt")
US2_goodbins_antisense <- readin(file = "US2_goodbins/US2_goodbins_ANTISENSE_q30.txt")
US3_goodbins_sense <- readin(file = "US3_goodbins/US3_goodbins_SENSE_q30.txt")
US3_goodbins_antisense <- readin(file = "US3_goodbins/US3_goodbins_ANTISENSE_q30.txt")

US2_goodbins <- US2_goodbins_sense
US2_goodbins$pro1_as <- US2_goodbins_antisense$pro1
US2_goodbins$pro2_as <- US2_goodbins_antisense$pro2
US2_goodbins$rna1_as <- US2_goodbins_antisense$rna1
US2_goodbins$rna2_as <- US2_goodbins_antisense$rna2

US3_goodbins <- US3_goodbins_sense
US3_goodbins$pro1_as <- US3_goodbins_antisense$pro1
US3_goodbins$pro2_as <- US3_goodbins_antisense$pro2
US3_goodbins$rna1_as <- US3_goodbins_antisense$rna1
US3_goodbins$rna2_as <- US3_goodbins_antisense$rna2

rm(US2_goodbins_sense)
rm(US2_goodbins_antisense)
rm(US3_goodbins_sense)
rm(US3_goodbins_antisense)
```

### calculate proportion of reads mapped to tRNA loci
```{r}
setwd("/workdir/users/acv46/stool_PROSeq2/deseq/featureCounts/US2_goodbins")

US2_P1_mappedpercontig <- read_delim("US2_PRO1.primarymapped.txt", col_names = c("reads","contig"), trim_ws = T)
US2_P2_mappedpercontig <- read_delim("US2_PRO2.primarymapped.txt", col_names = c("reads","contig"), trim_ws = T)
US2_R1_mappedpercontig <- read_delim("US2_RNA1.primarymapped.txt", col_names = c("reads","contig"), trim_ws = T)
US2_R2_mappedpercontig <- read_delim("US2_RNA2.primarymapped.txt", col_names = c("reads","contig"), trim_ws = T)

prevo_bin2contig <- read_delim("US2_bin2contig.txt", col_names = c("bin","contig"))

# use US2_goodbins object from above and tRNA object from below
tRNA_prevo <- tRNA %>% filter(V17 %in% c("bin.75.fa","48_sub.fa","bin.161.fa")) %>% 
  select(V2, V17) %>% unique() %>% rename("bin" = "V17", "contig" = "V2") %>%
  mutate(bin = gsub(".fa","",bin))
US2_goodbins_tRNA_prevo <- US2_goodbins %>% filter(type == "tRNA") %>%
  filter(contig %in% tRNA_prevo$contig) %>%
  inner_join(., tRNA_prevo)

t_res <- tibble()
for (i in unique(US2_goodbins_tRNA_prevo$bin)) {
  
  clist <- prevo_bin2contig %>% filter(bin == i) %>% select(contig) %>% unique()
  message(length(clist))
  prot <- US2_goodbins_tRNA_prevo %>% filter(bin == i) %>% select(pro1, pro2) %>% sum()
  rnat <- US2_goodbins_tRNA_prevo %>% filter(bin == i) %>% select(rna1, rna2) %>% sum()
  proa <- rbind(US2_P1_mappedpercontig, US2_P2_mappedpercontig) %>%
    filter(contig %in% unlist(clist)) %>% select(reads) %>% sum()
  rnaa <- rbind(US2_R1_mappedpercontig, US2_R2_mappedpercontig) %>%
    filter(contig %in% unlist(clist)) %>% select(reads) %>% sum()
  
  prop <- (prot / proa) * 100
  rnap <- (rnat / rnaa) * 100
  
  t_res <- bind_rows(t_res, c(bin = i, p = prop, r = rnap))
  
}

message(paste(mean(as.numeric(t_res$p)),stats::sd(as.numeric(t_res$p)),sep = ","))
message(paste(mean(as.numeric(t_res$r)),stats::sd(as.numeric(t_res$r)),sep = ","))
```

###optional -- split by feature type
```{r}
# split up US2
for (type in unique(US2_goodbins_sense$type)) {
  
  tmpobj <- US2_goodbins_sense[which(US2_goodbins_sense$type == type),]
  tmpobj_as <- US2_goodbins_antisense[which(US2_goodbins_antisense$type == type),]
  tmpobj$pro1_as <- tmpobj_as$pro1
  tmpobj$pro2_as <- tmpobj_as$pro2
  tmpobj$rna1_as <- tmpobj_as$rna1
  tmpobj$rna2_as <- tmpobj_as$rna2
  
  assign(paste("US2_goodbins.", type, sep = ""), tmpobj)
  
  rm(tmpobj)
  rm(tmpobj_as)
  
}

# split up US3
for (type in unique(US3_goodbins_sense$type)) {
  
  tmpobj <- US3_goodbins_sense[which(US3_goodbins_sense$type == type),]
  tmpobj_as <- US3_goodbins_antisense[which(US3_goodbins_antisense$type == type),]
  tmpobj$pro1_as <- tmpobj_as$pro1
  tmpobj$pro2_as <- tmpobj_as$pro2
  tmpobj$rna1_as <- tmpobj_as$rna1
  tmpobj$rna2_as <- tmpobj_as$rna2
  
  assign(paste("US3_goodbins.", type, sep = ""), tmpobj)
  
  rm(tmpobj)
  rm(tmpobj_as)
  
}
```

## normalize counts by transcript length and total mapped reads (mean + stdev)
```{r}
# # old
# setwd("/workdir/users/acv46/stool_PROSeq2/deseq/featureCounts")
# mapped <- read.table("mappedcounts.txt")
# rownames(mapped) <- mapped[,1]
# mapped <- mapped[,-1]
# colnames(mapped) <- c("tot_reads","primary_mapped")

# new, q30 cutoff and merged replicates
require(tidyverse)
setwd("/workdir/users/acv46/stool_PROSeq2/deseq/bam/pileup")
mapped <- read.table("mappedcounts_merged_q30.txt")
colnames(mapped) <- c("library","reads")
mapped <- mapped %>% mutate(sample = gsub("_.*","",library)) %>% 
  mutate(libtype = gsub("_merge.*","",library) %>% gsub(".*_","",.)) %>%
  select(-library)

```

```{r}

# RPKM

US2_goodbins$pro_norm <- (US2_goodbins$pro1 + US2_goodbins$pro2) / ((US2_goodbins$length / 1000) * (mapped$reads[1] / 10^6)) 

US2_goodbins$rna_norm <- (US2_goodbins$rna1 + US2_goodbins$rna2) / ((US2_goodbins$length / 1000) * (mapped$reads[2] / 10^6)) 

US3_goodbins$pro_norm <- (US3_goodbins$pro1 + US3_goodbins$pro2) / ((US3_goodbins$length / 1000) * (mapped$reads[3] / 10^6)) 

US3_goodbins$rna_norm <- (US3_goodbins$rna1 + US3_goodbins$rna2) / ((US3_goodbins$length / 1000) * (mapped$reads[4] / 10^6)) 

```

## ggplot, tRNA RPKM
```{r}
require(dplyr)
require(ggplot2)
require(patchwork)

t2 <- US2_goodbins %>%
  filter(type == "tRNA") %>% select(contig,length,product,id,pro_norm,rna_norm) %>%
  rename("PRO-seq" = pro_norm, "RNAseq" = rna_norm) %>% 
  pivot_longer(cols = c("PRO-seq","RNAseq")) %>%
  ggplot(aes(x = name, y = log10(value), fill = name)) +
  geom_violin() +
  # geom_line(mapping = aes(group = id),
  #           position = position_dodge(0.2),
  #           alpha = 0.2) +
  geom_point(mapping = aes(group = id),
             color = "black",
             alpha = 0.5,
             size = 1, shape = 20,
             position = position_dodge(0.2)) +
  theme_classic() +
  theme(legend.position = "none",
        axis.title.y = element_text(size = 12),
        axis.title.x = element_blank(),
        axis.text.x = element_text(size = 12),
        axis.text.y = element_text(size = 10)) + 
  ylab("log10(RPKM)") +
  xlab("") +
  ggtitle(paste0("US2 tRNAs, n = ",
                 US2_goodbins %>% filter(type == "tRNA") %>% nrow()))

t3 <- US3_goodbins %>%
  filter(type == "tRNA") %>% select(contig,length,product,id,pro_norm,rna_norm) %>%
  rename("PRO-seq" = pro_norm, "RNAseq" = rna_norm) %>% 
  pivot_longer(cols = c("PRO-seq","RNAseq")) %>%
  ggplot(aes(x = name, y = log10(value), fill = name)) +
  geom_violin() +
  # geom_line(mapping = aes(group = id),
  #           position = position_dodge(0.2),
  #           alpha = 0.2) +
  geom_point(mapping = aes(group = id),
             color = "black",
             alpha = 0.5,
             size = 1, shape = 20,
             position = position_dodge(0.2)) +
  theme_classic() +
  theme(legend.position = "none",
        axis.title.y = element_text(size = 12),
        axis.title.x = element_blank(),
        axis.text.x = element_text(size = 9),
        axis.text.y = element_text(size = 10)) + 
  ylab("") +
  xlab("") +
  ggtitle(paste0("US3 tRNAs, n = ",
                 US3_goodbins %>% filter(type == "tRNA") %>% nrow()))

t_all <- t2 + t3

t_all

setwd("/workdir/users/acv46/stool_PROSeq2/figures/tRNA/")
ggsave(filename = "goodbins_all_tRNA_RPKM_v6.pdf", plot = t_all, device = "pdf",
       width = 4, height = 3, useDingbats = F, units = "in", dpi = 400)

```

## ggplot2, correlation comparison, colored by featuretype
```{r}
#library(ggplot2)
#library(dplyr)

# specify order of feature types to control plotting order
# specify colors for each feature type

type_order <- c("CDS","tRNA","tmRNA","rRNA","misc_RNA","repeat_region")
type_colors <- c("#000000","#e41a1c","#377eb8","#4daf4a","#984ea3","#ff7f00")

p2_goodbins <- ggplot(data = US2_goodbins %>% arrange(sapply(type, function(y) which(y == type_order)))) +
  geom_point(mapping = aes(x = log10(rna_norm), y = log10(pro_norm), color = type)) +
  #gghighlight(type == "repeat_region", use_direct_label = F, unhighlighted_colour = NULL) +
  geom_abline(slope = 1, intercept = 0, color = "red") +
  theme_classic() +
  scale_color_manual(values = type_colors) +
  ggtitle("US2, good bins, sense strand expression") +
  xlab("Log10(Normalized RNA-seq counts)") +
  ylab("Log10(Normalized PRO-seq counts)")

# p2a_goodbins <- ggplot(data = US2_goodbins %>% arrange(sapply(type, function(y) which(y == type_order)))) + 
#   geom_point(mapping = aes(x = log10(rna_as_norm), y = log10(pro_as_norm), color = type)) +
#   geom_abline(slope = 1, intercept = 0, color = "red") +
#   theme_classic() +
#   scale_color_manual(values = type_colors) +
#   ggtitle("US2, good bins, antisense strand expression") +
#   xlab("Log10(Normalized RNA-seq counts)") +
#   ylab("Log10(Normalized PRO-seq counts)")
 
p3_goodbins <- ggplot(data = US3_goodbins %>% arrange(sapply(type, function(y) which(y == type_order)))) +
  geom_point(mapping = aes(x = log10(rna_norm), y = log10(pro_norm), color = type)) +
  #gghighlight(type == "repeat_region", use_direct_label = F, unhighlighted_colour = NULL) +
  geom_abline(slope = 1, intercept = 0, color = "red") +
  theme_classic() +
  scale_color_manual(values = type_colors) +
  ggtitle("US3, good bins, sense strand expression") +
  xlab("Log10(Normalized RNA-seq counts)") +
  ylab("Log10(Normalized PRO-seq counts)")

# p3a_goodbins <- ggplot(data = US3_goodbins %>% arrange(sapply(type, function(y) which(y == type_order)))) + 
#   geom_point(mapping = aes(x = log10(rna_as_norm), y = log10(pro_as_norm), color = type)) +
#   geom_abline(slope = 1, intercept = 0, color = "red") +
#   theme_classic() +
#   scale_color_manual(values = type_colors) +
#   ggtitle("US3, good bins, antisense strand expression") +
#   xlab("Log10(Normalized RNA-seq counts)") +
#   ylab("Log10(Normalized PRO-seq counts)")

p2_goodbins
#p2a_goodbins
p3_goodbins
#p3a_goodbins
```

## tRNA bins, US2
```{r}
setwd("/workdir/users/acv46/stool_PROSeq2/deseq/featureCounts/US2_goodbins")
counts <- read.table("bin_contig_counts.txt", sep = "", header = F, na.strings = "", stringsAsFactors = NA, fill = NA)
counts[is.na(counts)] <- 0
tRNA <- read.table("US2_tRNA_SENSE_bins.txt")
```

## NOT DONE -- mnmE analysis
```{r}
# see /workdir/users/acv46/stool_PROSeq2/deseq/featureCounts/US2_goodbins/_README

mnmE_res <- c()
for (bin in unique(mnmE$V20)){
   
  pcounts <- (sum(counts[which(counts$V1 == bin),]$V3) + sum(counts[which(counts$V17 == bin),]$V4))
  rcounts <- (sum(counts[which(counts$V1 == bin),]$V5) + sum(counts[which(counts$V17 == bin),]$V6))
  
  psum_t_norm <- (sum(tRNA[which(tRNA$V17 == bin),]$V13) + sum(tRNA[which(tRNA$V17 == bin),]$V14)) / pcounts
  rsum_t_norm <- (sum(tRNA[which(tRNA$V17 == bin),]$V15) + sum(tRNA[which(tRNA$V17 == bin),]$V16)) / rcounts
  psum_m_norm <- (sum(mnmE[which(mnmE$V20 == bin),]$V16) + sum(mnmE[which(mnmE$V20 == bin),]$V17)) / pcounts
  rsum_m_norm <- (sum(mnmE[which(mnmE$V20 == bin),]$V18) + sum(mnmE[which(mnmE$V20 == bin),]$V19)) / rcounts
  
  
  
  mnmE_res <- rbind(mnmE_res,c(bin,psum_t_norm, rsum_t_norm, psum_m_norm, rsum_m_norm, pcounts, rcounts))
  
}  

colnames(mnmE_res) <- c("bin","tRNA_PRO","tRNA_RNA","mnmE_PRO","mnmE_RNA","PRO_counts_bintot","RNA_counts_bintot")
```

```{r}
mplot <- ggplot(data = as.data.frame(mnmE_res)) +
  geom_point(mapping = aes(x = as.numeric(tRNA_PRO),
                           y = as.numeric(mnmE_PRO)),
             color = "red",
             size = 2) +
  geom_point(mapping = aes(x = as.numeric(tRNA_RNA),
                           y = as.numeric(mnmE_RNA)),
             color = "black",
             size = 2) +
  theme_classic()
mplot
```

## subset tRNA dat by prevotella bins, US2
```{r}
# base R, not tidy

prevo <- c("bin.75.fa","48_sub.fa","bin.161.fa")
tRNA_prevo <- tRNA[which(tRNA$V17 %in% prevo),]
set <- c("V6","V8","V13","V14","V15","V16","V17","V2")
newnames <- c("length","tRNA","pro1","pro2","rna1","rna2","bin","contig")
tRNA_prevo <- tRNA_prevo[set]
colnames(tRNA_prevo) <- newnames
tRNA_prevo$aa <- substring(tRNA_prevo$tRNA,6,8)
tRNA_prevo$anticodon <- substring(tRNA_prevo$tRNA,10,12)

# RPKM = numReads / ( (geneLength/10^3) * (totalNumReads/10^6) )

tRNA_prevo$pro_norm <- (tRNA_prevo$pro1 + tRNA_prevo$pro2) / ((tRNA_prevo$length / 10^3) * ((sum(counts[which(counts$V1 == tRNA_prevo$bin),]$V3) + sum(counts[which(counts$V17 == tRNA_prevo$bin),]$V4)) / 10^6))
tRNA_prevo$rna_norm <- (tRNA_prevo$rna1 + tRNA_prevo$rna2) / ((tRNA_prevo$length / 10^3) * ((sum(counts[which(counts$V1 == tRNA_prevo$bin),]$V5) + sum(counts[which(counts$V17 == tRNA_prevo$bin),]$V6)) / 10^6))

require(dplyr)
# get bin to species mapping from US2_bin object generated in "RNA-seq vs PRO-seq correlations"
# manually add species column

tRNA_prevo <- pivot_longer(tRNA_prevo, cols = c(pro_norm, rna_norm), names_to = "library") %>%
  mutate(species = ifelse(bin == "48_sub.fa", "P. sp900313215", 
                          ifelse(bin == "bin.75.fa", "P. copri", 
                                 ifelse(bin == "bin.161.fa", "P. sp002265625", NA))))




```

## plot tRNA RPKM for different library types
```{r}
library(ggplot2)
library(scales)
library(ggbreak)
library(dplyr)

bar_tRNA_p <- ggplot(data = tRNA_prevo %>% filter(library == "pro_norm"),
                   mapping = aes(x = species, y = value, fill = aa, alpha = anticodon)) +
  geom_bar(position = "stack", stat = "identity", color = "black") +
  facet_grid(aa ~ ., switch = "y") + 
  scale_y_continuous(labels = scientific) +
  theme_classic() +
  coord_flip() +
  scale_y_break(c(35000, 110000)) +
  theme(strip.text.y.left = element_text(angle = 0),
        panel.background = element_rect(fill = NA, color = "black"),
        legend.position = "none",
        panel.spacing = unit(0, "lines")) + 
  xlab(label = "") + 
  ylab(label = "RPKM")

bar_tRNA_r <- ggplot(data = tRNA_prevo %>% filter(library == "rna_norm"),
                   mapping = aes(x = species, y = value, fill = aa, alpha = anticodon)) +
  geom_bar(position = "stack", stat = "identity", color = "black") +
  facet_grid(aa ~ ., switch = "y") + 
  scale_y_continuous(labels = scientific,
                     limits = c(0,2500)) +
  theme_classic() +
  coord_flip() +
  theme(strip.text.y.left = element_text(angle = 0),
        panel.background = element_rect(fill = NA, color = "black"),
        legend.position = "none",
        panel.spacing = unit(0, "lines")) + 
  xlab(label = "") + 
  ylab(label = "RPKM")

bar_tRNA_p
bar_tRNA_r
```
```{r}
save_tRNA <- function(plot, name, version, height, width) {
  
  
  ggsave(plot = plot,
         filename = paste0("US2_prevo_",name, "_tRNA_barplot_v", version, ".pdf"),
         device = "pdf",
         useDingbats = FALSE,
         dpi = 400,
         height = height,
         width = width,
         units = "in")
  
}

setwd("/workdir/users/acv46/stool_PROSeq2/figures/tRNA")

save_tRNA(bar_tRNA_p, "PRO", 2, 6, 6)
save_tRNA(bar_tRNA_r, "RNA", 2, 6, 4)
```

## visualize coverage across US2 long tRNA arrays (>= 3 tRNAs)
```{r}
tRNA_top_contigs <- tRNA %>% select(V2) %>% table() %>%
  sort() %>% enframe() %>% filter(value >= 4) 

# manually curate arrays to pick those where all tRNAsare on the same strand
sapply(tRNA_top_contigs$name, function(contig) { tRNA %>% filter(V2 == contig) %>% select(V5)})

tRNA_top_contigs <- filter(tRNA_top_contigs, name %in% c("NODE_484_length_24169","NODE_2567_length_6008",
                                                         "NODE_5666_length_2603","NODE_257_length_37526"))
```

### read in coverage data and subset for tRNA arrays: 3', 5', and full intervals for all libraries, q>=30
```{r}
###  full pileup file too big

get_coverage <- function(file, vector, samps, groupsums) {

  # file is the coverage file
  # vector is a vector of contigs for positive subsetting
  
  coverage <- read_delim(file = file,
                         delim = "\t",
                         col_names = T)
  
  # make sure column names are correct
  
  cols <- dput(scan(text = "contig position PRO_m_3 PRO_m_5 PRO_m_full PRO_p_3 PRO_p_5 PRO_p_full RNA_m_full RNA_p_full", what = ""))
  
  colnames(coverage) <- cols
  
  coverage_sub <- coverage %>%
    pivot_longer(cols = cols[-c(1:2)]) %>%
    filter(name %in% samps) %>%
    filter(contig %in% vector) %>%
    mutate(end = sub(".*_", "", name)) %>%
    mutate(type = sub("_.*", "", name) %>% paste0(.,"-seq")) %>%
    mutate(., value = ifelse(grepl("_m_", name), value * -1, value)) %>%
    # flip RNA-seq
    mutate(., value = ifelse(type == "RNA-seq", value * -1, value)) %>%
    mutate(strand = NA) %>%
    mutate(strand = ifelse(grepl("_m_", name), "minus", "plus")) %>%
    mutate(nlab = ifelse(end == "full", paste0(type), paste0(type, " ", end, "' end"))) %>%
    full_join(., groupsums) %>%
    mutate(normval = 10^9 * (value / gsum))
  
  coverage_sub
  
}

setwd("/workdir/users/acv46/stool_PROSeq2/deseq/bam/pileup")
samps <- c("PRO_m_3","PRO_m_5","PRO_p_3","PRO_p_5","PRO_m_full","PRO_p_full","RNA_m_full","RNA_p_full")
# get "tRNA_all_goodbins" object from "visualize coverage across tRNA arrays in all contigs (US2 + US3)" block below
US2_contigs_tRNA <- tRNA_all_goodbins %>% filter(samp == "US2") %>% select(contig) %>% unique %>% as_vector
US3_contigs_tRNA <- tRNA_all_goodbins %>% filter(samp == "US3") %>% select(contig) %>% unique %>% as_vector
# see /workdir/users/acv46/stool_PROSeq2/script/get_groupsums.sh
US2_groupsum <- read_delim("US2_groupsums.txt", col_names = c("type","end","gsum")) %>%
  filter(end == "full") %>% select(type,gsum)
US3_groupsum <- read_delim("US3_groupsums.txt", col_names = c("type","end","gsum")) %>%
  filter(end == "full") %>% select(type,gsum)

US2_cov_set <- get_coverage(file = "US2_coverage_q30_correct2.txt",
                            vector = US2_contigs_tRNA,
                            samps = samps,
                            groupsums = US2_groupsum)
US3_cov_set <- get_coverage(file = "US3_coverage_q30_correct2.txt",
                            vector = US3_contigs_tRNA,
                            samps = samps,
                            groupsums = US3_groupsum)

# US2_cov_all <- get_coverage("US2_coverage_q30_correct2.txt")
# #write_csv(US2_cov_all, file = "US2_coverage_q30_correct2_processed.txt")
# US2_cov_set <- US2_cov_all %>% filter(name %in% samps) %>%
#   filter(contig %in% US2_contigs_tRNA) %>%
#   mutate(nlab = ifelse(end == "full", paste0(type), paste0(type, " ", end, "' end")))
# rm(US2_cov_all)
# 
# US3_cov_all <- get_coverage("US3_coverage_q30_correct2.txt")
# #write_csv(US3_cov_all, file = "US3_coverage_q30_correct2_processed.txt")
# US3_cov_set <- US3_cov_all %>% filter(name %in% samps) %>%
#   filter(contig %in% US3_contigs_tRNA) %>%
#   mutate(nlab = ifelse(end == "full", paste0(type), paste0(type, " ", end, "' end")))
# rm(US3_cov_all)



```

### get groupsum values for normalization
```{r}
###  full pileup file too big

get_groupsum <- function(file) {

  # file is the coverage file
  # vector is a vector of contigs for positive subsetting
  
  coverage <- read_delim(file = file,
                         delim = "\t",
                         col_names = T)
  
  # make sure column names are correct
  
  cols <- dput(scan(text = "contig position PRO_m_3 PRO_m_5 PRO_m_full PRO_p_3 PRO_p_5 PRO_p_full RNA_m_full RNA_p_full", what = ""))
  
  colnames(coverage) <- cols
  name <- dput(file) %>% str_replace("_.*", "")
  coverage_sub <- coverage %>% pivot_longer(cols = cols[-c(1:2)])
  rm(coverage)
  coverage_sub$end <- coverage_sub$name %>% sub(".*_", "", .)
  coverage_sub$type <- coverage_sub$name %>% sub("_.*", "", .) %>% paste0(.,"-seq")
  coverage_sub <- coverage_sub %>% dplyr::mutate(., value = ifelse(grepl("_m_", name), value * -1, value))
  # flip RNA-seq
  coverage_sub <- coverage_sub %>% dplyr::mutate(., value = ifelse(type == "RNA-seq", value * -1, value))
  coverage_sub$strand <- NA
  coverage_sub <- coverage_sub %>% dplyr::mutate(., strand = ifelse(grepl("_m_", name), "minus", "plus"))
  #coverage_sub <- coverage_sub %>% filter(name %in% samps)
  grpsm <- coverage_sub %>% group_by(type,end) %>% mutate(groupsum = sum(abs(value))) %>% ungroup() %>%
    select(type,end,groupsum) %>% unique()
  
  grpsm
  
  # facet grid by end and type, plot plus and minus on same plot
  
  
}

setwd("/workdir/users/acv46/stool_PROSeq2/deseq/bam/pileup")
US2_groupsum <- get_groupsum("US2_coverage_q30_correct2.txt")
write_csv(US2_groupsum, file = "US2_groupsum_q30.txt")
US3_groupsum <- get_groupsum("US3_coverage_q30_correct2.txt")
write_csv(US3_groupsum, file = "US3_groupsum_q30.txt")
```

### plot tRNA arrays with coverage
```{r}
# plot coverage along array
# include geom_rect for repeats
# plot logo of repeat below trace

plot_tRNA <- function(contigs, tRNA_dat, cov, buffer, lab) {
  
  require(dplyr)

  # plot for each contig individually
  sapply(contigs,
         function(contig) {
           
           # create data to plot repeat ranges as geom_rect
           
           tdat <- tRNA_dat %>% filter(V2 == contig)
           contig_size <- cov %>% filter(contig == contig) %>% select(position) %>% max()
           xmin <- tRNA_dat %>% filter(V2 == contig) %>% select(V3) %>% min() %>% as.numeric() - buffer
           xmax <- tRNA_dat %>% filter(V2 == contig) %>% select(V4) %>% max() %>% as.numeric() + buffer
           strand <- ifelse(unique(tdat$V5) == "+", -1, 1)
           # xmin <- c(cas[which(cas$contig == contig),]$start,
           #           crispr[which(crispr$id == array),]$start) %>% min() %>% as.numeric() - buffer
           # xmax <- c(cas[which(cas$contig == contig),]$end,
           #           crispr[which(crispr$id == array),]$end) %>% max() %>% as.numeric() + buffer
           
           if (xmin < 1) {
             xmin <- 1
           }
           
           if (xmax > contig_size) {
             xmax <- contig_size
           }
           
           cov_array <- cov %>% filter(contig == contig) %>% filter(position <= xmax & position >= xmin)
           ymax <- max(abs(cov_array$value))
           
           breaks <- seq(xmin, xmax, by = round((xmax - xmin)/7, digits = 0))

           boxes <- data.frame(x1 = tdat$V3,
                               x2 = tdat$V4,
                               y1 = strand * ymax * 0.4,
                               y2 = strand * ymax * 0.2, 
                               stringsAsFactors = F)
           
           pc <- ggplot() +
             geom_line(data = cov %>% filter(contig == contig),
                       mapping = aes(x = factor(position), y = value, color = "red", group = 1)) +
             facet_grid(nlab ~ ., scales = "free_y") +
             scale_x_discrete(breaks = breaks) +
             coord_cartesian(xlim = c(xmin, xmax),
                             ylim = c(-ymax - (0.02 * ymax), ymax + (0.02 * ymax))) +
             geom_rect(data = boxes,
                       mapping = aes(xmin = x1, xmax = x2, ymin = y1, ymax = y2),
                       alpha = 0.5) +
             theme_classic() +
             ggtitle(paste("contig = ", contig))+
             geom_hline(yintercept = 0, color = "black")

             print(pc)

           
           # save each plot as a pdf
           # fname <- paste(lab, contig, "partial.pdf", sep = "_")
           # ggsave(filename = fname,
           #        plot = pc,
           #        device = cairo_pdf,
           #        dpi = 600,
           #        width = 6,
           #        height = 4)
           
         })
  
   # create ordered pdf list by number of RNA-seq reads
   # pdflist <- list.files(path = ".", pattern = paste(lab))
   # # combine pdfs into a single file
   # staple_pdf(input_files = pdflist,
   #            output_filepath = file.path(".",paste(lab, "crispr_merged.pdf", sep = "_")))
   # # remove individual pdfs
   # do.call(file.remove, list(pdflist))
  
}
```

### apply plotting function
```{r}
library(staplr)
setwd("/workdir/users/acv46/stool_PROSeq2/figures/crispr")
plot_tRNA(contigs = tRNA_top_contigs$name,
            tRNA_dat = tRNA,
            cov = US2_cov_set,
            buffer = 100,
            lab = "US2")

pc
```

## visualize coverage across tRNA arrays in all contigs (US2 + US3)
### read in all tRNA data
```{r}
get_tRNA <- function(file, sample) {
  
  read_tsv(file = file, col_names = T, comment = "#") %>%
    filter(Geneid == "tRNA") %>%
    select(Chr, Start, End, Strand, Length, product, c(13:16)) %>%
    mutate(samp = sample) %>%
    mutate(aa = product %>%
             str_remove("tRNA-") %>%
             sub(x = ., pattern = "\\(.*", replacement = "")) %>%
    mutate(anticodon = product %>%
             sub(x = ., pattern = "tRNA-.*\\(", replacement = "") %>%
             sub(x = ., pattern = "\\)", replacement = "")) %>%
    rename(PRO1 = 7,
           PRO2 = 8,
           RNA1 = 9,
           RNA2 = 10,
           contig = Chr)
  
}

US2_tRNA <- get_tRNA(file = "/workdir/users/acv46/stool_PROSeq2/deseq/featureCounts/US2_goodbins/US2_goodbins_SENSE_q30.txt",
                     sample = "US2") 
US3_tRNA <- get_tRNA(file = "/workdir/users/acv46/stool_PROSeq2/deseq/featureCounts/US3_goodbins/US3_goodbins_SENSE_q30.txt",
                     sample = "US3") 

tRNA_all_goodbins <- rbind(US2_tRNA, US3_tRNA)

# # select all contigs with a tRNA array of length >= 4, all on the same strand
# tRNA_all_goodbins %>% select(contig) %>% table() %>% sort() %>% enframe() %>%
#   filter(value >= 4) %>% select(name) %>%
#   apply(., 1, function(cont) {tRNA_all_goodbins %>% filter(contig == cont) %>%
#       select(Strand) %>% unique()})

# select all contigs where PRO-seq tRNA reads are >= 100
tRNA_all_goodbins <- tRNA_all_goodbins %>% group_by(contig) %>%
  filter(sum(PRO1 + PRO2) > 100) %>% ungroup() 
rm(US2_tRNA)
rm(US3_tRNA)
```

### subset tRNA arrays by length and strandedness (do not use when creating _cov_set objects)
```{r}
costrand_arrays <- tRNA_all_goodbins %>% select(contig) %>% table() %>%
  sort() %>% enframe() %>% filter(value >= 4) %>% select(name) %>%
  mutate(costrand = apply(., 1, function(cont) {tRNA_all_goodbins %>%
      filter(contig == cont) %>% select(Strand) %>%
      unique() %>% nrow()})) %>% filter(costrand == 1)

tRNA_all_goodbins <- tRNA_all_goodbins %>% filter(contig %in% costrand_arrays$name)
```

### plot tRNAs with coverage (per contig)
```{r}
# plot coverage along array
# include geom_rect for repeats
# plot logo of repeat below trace

plot_tRNA2 <- function(contigs, tRNA_dat, cov, buffer, lab, version) {
  
  require(dplyr)
  require(patchwork)

  # plot for each contig individually
  sapply(contigs,
         function(cont) {
           
           # create data to plot repeat ranges as geom_rect
           
           tdat <- tRNA_dat %>% filter(contig == cont)
           contig_size <- cov %>% filter(contig == cont) %>% select(position) %>% max()
           xmin <- tdat %>% select(Start) %>% min() %>% as.numeric() - buffer
           xmax <- tdat %>% select(End) %>% max() %>% as.numeric() + buffer
           message(paste(cont,contig_size, xmin, xmax, sep = ";"))
           lab <- unique(tdat$samp)
           
           if (xmin <= 1) {
             xmin <- 1
           }
           
           if (xmax >= contig_size) {
             xmax <- contig_size
           }
           
           cov_array <- cov %>% filter(contig == cont) %>% filter(position <= xmax & position >= xmin)
           ymax <- max(abs(cov_array$normval))
           
           breaks <- seq(xmin, xmax, by = round((xmax - xmin)/7, digits = 0))

           boxes <- data.frame(x1 = tdat$Start,
                               x2 = tdat$End,
                               y1 = tdat$Strand * ymax * 0.4,
                               y2 = tdat$Strand * ymax * 0.2,
                               label = paste0(tdat$aa, " (", tdat$anticodon,")"),
                               stringsAsFactors = F)
           
           pc <- ggplot() +
             geom_line(data = cov %>% filter(contig == cont),
                       mapping = aes(x = factor(position), y = normval, group = 1),
                       color = "red") +
             facet_grid(nlab ~ ., scales = "free_y") +
             scale_x_discrete(breaks = breaks) +
             coord_cartesian(xlim = c(xmin, xmax),
                             ylim = c(-ymax - (0.02 * ymax), ymax + (0.02 * ymax))) +
             geom_rect(data = boxes,
                       mapping = aes(xmin = x1, xmax = x2, ymin = y1, ymax = y2),
                       alpha = 0.5) +
             geom_text(data = boxes,
                       mapping = aes(x = x1, y = y1, label = label),
                       hjust = 0,
                       size = 2.5) +
             theme_classic() +
             geom_hline(yintercept = 0, color = "black")

           ymax_sub <- cov_array %>% filter(nlab == "PRO-seq 5' end") %>%
             select(normval) %>% abs() %>% max()
           
           boxes_sub <- data.frame(x1 = tdat$Start,
                               x2 = tdat$End,
                               y1 = -ymax_sub * 0.05,
                               y2 = ymax_sub * 0.05,
                               stringsAsFactors = F)
           
           
           
           pb <- ggplot() + 
             geom_rect(data = boxes_sub,
                       mapping = aes(xmin = x1, xmax = x2, ymin = y1, ymax = y2),
                       alpha = 0.5) +
             geom_line(data = cov %>% filter(nlab == "PRO-seq 5' end") %>% filter(contig == cont),
                       mapping = aes(x = factor(position), y = normval, group = 1),
                       color = "red") +
             scale_x_discrete(breaks = breaks) +
             coord_cartesian(xlim = c(xmin, xmax),
                             ylim = c(-ymax_sub - (0.02 * ymax_sub), ymax_sub + (0.02 * ymax_sub))) +
             theme_classic() +
             geom_hline(yintercept = 0, color = "black")
           
           pd <- (pc + pb) + 
             plot_annotation(title = paste0(lab,", contig = ", cont))

           print(pd)
             
             
           # save each plot as a pdf
           fname <- paste(lab, cont, "partial.pdf", sep = "_")
           ggsave(filename = fname,
                  plot = pd,
                  device = cairo_pdf,
                  dpi = 600,
                  width = 6,
                  height = 4)
           
         })
  
   # create ordered pdf list by number of RNA-seq reads
   pdflist <- list.files(path = ".", pattern = "partial.pdf")
   # combine pdfs into a single file
   staple_pdf(input_files = pdflist,
              output_filepath = file.path(".", paste(lab, "tRNA_merged", buffer, paste0("v",version,".pdf"), sep = "_")))
   # remove individual pdfs
   do.call(file.remove, list(pdflist))
  
}
```

### apply plotting function
```{r}
library(staplr)
setwd("/workdir/users/acv46/stool_PROSeq2/figures/tRNA")
plot_tRNA2(contigs = tRNA_all_goodbins %>% filter(samp == "US2") %>% select(contig) %>% unique() %>% as_vector(),
            tRNA_dat = tRNA_all_goodbins %>% filter(samp == "US2") %>% mutate(Strand = ifelse(Strand == "+", 1, -1)),
            cov = US2_cov_set,
            buffer = 100,
           lab = "US2",
           version = 3)
plot_tRNA2(contigs = tRNA_all_goodbins %>% filter(samp == "US3") %>% select(contig) %>% unique() %>% as_vector(),
            tRNA_dat = tRNA_all_goodbins %>% filter(samp == "US3") %>% mutate(Strand = ifelse(Strand == "+", 1, -1)),
            cov = US3_cov_set,
            buffer = 100,
           lab = "US3",
           version = 3)
```

### plot tRNAs with coverage (per individual tRNA)
```{r}
# plot coverage along array
# include geom_rect for repeats
# plot logo of repeat below trace

plot_tRNA4 <- function(tRNA_dat, cov, buffer, lab, version, bindat) {
  
  require(dplyr)
  require(patchwork)

  # plot for each contig individually
  apply(X = tRNA_dat,
        MARGIN = 1,
        FUN = function(tRNA) {
           
           # create data to plot repeat ranges as geom_rect
           
           cont <- tRNA[1]
           contig_size <- cov %>% filter(contig == cont) %>% select(position) %>% max()
           xmin <- as.numeric(tRNA[2]) - buffer
           xmax <- as.numeric(tRNA[3]) + buffer
           message(paste(cont,contig_size, xmin, xmax, sep = ";"))
           product <- tRNA[6]
           lab <- tRNA[11]
           species <- filter(bindat, contig == cont) %>% select(g_species) %>% unique()
           
           if (xmin <= 1) {
             xmin <- 1
           }
           
           if (xmax >= contig_size) {
             xmax <- contig_size
           }
           
           cov_array <- cov %>% filter(contig == cont) %>%
             filter(position <= xmax & position >= xmin)
           message(paste(nrow(cov_array)))
           ymax <- max(abs(cov_array$value))
           
           # set minimum plotting cutoff
           if (ymax >= 50) {
           
             b1 <- round(xmin,nchar(xmin - 4))
             b2 <- round(xmax,nchar(xmin - 4))
             
             breaks <- seq(from = b1, to = b2, by = (b2 - b1) / 4)
             breaks <- breaks[which(breaks >= xmin & breaks <= xmax)]
  
             # boxes <- data.frame(x1 = tRNA[2],
             #                     x2 = tRNA[3],
             #                     y1 = -1 * as.numeric(tRNA[4]) * ymax * 0.4,
             #                     y2 = -1 * as.numeric(tRNA[4]) * ymax * 0.2,
             #                     label = paste0(tRNA[12], " (", tRNA[13],")"),
             #                     stringsAsFactors = T)
             
             pc <- ggplot(data = cov_array,
                          mapping = aes(x = position, y = value)) +
               # geom_rect(data = boxes,
               #           mapping = aes(xmin = x1, xmax = x2, ymin = y1, ymax = y2),
               #           alpha = 0.5,
               #           fill = "black",
               #           inherit.aes = FALSE) +
               # geom_text(data = boxes,
               #           mapping = aes(x = x1, y = y1, label = label),
               #           hjust = 0,
               #           size = 2.5,
               #           inherit.aes = FALSE) +
               geom_path(color = "red") +
               facet_grid(nlab ~ .) +
               scale_x_continuous(breaks = breaks,
                                labels = sprintf("%.2f", (breaks / 1000))) +
               coord_cartesian(xlim = c(xmin, xmax),
                               ylim = c(-ymax - (0.05 * ymax), ymax + (0.05 * ymax))) +
               theme_classic() +
               geom_hline(yintercept = 0, color = "black") +
               geom_vline(xintercept = xmin + buffer, linetype = "dotted", color = "black") +
               geom_vline(xintercept = xmax - buffer, linetype = "dotted", color = "black")
               
               # annotate("rect",
               #          xmin = as.numeric(boxes$x1), xmax = as.numeric(boxes$x2),
               #          ymin = as.numeric(boxes$y1), ymax = as.numeric(boxes$y2),
               #          color = "gray", alpha = 0.4) +
               # annotate("text",
               #          x = as.numeric(boxes$x1),
               #          y = as.numeric(boxes$y1),
               #          label = boxes$label,
               #          size = 2.5,
               #          color = "black")
  
  
             ymax_sub <- cov_array %>% filter(nlab == "PRO-seq 5' end") %>%
               select(value) %>% abs() %>% max()
  
             # boxes_sub <- data.frame(x1 = tRNA[2],
             #                     x2 = tRNA[3],
             #                     y1 = -1 * ymax_sub * 0.05,
             #                     y2 = ymax_sub * 0.05,
             #                     stringsAsFactors = T)
  
             pb <- ggplot() +
               geom_path(data = cov_array %>% filter(nlab == "PRO-seq 5' end"),
                         mapping = aes(x = position, y = value),
                         color = "red") +
               # geom_rect(data = boxes_sub,
               #           mapping = aes(xmin = x1, xmax = x2, ymin = y1, ymax = y2),
               #           alpha = 0.5) +
               scale_x_continuous(breaks = breaks,
                                labels = sprintf("%.2f", (breaks / 1000))) +
               coord_cartesian(xlim = c(xmin, xmax),
                               ylim = c(-ymax_sub - (0.05 * ymax_sub), ymax_sub + (0.05 * ymax_sub))) +
               theme_classic() +
               geom_hline(yintercept = 0, color = "black") +
               geom_vline(xintercept = xmin + buffer, linetype = "dotted", color = "black") +
               geom_vline(xintercept = xmax - buffer, linetype = "dotted", color = "black")
  
             pd <- (pc + pb) +
               plot_annotation(title = paste0(lab,", ", species),
                               subtitle = paste0(product))
  
             print(pd)
               
               
             # save each plot as a pdf
             fname <- paste(lab, cont, "partial.pdf", sep = "_")
             ggsave(filename = fname,
                    plot = pd,
                    device = cairo_pdf,
                    dpi = 600,
                    width = 6,
                    height = 4)
             
           }

         })

   # create ordered pdf list by number of RNA-seq reads
   pdflist <- list.files(path = ".", pattern = "partial.pdf")
   # combine pdfs into a single file
   staple_pdf(input_files = pdflist,
              output_filepath = file.path(".", paste(lab, "tRNA_single_merged", buffer, paste0("v",version,".pdf"), sep = "_")))
   # remove individual pdfs
   do.call(file.remove, list(pdflist))
  
}
```

### apply plotting function
```{r}
library(staplr)
setwd("/workdir/users/acv46/stool_PROSeq2/figures/tRNA")
plot_tRNA4(tRNA_dat = tRNA_all_goodbins %>% filter(samp == "US2") %>% mutate(Strand = ifelse(Strand == "+", 1, -1)),
            cov = US2_cov_set %>% mutate(value = ifelse(type == "RNA-seq", -1 * value, value)),
            buffer = 30,
           lab = "US2",
           version = 8,
           bindat = US2_bins)
plot_tRNA4(tRNA_dat = tRNA_all_goodbins %>% filter(samp == "US3") %>% mutate(Strand = ifelse(Strand == "+", 1, -1)),
            cov = US3_cov_set %>% mutate(value = ifelse(type == "RNA-seq", -1 * value, value)),
            buffer = 30,
           lab = "US3",
           version = 8,
           bindat = US3_bins)
```

### single array plot, US3 NODE_478
```{r}
plot_tRNA3 <- function(contigs, tRNA_dat, cov, buffer) {
  
  require(dplyr)
  require(patchwork)

  cont <- "NODE_478_length_22989"
           
           # create data to plot repeat ranges as geom_rect
           
           tdat <- tRNA_dat %>% filter(contig == cont)
           contig_size <- cov %>% filter(contig == cont) %>% select(position) %>% max()
           xmin <- tdat %>% select(Start) %>% min() %>% as.numeric() - buffer
           xmax <- tdat %>% select(End) %>% max() %>% as.numeric() + buffer
           message(paste(contig_size, xmin, xmax, sep = ";"))
           strand <- ifelse(unique(tdat$Strand) == "+", -1, 1)
           lab <- unique(tdat$samp)
           
           if (xmin <= 1) {
             xmin <- 1
           }
           
           if (xmax >= contig_size) {
             xmax <- contig_size
           }
           
           cov_array <- cov %>% filter(contig == cont) %>% filter(position <= xmax & position >= xmin)
           ymax <- max(abs(cov_array$value))
           
           breaks <- seq(xmin, xmax, by = round((xmax - xmin)/7, digits = 0))

           boxes <- data.frame(x1 = tdat$Start,
                               x2 = tdat$End,
                               y1 = strand * ymax * 0.4,
                               y2 = strand * ymax * 0.2,
                               label = paste0(tdat$aa, " (", tdat$anticodon,")"),
                               stringsAsFactors = F)
           
           pc <- ggplot() +
             geom_line(data = cov %>% filter(contig == cont),
                       mapping = aes(x = factor(position), y = value, group = 1),
                       color = "red") +
             facet_grid(nlab ~ ., scales = "free_y") +
             scale_x_discrete(breaks = breaks) +
             coord_cartesian(xlim = c(xmin, xmax),
                             ylim = c(-ymax - (0.02 * ymax), ymax + (0.02 * ymax))) +
             geom_rect(data = boxes,
                       mapping = aes(xmin = x1, xmax = x2, ymin = y1, ymax = y2),
                       alpha = 0.5) +
             geom_text(data = boxes,
                       mapping = aes(x = x1, y = y1, label = label),
                       hjust = 0,
                       vjust = strand * -1.2,
                       size = 2.5) +
             theme_classic() +
             geom_hline(yintercept = 0, color = "black")

           ymax_sub <- cov_array %>% filter(nlab == "PRO-seq 5' end") %>%
             select(value) %>% abs() %>% max()
           
           boxes_sub <- data.frame(x1 = tdat$Start,
                               x2 = tdat$End,
                               y1 = -ymax_sub * 0.05,
                               y2 = ymax_sub * 0.05,
                               stringsAsFactors = F)
           
           cuts_end <- data.frame(xend = c(14023,14106,14186),
                                  x = c(14023,14106,14186),
                                  yend = -1 * ymax_sub*0.06,
                                  y = -1 * ymax_sub*0.16,
                                  stringsAsFactors = F)
           
           cuts_middle <- data.frame(xend = c(14060,14145,14222),
                                  x = c(14060,14145,14222),
                                  yend = -1 * ymax_sub*0.06,
                                  y = -1 * ymax_sub*0.16,
                                  stringsAsFactors = F)
           
           pb <- ggplot() + 
             geom_rect(data = boxes_sub,
                       mapping = aes(xmin = x1, xmax = x2, ymin = y1, ymax = y2),
                       alpha = 0.5) +
             geom_line(data = cov %>% filter(nlab == "PRO-seq 5' end") %>% filter(contig == cont),
                       mapping = aes(x = factor(position), y = value, group = 1),
                       color = "red") +
             scale_x_discrete(breaks = breaks) +
             coord_cartesian(xlim = c(xmin, xmax),
                             ylim = c(-ymax_sub - (0.02 * ymax_sub), ymax_sub + (0.02 * ymax_sub))) +
             theme_classic() +
             geom_hline(yintercept = 0, color = "black") +
             geom_segment(data = cuts_end,
                mapping = aes(x = x, y = y, xend = xend, yend = yend),
                size = 0.6,
                arrow = arrow(length = unit(0.02, "npc")),
                lineend = "butt", linejoin = "mitre", color = "orange") +
           geom_segment(data = cuts_middle,
                mapping = aes(x = x, y = y, xend = xend, yend = yend),
                size = 0.6,
                arrow = arrow(length = unit(0.02, "npc")),
                lineend = "butt", linejoin = "mitre", color = "blue")
             
           pd <- pc + pb

           print(pd)
             
             
           # save each plot as a pdf
           # fname <- paste(lab, contig, "partial.pdf", sep = "_")
           # ggsave(filename = fname,
           #        plot = pc,
           #        device = cairo_pdf,
           #        dpi = 600,
           #        width = 6,
           #        height = 4)
           
  
   # create ordered pdf list by number of RNA-seq reads
   # pdflist <- list.files(path = ".", pattern = paste(lab))
   # # combine pdfs into a single file
   # staple_pdf(input_files = pdflist,
   #            output_filepath = file.path(".",paste(lab, "crispr_merged.pdf", sep = "_")))
   # # remove individual pdfs
   # do.call(file.remove, list(pdflist))
  
}

pt <- plot_tRNA3(contigs = tRNA_all_goodbins %>% filter(contig == "NODE_478_length_22989") %>% select(contig) %>% unique() %>% as_vector(),
            tRNA_dat = tRNA_all_goodbins %>% filter(samp == "US3"),
            cov = US3_cov_set %>% mutate(value = ifelse(type == "RNA-seq", value * 20, value)) %>% filter(position %in% c(13900:14500)),
            buffer = 50)

pt

# ggsave(filename = "/workdir/users/acv46/stool_PROSeq2/figures/tRNA/US3_NODE_478_v1.pdf",
#        plot = pt, device = "pdf", useDingbats = FALSE, width = 6, height = 4,
#        dpi = 400, units = "in")

```

### single array plot, US2 NODE_5666
```{r}
plot_tRNA3 <- function(contigs, tRNA_dat, cov, buffer) {
  
  require(dplyr)
  require(patchwork)

  cont <- "NODE_5666_length_2603"
           
           # create data to plot repeat ranges as geom_rect
           
           tdat <- tRNA_dat %>% filter(contig == cont)
           contig_size <- cov %>% filter(contig == cont) %>% select(position) %>% max()
           xmin <- tdat %>% select(Start) %>% min() %>% as.numeric() - buffer
           xmax <- tdat %>% select(End) %>% max() %>% as.numeric() + buffer
           message(paste(contig_size, xmin, xmax, sep = ";"))
           strand <- ifelse(unique(tdat$Strand) == "+", -1, 1)
           lab <- unique(tdat$samp)
           
           if (xmin <= 1) {
             xmin <- 1
           }
           
           if (xmax >= contig_size) {
             xmax <- contig_size
           }
           
           cov_array <- cov %>% filter(contig == cont) %>% filter(position <= xmax & position >= xmin)
           ymax <- max(abs(cov_array$value))
           
           breaks <- seq(xmin, xmax, by = round((xmax - xmin)/7, digits = 0))

           boxes <- data.frame(x1 = tdat$Start,
                               x2 = tdat$End,
                               y1 = strand * ymax * 0.4,
                               y2 = strand * ymax * 0.2,
                               label = paste0(tdat$aa, " (", tdat$anticodon,")"),
                               stringsAsFactors = F)
           
           pc <- ggplot() +
             geom_line(data = cov %>% filter(contig == cont),
                       mapping = aes(x = factor(position), y = value, group = 1),
                       color = "red") +
             facet_grid(nlab ~ ., scales = "free_y") +
             scale_x_discrete(breaks = breaks) +
             coord_cartesian(xlim = c(xmin, xmax),
                             ylim = c(-ymax - (0.02 * ymax), ymax + (0.02 * ymax))) +
             geom_rect(data = boxes,
                       mapping = aes(xmin = x1, xmax = x2, ymin = y1, ymax = y2),
                       alpha = 0.5) +
             geom_text(data = boxes,
                       mapping = aes(x = x1, y = y1, label = label),
                       hjust = 0,
                       vjust = strand * -1.2,
                       size = 2.5) +
             theme_classic() +
             geom_hline(yintercept = 0, color = "black")

           ymax_sub <- cov_array %>% filter(nlab == "PRO-seq 5' end") %>%
             select(value) %>% abs() %>% max()
           
           boxes_sub <- data.frame(x1 = tdat$Start,
                               x2 = tdat$End,
                               y1 = -ymax_sub * 0.05,
                               y2 = ymax_sub * 0.05,
                               stringsAsFactors = F)
           
           cuts_end <- data.frame(xend = c(14023,14106,14186),
                                  x = c(14023,14106,14186),
                                  yend = -1 * ymax_sub*0.06,
                                  y = -1 * ymax_sub*0.16,
                                  stringsAsFactors = F)
           
           cuts_middle <- data.frame(xend = c(14060,14145,14222),
                                  x = c(14060,14145,14222),
                                  yend = -1 * ymax_sub*0.06,
                                  y = -1 * ymax_sub*0.16,
                                  stringsAsFactors = F)
           
           pb <- ggplot() + 
             geom_rect(data = boxes_sub,
                       mapping = aes(xmin = x1, xmax = x2, ymin = y1, ymax = y2),
                       alpha = 0.5) +
             geom_line(data = cov %>% filter(nlab == "PRO-seq 5' end") %>% filter(contig == cont),
                       mapping = aes(x = factor(position), y = value, group = 1),
                       color = "red") +
             scale_x_discrete(breaks = breaks) +
             coord_cartesian(xlim = c(xmin, xmax),
                             ylim = c(-ymax_sub - (0.02 * ymax_sub), ymax_sub + (0.02 * ymax_sub))) +
             theme_classic() +
             geom_hline(yintercept = 0, color = "black") +
             geom_segment(data = cuts_end,
                mapping = aes(x = x, y = y, xend = xend, yend = yend),
                size = 0.6,
                arrow = arrow(length = unit(0.02, "npc")),
                lineend = "butt", linejoin = "mitre", color = "orange") +
           geom_segment(data = cuts_middle,
                mapping = aes(x = x, y = y, xend = xend, yend = yend),
                size = 0.6,
                arrow = arrow(length = unit(0.02, "npc")),
                lineend = "butt", linejoin = "mitre", color = "blue")
             
           pd <- pc + pb

           print(pd)
             
             
           # save each plot as a pdf
           # fname <- paste(lab, contig, "partial.pdf", sep = "_")
           # ggsave(filename = fname,
           #        plot = pc,
           #        device = cairo_pdf,
           #        dpi = 600,
           #        width = 6,
           #        height = 4)
           
  
   # create ordered pdf list by number of RNA-seq reads
   # pdflist <- list.files(path = ".", pattern = paste(lab))
   # # combine pdfs into a single file
   # staple_pdf(input_files = pdflist,
   #            output_filepath = file.path(".",paste(lab, "crispr_merged.pdf", sep = "_")))
   # # remove individual pdfs
   # do.call(file.remove, list(pdflist))
  
}

pt <- plot_tRNA3(contigs = tRNA_all_goodbins %>% filter(contig == "NODE_5666_length_2603") %>% select(contig) %>% unique() %>% as_vector(),
            tRNA_dat = tRNA_all_goodbins %>% filter(samp == "US2"),
            cov = US2_cov_set %>% mutate(value = ifelse(type == "RNA-seq", value * 20, value)),
            buffer = 50)

pt

ggsave(filename = "/workdir/users/acv46/stool_PROSeq2/figures/tRNA/US2_NODE_5666_v1.pdf",
       plot = pt, device = "pdf", useDingbats = FALSE, width = 6, height = 4,
       dpi = 400, units = "in")

```

### show whole contig context
```{r}
plot_tRNA4 <- function(contigs, tRNA_dat, cov, buffer, genes, cont) {
  
  require(dplyr)
  require(gggenes)
  require(patchwork)
  
           # create data to plot repeat ranges as geom_rect
           
           tdat <- tRNA_dat %>% filter(contig == cont)
           contig_size <- cov %>% filter(contig == cont) %>% select(position) %>% max()
           # xmin <- tdat %>% select(Start) %>% min() %>% as.numeric() - buffer
           # xmax <- tdat %>% select(End) %>% max() %>% as.numeric() + buffer
           strand <- ifelse(unique(tdat$Strand) == "+", -1, 1)
           lab <- unique(tdat$samp)
           
           if (xmin <= 1) {
             xmin <- 1
           }
           
           if (xmax >= contig_size) {
             xmax <- contig_size
           }
           
           cov_array <- cov %>% filter(contig == cont) %>% filter(position <= xmax & position >= xmin)
           ymax <- max(abs(cov_array$value))
           
           breaks <- seq(1, contig_size, by = round((contig_size)/7, digits = 0))
           
           pc <- ggplot() +
             geom_line(data = cov %>% filter(contig == cont),
                       mapping = aes(x = factor(position), y = value, group = 1),
                       color = "red") +
             facet_grid(nlab ~ ., scales = "free_y") +
             theme_classic() +
             geom_hline(yintercept = 0, color = "black") +
             scale_x_discrete(breaks = breaks)
           
           pg <- genes %>% filter(Chr == cont) %>%
             mutate(orientation = ifelse(Strand == "+", 1, -1)) %>%
             ggplot(data = .,
                        mapping = aes(xmin = Start,
                         xmax = End,
                         y = Chr,
                         fill = ID,
                         label = gene,
                         forward = orientation)) +
             geom_gene_arrow(arrowhead_width = grid::unit(2, "mm"),
                    arrowhead_height = grid::unit(4, "mm"),
                    arrow_body_height = grid::unit(4, "mm")) +
              # geom_text(mapping = aes(x = start),
              #           angle = 0, hjust = 0, vjust = 2, size = 5) +
              #scale_fill_manual(values = pal) +
             scale_x_continuous(breaks = breaks) +
              theme_genes() +
              theme(legend.position = "none",
                    #axis.text.y = element_blank(),
                    #axis.ticks.y = element_blank(),
                    axis.title.x = element_blank(),
                    #axis.text.x = element_blank(),
                    #axis.ticks.x = element_blank(),
                    axis.title.y = element_blank(),
                    aspect.ratio = 1/5)
             

             ph <- pc / pg
             print(ph)
             
  
}

px <- plot_tRNA4(contigs = tRNA_all_goodbins %>% filter(contig == "NODE_478_length_22989") %>%
                   select(contig) %>% unique() %>% as_vector(),
                 tRNA_dat = tRNA_all_goodbins %>% filter(samp == "US3"),
                 cov = US3_cov_set %>% filter(end == "full"),
                 buffer = 0,
                 genes = US3_fcounts,
                 cont = "NODE_478_length_22989")
py <- plot_tRNA4(contigs = tRNA_all_goodbins %>% filter(contig == "NODE_5666_length_2603") %>%
                   select(contig) %>% unique() %>% as_vector(),
                 tRNA_dat = tRNA_all_goodbins %>% filter(samp == "US2"),
                 cov = US2_cov_set %>% filter(end == "full"),
                 buffer = 0,
                 genes = US2_fcounts,
                 cont = "NODE_5666_length_2603")
pz <- plot_tRNA4(contigs = tRNA_all_goodbins %>% filter(contig == "NODE_490_length_22536") %>%
                   select(contig) %>% unique() %>% as_vector(),
                 tRNA_dat = tRNA_all_goodbins %>% filter(samp == "US3"),
                 cov = US3_cov_set %>% filter(end == "full"),
                 buffer = 0,
                 genes = US3_fcounts,
                 cont = "NODE_490_length_22536")

px
py
pz

# ggsave(filename = "/workdir/users/acv46/stool_PROSeq2/figures/tRNA/US3_NODE_478_fullcontig_v1.pdf",
#        plot = pz, device = "pdf", useDingbats = FALSE, width = 6, height = 4,
#        dpi = 400, units = "in")
```


## correlation plot by feature type, all contigs -- defunct
### Read in data, merge sense and antisense tables
```{r}
readin <- function(file){

name <- read.table(file = file,
                   sep = "\t",
                   header = T,
                   fill = F,
                   quote = "")

colnames(name) <- c("type","contig","start","end","strand","length","name","product","gene","note","id","parent","pro1","pro2","rna1","rna2")

name
}

US2_allcontigs_sense <- readin(file = "featureCounts/US2_allcontigs/US2_allcontigs_SENSE.txt")
US2_allcontigs_antisense <- readin(file = "featureCounts/US2_allcontigs/US2_allcontigs_ANTISENSE.txt")
US3_allcontigs_sense <- readin(file = "featureCounts/US3_allcontigs/US3_allcontigs_SENSE.txt")
US3_allcontigs_antisense <- readin(file = "featureCounts/US3_allcontigs/US3_allcontigs_ANTISENSE.txt")

US2_allcontigs <- US2_allcontigs_sense
US2_allcontigs$pro1_as <- US2_allcontigs_antisense$pro1
US2_allcontigs$pro2_as <- US2_allcontigs_antisense$pro2
US2_allcontigs$rna1_as <- US2_allcontigs_antisense$rna1
US2_allcontigs$rna2_as <- US2_allcontigs_antisense$rna2

US3_allcontigs <- US3_allcontigs_sense
US3_allcontigs$pro1_as <- US3_allcontigs_antisense$pro1
US3_allcontigs$pro2_as <- US3_allcontigs_antisense$pro2
US3_allcontigs$rna1_as <- US3_allcontigs_antisense$rna1
US3_allcontigs$rna2_as <- US3_allcontigs_antisense$rna2

rm(US2_allcontigs_sense)
rm(US2_allcontigs_antisense)
rm(US3_allcontigs_sense)
rm(US3_allcontigs_antisense)
```

### optional -- split by feature type
```{r}
# split up US2
for (type in unique(US2_allcontigs_sense$type)) {
  
  tmpobj <- US2_allcontigs_sense[which(US2_allcontigs_sense$type == type),]
  tmpobj_as <- US2_allcontigs_antisense[which(US2_allcontigs_antisense$type == type),]
  tmpobj$pro1_as <- tmpobj_as$pro1
  tmpobj$pro2_as <- tmpobj_as$pro2
  tmpobj$rna1_as <- tmpobj_as$rna1
  tmpobj$rna2_as <- tmpobj_as$rna2
  
  assign(paste("US2_allcontigs.", type, sep = ""), tmpobj)
  
  rm(tmpobj)
  rm(tmpobj_as)
  
}

# split up US3
for (type in unique(US3_allcontigs_sense$type)) {
  
  tmpobj <- US3_allcontigs_sense[which(US3_allcontigs_sense$type == type),]
  tmpobj_as <- US3_allcontigs_antisense[which(US3_allcontigs_antisense$type == type),]
  tmpobj$pro1_as <- tmpobj_as$pro1
  tmpobj$pro2_as <- tmpobj_as$pro2
  tmpobj$rna1_as <- tmpobj_as$rna1
  tmpobj$rna2_as <- tmpobj_as$rna2
  
  assign(paste("US3_allcontigs.", type, sep = ""), tmpobj)
  
  rm(tmpobj)
  rm(tmpobj_as)
  
}
```

### normalize counts by transcript length and total mapped reads (mean + stdev)

```{r}

mapped <- read.table("featureCounts/mappedcounts.txt")
rownames(mapped) <- mapped[,1]
mapped <- mapped[,-1]
colnames(mapped) <- c("tot_reads","primary_mapped")

```
```{r}

# US2 counts per million primary mapped reads, normalized by feature length

US2_allcontigs$pro_norm <- (US2_allcontigs$pro1 + US2_allcontigs$pro2) / (US2_allcontigs$length * ((mapped["US2_PRO1.allcontigs.bam",2] + mapped["US2_PRO2.allcontigs.bam",2]) / 10^6)) 

US2_allcontigs$pro_as_norm <- (US2_allcontigs$pro1_as + US2_allcontigs$pro2_as) / (US2_allcontigs$length * ((mapped["US2_PRO1.allcontigs.bam",2] + mapped["US2_PRO2.allcontigs.bam",2]) / 10^6)) 

US2_allcontigs$rna_norm <- (US2_allcontigs$rna1 + US2_allcontigs$rna2) / (US2_allcontigs$length * ((mapped["US2_RNA1.allcontigs.bam",2] + mapped["US2_RNA2.allcontigs.bam",2]) / 10^6)) 

US2_allcontigs$rna_as_norm <- (US2_allcontigs$rna1_as + US2_allcontigs$rna2_as) / (US2_allcontigs$length * ((mapped["US2_RNA1.allcontigs.bam",2] + mapped["US2_RNA2.allcontigs.bam",2]) / 10^6))

# US3 counts per million primary mapped reads, normalized by feature length

US3_allcontigs$pro_norm <- (US3_allcontigs$pro1 + US3_allcontigs$pro2) / (US3_allcontigs$length * ((mapped["US3_PRO1.allcontigs.bam",2] + mapped["US3_PRO2.allcontigs.bam",2]) / 10^6)) 

US3_allcontigs$pro_as_norm <- (US3_allcontigs$pro1_as + US3_allcontigs$pro2_as) / (US3_allcontigs$length * ((mapped["US3_PRO1.allcontigs.bam",2] + mapped["US3_PRO2.allcontigs.bam",2]) / 10^6)) 

US3_allcontigs$rna_norm <- (US3_allcontigs$rna1 + US3_allcontigs$rna2) / (US3_allcontigs$length * ((mapped["US3_RNA1.allcontigs.bam",2] + mapped["US3_RNA2.allcontigs.bam",2]) / 10^6)) 

US3_allcontigs$rna_as_norm <- (US3_allcontigs$rna1_as + US3_allcontigs$rna2_as) / (US3_allcontigs$length * ((mapped["US3_RNA1.allcontigs.bam",2] + mapped["US3_RNA2.allcontigs.bam",2]) / 10^6))

```

### ggplot2

```{r}
#library(ggplot2)
#library(dplyr)

# specify order of feature types to control plotting order
# specify colors for each feature type

type_order <- c("CDS","tRNA","tmRNA","rRNA","misc_RNA","repeat_region")
type_colors <- c("#000000","#e41a1c","#377eb8","#4daf4a","#984ea3","#ff7f00")

p2_allcontigs <- ggplot(data = US2_allcontigs %>% arrange(sapply(type, function(y) which(y == type_order)))) + 
  geom_point(mapping = aes(x = log10(rna_norm), y = log10(pro_norm), color = type)) +
  # gghighlight(type == "repeat_region",
  #             use_direct_label = F,
  #             #label_key = ,
  #             unhighlighted_colour = NULL) +
  geom_abline(slope = 1, intercept = 0, color = "red") +
  theme_classic() +
  scale_color_manual(values = type_colors) +
  ggtitle("US2, all contigs, sense strand expression") +
  xlab("Log10(Normalized RNA-seq counts)") +
  ylab("Log10(Normalized PRO-seq counts)")

# p2a_allcontigs <- ggplot(data = US2_allcontigs %>% arrange(sapply(type, function(y) which(y == type_order)))) + 
#   geom_point(mapping = aes(x = log10(rna_as_norm), y = log10(pro_as_norm), color = type)) +
#   geom_abline(slope = 1, intercept = 0, color = "red") +
#   theme_classic() +
#   scale_color_manual(values = type_colors) +
#   ggtitle("US2, all contigs, antisense strand expression") +
#   xlab("Log10(Normalized RNA-seq counts)") +
#   ylab("Log10(Normalized PRO-seq counts)")

p3_allcontigs <- ggplot(data = US3_allcontigs %>% arrange(sapply(type, function(y) which(y == type_order)))) + 
  geom_point(mapping = aes(x = log10(rna_norm), y = log10(pro_norm), color = type)) +
  # gghighlight(type == "repeat_region",
  #             use_direct_label = F,
  #             unhighlighted_colour = NULL) +
  geom_abline(slope = 1, intercept = 0, color = "red") +
  theme_classic() +
  scale_color_manual(values = type_colors) +
  ggtitle("US3, all contigs, sense strand expression") +
  xlab("Log10(Normalized RNA-seq counts)") +
  ylab("Log10(Normalized PRO-seq counts)")

# p3a_allcontigs <- ggplot(data = US3_allcontigs %>% arrange(sapply(type, function(y) which(y == type_order)))) + 
#   geom_point(mapping = aes(x = log10(rna_as_norm), y = log10(pro_as_norm), color = type)) +
#   geom_abline(slope = 1, intercept = 0, color = "red") +
#   theme_classic() +
#   scale_color_manual(values = type_colors) +
#   ggtitle("US3, all contigs, antisense strand expression") +
#   xlab("Log10(Normalized RNA-seq counts)") +
#   ylab("Log10(Normalized PRO-seq counts)")

p2_allcontigs
#p2a_allcontigs
p3_allcontigs
#p3a_allcontigs
```
# scratch
```{r}
library(datasets)
library(ggplot2)
library(dplyr)

iris_edit <- iris %>% group_by(Species) %>%
  mutate(paired = seq(1:length(Species))) %>%
  filter(Species %in% c("setosa","versicolor"))

ggplot(data = iris_edit,
       mapping = aes(x = Species, y = Sepal.Length, fill = Species)) +
  geom_violin() +
  geom_line(mapping = aes(group = paired),
            position = position_dodge(0.1),
            alpha = 0.3) +
  geom_point(mapping = aes(fill = Species, group = paired),
             size = 1.5, shape = 21,
             position = position_dodge(0.1)) +
  theme_classic() +
  theme(legend.position = "none",
        axis.text.x = element_text(size = 15),
        axis.title.y = element_text(size = 15),
        axis.title.x = element_blank(),
        axis.text.y = element_text(size = 10))

library(see)

ggplot(data = iris_edit,
       mapping = aes(x = Species, y = Sepal.Length, fill = Species)) +
  geom_violindot(dots_size = 0.8,
                 position_dots = position_dodge(0.1),
                 flip = c(1)) +
  geom_line(mapping = aes(group = paired),
            alpha = 0.3,
            position = position_dodge(0.1)) +
  theme_classic() +
  theme(legend.position = "none",
        axis.text.x = element_text(size = 15),
        axis.title.y = element_text(size = 15),
        axis.title.x = element_blank(),
        axis.text.y = element_text(size = 10))
```

