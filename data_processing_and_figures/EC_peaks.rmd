---
title: "EC_peaks"
author: "Albert Vill"
date: "1/25/2022"
output: html_document
---

# Homer autocorrelation plots
```{r}

autocorr <- function(autocorr_dat){

  #library(tidyverse)

  tags <- read.table(autocorr_dat, sep = "\t", header = T)
  colnames(tags) <- c("distance","same","opposite")

  tags <- tags %>%
    select(distance, same, opposite) %>%
    gather(key = "variable", value = "value", -distance)

  ggplot(tags, aes(x = distance, y = value)) + 
    geom_line(aes(color = variable)) + 
    scale_color_manual(values = c("darkred", "steelblue")) +
    theme_classic()

}
```
```{r}
setwd("/workdir/users/acv46/EC_PROSeq/homer")

autocorr("RCD2/tagdir/tagAutocorrelation.txt")

```

# Promoter proximal coverage

## (defunct, use code below) retrieve regulonDB and create GRanges objects 
```{r}
require(regutools)
## Build a regulondb object
## stores database at /home/acv46/.cache/AnnotationHub
e_coli_regulondb_10.9 <- regulondb(database_conn = connect_database(),
                              organism = "E.coli",
                              database_version = "10.9",
                              genome_version = "NC_000913.3")

#list_datasets(e_coli_regulondb)
#list_attributes(e_coli_regulondb, dataset = "PROMOTER")

## datasets

promoters <- get_dataset(e_coli_regulondb_10.9, 
            dataset = "PROMOTER",
            attributes = c("id","name","strand","tss","sigma_factor","regulated_operon")) %>%
  as_tibble(.)

promoters_sub <- promoters[-grep(",",promoters$sigma_factor),]
promoters_sub$sigma_factor[is.na(promoters_sub$sigma_factor)] <- "unknown"

ops <- get_dataset(e_coli_regulondb_10.9, 
            dataset = "OPERON",
            attributes = c("id","name","total_sigma","sigma_name")) %>%
  as_tibble(.)

ops_sub <- ops[ops$total_sigma == 1,]

```

## (defunct, use code below) subset promoter regulondb dataset to get promoter closes to beginning of operon
```{r}
library(purrr)

closest <- function(op_name, pro_list){
  
  set <- pro_list[which(pro_list$regulated_operon == op_name),]
  str <- set$strand %>% unique()
  
  if (str == "forward") {
    
    yeet <- set[which(set$tss == max(set$tss)),]
    
  } else if (str == "reverse") {
    
    yeet <- set[which(set$tss == min(set$tss)),]
    
  }
  
  yeet
  
}

unique_ops <- unique(promoters_sub$regulated_operon) %>% na.omit()
closest_promoters <- lapply(unique_ops, closest, pro_list = promoters_sub) %>% purrr::reduce(full_join)
```

## (use this) get set of operons controlled by single promoters of a single type
```{r}
require(regutools)
## Build a regulondb object
## stores database at /home/acv46/.cache/AnnotationHub
e_coli_regulondb_10.9 <- regulondb(database_conn = connect_database(),
                              organism = "E.coli",
                              database_version = "10.9",
                              genome_version = "NC_000913.3")

# get vector of promoters
promset <- get_dataset(e_coli_regulondb_10.9, 
            dataset = "OPERON") %>% as_tibble() %>%
  filter(total_promoter == 1 & total_sigma == 1) %>%
  select(promoter_name) %>% as_vector()

promoters <- get_dataset(e_coli_regulondb_10.9, 
                         dataset = "PROMOTER",
                         attributes = c("id","name","strand","tss","sigma_factor","regulated_operon")) %>%
  as_tibble() %>% filter(name %in% promset) %>%
  na.omit() %>% mutate(count = c(1:n()))
```

## manually curated promoter data -- superseded by regulonDB object
```{r}
setwd("/workdir/users/acv46/EC_PROSeq/")

# # regulonDB promoter data
# # promoters subset to include only the closest promoter to each unique operon
promoters_old <- read_delim(file = "index/U00096.3/regulonDB/closest_promoters.txt",
                        delim = "\t",
                        col_names = c("EC_ID","tss","strand","position","sigma","operon_ID"))

## relabel "NA" as "unknown" for sigma
promoters_old$sigma <- replace_na(promoters_old$sigma, "unknown")

## remove rows where strand or position are NA
promoters_old <- promoters_old %>% drop_na()
```

## read in and clean up counts data (iter2)
```{r}
#library(tidyverse)

setwd("/workdir/users/acv46/EC_PROSeq/")

# PRO-seq and RNA-seq coverage data
# use interation 2, see readme in file directory
coverage <- read_delim(file = "pileup/iter2/all_coverage.txt",
                       delim = "\t")

## normalize to rpm and subset for manageability
# size of window over which coverage is calculated
window <- 250

coverage$PCm_norm <- coverage$PC_minus / (sum(coverage$PC_minus + coverage$PC_plus) / 10^6)
coverage$PCp_norm <- coverage$PC_plus / sum(coverage$PC_minus + coverage$PC_plus) * 10^6
coverage$PHm_norm <- coverage$PH_minus / sum(coverage$PH_minus + coverage$PH_plus) * 10^6
coverage$PHp_norm <- coverage$PH_plus / sum(coverage$PH_minus + coverage$PH_plus) * 10^6
coverage$RCm_norm <- coverage$RC_minus / sum(coverage$RC_minus + coverage$RC_plus) * 10^6
coverage$RCp_norm <- coverage$RC_plus / sum(coverage$RC_minus + coverage$RC_plus) * 10^6
coverage$RHm_norm <- coverage$RH_minus / sum(coverage$RH_minus + coverage$RH_plus) * 10^6
coverage$RHp_norm <- coverage$RH_plus / sum(coverage$RH_minus + coverage$RH_plus) * 10^6

## normalization values from samtools flagstat
## multiply PRO-seq reads by 2x average read length since only 3' position is used

# coverage$PCm_norm <- (coverage$PC_minus / 3480968) * 10^6
# coverage$PCp_norm <- (coverage$PC_plus / 3480968) * 10^6
# coverage$PHm_norm <- (coverage$PH_minus / 3265929) * 10^6
# coverage$PHp_norm <- (coverage$PH_plus / 3265929) * 10^6
# coverage$RCm_norm <- (coverage$RC_minus / 6391339) * 10^6
# coverage$RCp_norm <- (coverage$RC_plus / 6391339) * 10^6
# coverage$RHm_norm <- (coverage$RH_minus / 5023896) * 10^6
# coverage$RHp_norm <- (coverage$RH_plus / 5023896) * 10^6

cov_norm <- coverage[,-c(3:10)]
treatments <- colnames(cov_norm)[3:10]
#rm(coverage)
```

## read in and clean up counts data (iter_correct)
```{r}
require(dplyr)

setwd("/workdir/users/acv46/EC_PROSeq/")

# PRO-seq and RNA-seq coverage data
# use interation 2, see readme in file directory
coverage <- read_csv(file = "pileup/iter_correct/all_coverage_formatted.txt", col_names = T)

## normalize to rpm and subset for manageability
# size of window over which coverage is calculated

# pc_sum <- coverage %>% filter(type == "PRO-seq" & treatment == "control" & end == "full") %>% select(value) %>% sum()
# rc_sum <- coverage %>% filter(type == "RNA-seq" & treatment == "control" & end == "full") %>% select(value) %>% sum()
# ph_sum <- coverage %>% filter(type == "PRO-seq" & treatment == "heat shock" & end == "full") %>% select(value) %>% sum()
# rh_sum <- coverage %>% filter(type == "RNA-seq" & treatment == "heat shock" & end == "full") %>% select(value) %>% sum()
#   
# coverage <- coverage %>% mutate(norm = 10^9 * value / sum(
#   
#   if (type == "PRO-seq" & treatment == "control") {
#     pc_sum
#   } else if (type == "RNA-seq" & treatment == "control") {
#     rc_sum
#   } else if (type == "PRO-seq" & treatment == "heat shock") {
#     ph_sum
#   } else if (type == "RNA-seq" & treatment == "heat shock") {
#     rh_sum
#   }
#   
#   ))

coverage <- coverage %>% group_by(type,end,treatment) %>%
  mutate(norm = 10^6 * value / sum(value)) %>% ungroup()

```

## get coverage at TSS and range around each promoter, old coverage file
```{r}
getcoverage <- function(x, coverage, range) {
  
  # lapply does not preserve colnames, so must use column indices
  
  # caveats -- eliminates cases where tss is positioned within range of genome end
  
  # x is a row from the promoters file
  # cov is the coverage file
  ## assumes coverage file is sorted by position (decreasing)
  # treatments is a vector of treatment names corresponding to columns in the coverage file
  # range is a vector c(x,y), where x is the upstream context and y is the downstream context
  
  edge <- as.numeric(dplyr::count(coverage))
  
  if (x[3] == "forward") {
    
    min <- as.numeric(x[4]) - range[1]
    max <- as.numeric(x[4]) + range[2]
    
    # do not compute coverage if range goes over edge of genome
    if (min < 1 || max < 1 || min > edge || max > edge ) {
      
      print(paste("Skipping ", x[2], ", range exceeds edge of genome", sep = ""))
      
    } else {
    
      # hard-coded column names
    
      ## same strand as promoter
      PRO_control_plus <- coverage[min:max,]$PCp_norm
      PRO_heat_plus    <- coverage[min:max,]$PHp_norm
      RNA_control_plus <- coverage[min:max,]$RCm_norm #flipped
      RNA_heat_plus    <- coverage[min:max,]$RHm_norm #flipped
      ## opposite strand of promoter
      PRO_control_minus <- -coverage[min:max,]$PCm_norm
      PRO_heat_minus    <- -coverage[min:max,]$PHm_norm
      RNA_control_minus <- -coverage[min:max,]$RCp_norm #flipped
      RNA_heat_minus    <- -coverage[min:max,]$RHp_norm #flipped
      
      # hard-coded treatments
      
      index        <- c(-range[1]:range[2])
      pos <- c(min:max)
      promoter     <- c(rep(x[2], length(index)))
      sigma_factor <- c(rep(x[5], length(index)))
      EC_id        <- c(rep(x[1], length(index)))
  
      tibble(EC_id, promoter, sigma_factor, index, pos,
                 PRO_control_plus, PRO_heat_plus, RNA_control_plus, RNA_heat_plus,
                 PRO_control_minus, PRO_heat_minus, RNA_control_minus, RNA_heat_minus)
    
    }
    
  } else if (x[3] == "reverse") {
    
    min <- as.numeric(x[4]) + range[1]
    max <- as.numeric(x[4]) - range[2]
    
    # do not compute coverage if range goes over edge of genome
    if (min < 1 || max < 1 || min > edge || max > edge ) {
      
      print(paste("Skipping ", x[2], ", range exceeds edge of genome", sep = ""))
      
    } else {
    
      # hard-coded column names
    
      ## same strand as promoter
      PRO_control_plus <- coverage[min:max,]$PCm_norm
      PRO_heat_plus    <- coverage[min:max,]$PHm_norm
      RNA_control_plus <- coverage[min:max,]$RCp_norm #flipped
      RNA_heat_plus    <- coverage[min:max,]$RHp_norm #flipped
      ## opposite strand of promoter
      PRO_control_minus <- -coverage[min:max,]$PCp_norm
      PRO_heat_minus    <- -coverage[min:max,]$PHp_norm
      RNA_control_minus <- -coverage[min:max,]$RCm_norm #flipped
      RNA_heat_minus    <- -coverage[min:max,]$RHm_norm #flipped
      
      # hard-coded treatments
      
      index        <- c(-range[1]:range[2])
      pos <- c(min:max)
      promoter     <- c(rep(x[2], length(index)))
      sigma_factor <- c(rep(x[5], length(index)))
      EC_id        <- c(rep(x[1], length(index)))
  
      # dplyr::data_frame() is deprecated, update to use dplyr::tibble()
      
      tibble(EC_id, promoter, sigma_factor, index, pos,
                 PRO_control_plus, PRO_heat_plus, RNA_control_plus, RNA_heat_plus,
                 PRO_control_minus, PRO_heat_minus, RNA_control_minus, RNA_heat_minus)
    
    }
      
  }
  
}
```

## get coverage at TSS and range around each promoter, new coverage file
```{r}
getcoverage <- function(x, cov, range) {
  
  # lapply does not preserve colnames, so must use column indices
  
  # caveats -- eliminates cases where tss is positioned within range of genome end
  
  # x is a row from the promoters file
  # cov is the coverage file
  ## assumes coverage file is sorted by position (decreasing)
  # treatments is a vector of treatment names corresponding to columns in the coverage file
  # range is a vector c(x,y), where x is the upstream context and y is the downstream context
  
  subcov <- function(cov_, type_, end_, treat_, strand_, min_, max_) {
        subout <- cov_ %>% filter(type == type_ & end == end_ & treatment == treat_ &
                         strand == strand_ & position >= min_ & position <= max_) %>%
          select(norm) %>% as_vector()
        }
  
  edge <- as.numeric(max(cov$position))
  
  if (x[3] == "forward") {
    
    min <- as.numeric(x[4]) - range[1]
    max <- as.numeric(x[4]) + range[2]
    
    # do not compute coverage if range goes over edge of genome
    if (min < 1 || max < 1 || min > edge || max > edge ) {
      
      print(paste("Skipping ", x[2], ", range exceeds edge of genome", sep = ""))
      
    } else {
    
      # hard-coded column names
      
      ## same strand as promoter
      PRO_control_plus <- subcov(cov, "PRO-seq", "3", "control", "plus", min, max)
      PRO_heat_plus    <- subcov(cov, "PRO-seq", "3", "heat shock", "plus", min, max)
      RNA_control_plus <- subcov(cov, "RNA-seq", "full", "control", "minus", min, max) #flipped
      RNA_heat_plus    <- subcov(cov, "RNA-seq", "full", "heat shock", "minus", min, max) #flipped
      ## opposite strand of promoter
      PRO_control_minus <- subcov(cov, "PRO-seq", "3", "control", "minus", min, max) * -1
      PRO_heat_minus    <- subcov(cov, "PRO-seq", "3", "heat shock", "minus", min, max) * -1
      RNA_control_minus <- subcov(cov, "RNA-seq", "full", "control", "plus", min, max) * -1 #flipped
      RNA_heat_minus    <- subcov(cov, "RNA-seq", "full", "heat shock", "plus", min, max) * -1 #flipped
      
      # hard-coded treatments
      
      index        <- c(-range[1]:range[2])
      pos <- c(min:max)
      promoter     <- c(rep(x[2], length(index)))
      sigma_factor <- c(rep(x[5], length(index)))
      EC_id        <- c(rep(x[1], length(index)))
      direction <- c(rep(x[3], length(index)))
  
      # dplyr::data_frame() is deprecated, update to use dplyr::tibble()
      
      tibble(EC_id, promoter, sigma_factor, index, pos, direction,
                 PRO_control_plus, PRO_heat_plus, RNA_control_plus, RNA_heat_plus,
                 PRO_control_minus, PRO_heat_minus, RNA_control_minus, RNA_heat_minus)
    
    }
    
  } else if (x[3] == "reverse") {
    
    min <- as.numeric(x[4]) - range[2]
    max <- as.numeric(x[4]) + range[1]
    
    # do not compute coverage if range goes over edge of genome
    if (min < 1 || max < 1 || min > edge || max > edge ) {
      
      print(paste("Skipping ", x[2], ", range exceeds edge of genome", sep = ""))
      
    } else {
    
      # hard-coded column names
    
      ## same strand as promoter
      PRO_control_plus <- subcov(cov, "PRO-seq", "3", "control", "minus", min, max)
      PRO_heat_plus    <- subcov(cov, "PRO-seq", "3", "heat shock", "minus", min, max)
      RNA_control_plus <- subcov(cov, "RNA-seq", "full", "control", "plus", min, max) #flipped
      RNA_heat_plus    <- subcov(cov, "RNA-seq", "full", "heat shock", "plus", min, max) #flipped
      ## opposite strand of promoter
      PRO_control_minus <- subcov(cov, "PRO-seq", "3", "control", "plus", min, max) * -1
      PRO_heat_minus    <- subcov(cov, "PRO-seq", "3", "heat shock", "plus", min, max) * -1
      RNA_control_minus <- subcov(cov, "RNA-seq", "full", "control", "minus", min, max) * -1  #flipped
      RNA_heat_minus    <- subcov(cov, "RNA-seq", "full", "heat shock", "minus", min, max) * -1 #flipped
      
      # hard-coded treatments
      
      index        <- c(range[2]:-range[1])
      pos <- c(min:max)
      promoter     <- c(rep(x[2], length(index)))
      sigma_factor <- c(rep(x[5], length(index)))
      EC_id        <- c(rep(x[1], length(index)))
      direction <- c(rep(x[3], length(index)))
  
      # dplyr::data_frame() is deprecated, update to use dplyr::tibble()
      
      tibble(EC_id, promoter, sigma_factor, index, pos, direction,
                 PRO_control_plus, PRO_heat_plus, RNA_control_plus, RNA_heat_plus,
                 PRO_control_minus, PRO_heat_minus, RNA_control_minus, RNA_heat_minus)
    
    }
      
  }
  
  message(paste0(x[7], " / 622"))
  
}
```

## apply function and bind results to single dataframe
```{r}
library(dplyr)
library(pbapply)
library(reshape2)
# make sure to unload other packages before running, or calls of count get masked and fail

covdat <- pbapply(X = promoters, MARGIN = 1,
                  FUN = getcoverage, cov = coverage, range = c(50,200))

# bind_rows returns error for dataframes from promoters that exceeded genome range, drop first

#covdat[3749] <- NULL
covdat <- bind_rows(covdat)

#write_csv(covdat, file = "/workdir/users/acv46/EC_PROSeq/figures/promoters/covdat_promoterproximal_singlesigma_20Dec2021.csv", col_names = T)
covdat <- read_csv(file = "/workdir/users/acv46/EC_PROSeq/figures/promoters/covdat_promoterproximal_singlesigma_20Dec2021_2.csv", col_names = T)

# subset dataframe to promoters with a single sigmafactor
# melt so that all libraries are in a single column
covdat_melt <- melt(data = covdat,
                    id.vars = c("EC_id", "promoter", "sigma_factor", "index", "pos", "direction"),
                    measure.vars = c("PRO_control_plus", "PRO_heat_plus", "RNA_control_plus", "RNA_heat_plus",
                                     "PRO_control_minus", "PRO_heat_minus", "RNA_control_minus", "RNA_heat_minus"))

covdat_melt <- covdat_melt %>% filter(sigma_factor %in% c("Sigma70","Sigma38","Sigma24","unknown","Sigma28","Sigma32","Sigma54")) 
```

## plot coverage centered at TSS - geom_smooth, RNA-seq and PRO-seq
```{r}
# facet by sigma factor

pal <- c("#2c7bb6", 
         "#d7191c",
         "#4daf4a",
         "#984ea3",
         "#2c7bb6", 
         "#d7191c",
         "#4daf4a",
         "#984ea3")

ggplot(data = covdat_melt) +
  geom_smooth(aes(x = index,
                  y = value,
                  color = variable,
                  fill = variable)) +
  scale_fill_manual(values = pal) +
  scale_color_manual(values = pal) +
  facet_wrap(~ sigma_factor) +
  theme_classic() +
  geom_hline(yintercept = 0, color = "black", size = 0.5) +
  geom_vline(xintercept = 0, color = "black", size = 0.5, linetype = "dotted") +
  ylab("Normalized read count") + 
  xlab("Position relative to promoter start")

```

## plot coverage centered at TSS - geom_smooth, PRO-seq only
```{r}
# facet by sigma factor

pal <- c("#2c7bb6", 
         "#d7191c",
         "#2c7bb6", 
         "#d7191c")

ggplot(data = covdat_melt[grep("^PRO", covdat_melt$variable), ]) +
  geom_smooth(aes(x = index,
                  y = value,
                  color = variable,
                  fill = variable)) +
  scale_fill_manual(values = pal) +
  scale_color_manual(values = pal) +
  facet_wrap(~ sigma_factor) +
  theme_classic() +
  geom_hline(yintercept = 0, color = "black", size = 0.5) +
  geom_vline(xintercept = 0, color = "black", size = 0.5, linetype = "dotted") +
  ylab("Normalized read count") + 
  xlab("Position relative to promoter start")

```

## plot coverage centered at TSS - geom_smooth, RNA-seq only
```{r}
# facet by sigma factor

pal <- c("#4daf4a",
         "#984ea3",
         "#4daf4a",
         "#984ea3")

ggplot(data = covdat_melt[grep("^RNA", covdat_melt$variable), ]) +
  geom_smooth(aes(x = index,
                  y = value,
                  color = variable,
                  fill = variable)) +
  scale_fill_manual(values = pal) +
  scale_color_manual(values = pal) +
  facet_wrap(~ sigma_factor) +
  theme_classic() +
  geom_hline(yintercept = 0, color = "black", size = 0.5) +
  geom_vline(xintercept = 0, color = "black", size = 0.5, linetype = "dotted") +
  ylab("Normalized read count") + 
  xlab("Position relative to promoter start")

```

## plot coverage centered at TSS - geom_smooth, RNA-seq and PRO-seq, sigma 70, 32, 24
```{r}
# facet by sigma factor

covdat_melt_sub <- covdat_melt[which(covdat_melt$sigma_factor == "Sigma70" 
                                     | covdat_melt$sigma_factor == "Sigma32" 
                                     | covdat_melt$sigma_factor == "Sigma24"),]

covdat_melt_sub$sigma_factor_ordered = factor(covdat_melt_sub$sigma_factor, levels=c("Sigma70","Sigma32","Sigma24"))

# y value for line labels
laby <- 2

# labels for legend
lableg <- c("PRO-seq control", "PRO-seq heat shock", "RNA-seq control", "RNA-seq heat shock")

facet.labs <- c(paste("\u03C3","70",", n = ", 
                      nrow(covdat_melt_sub[which(covdat_melt_sub$index == 0  
                                                 & covdat_melt_sub$variable == "PRO_control_plus" 
                                                 & covdat_melt_sub$sigma_factor_ordered == "Sigma70"),]),
                      sep = ""),
                paste("\u03C3","32",", n = ", 
                      nrow(covdat_melt_sub[which(covdat_melt_sub$index == 0  
                                                 & covdat_melt_sub$variable == "PRO_control_plus" 
                                                 & covdat_melt_sub$sigma_factor_ordered == "Sigma32"),]),
                      sep = ""),
                paste("\u03C3","24",", n = ", 
                      nrow(covdat_melt_sub[which(covdat_melt_sub$index == 0  
                                                 & covdat_melt_sub$variable == "PRO_control_plus" 
                                                 & covdat_melt_sub$sigma_factor_ordered == "Sigma24"),]),
                      sep = ""))
names(facet.labs) <- c("Sigma70","Sigma32","Sigma24")

pal <- c("#E69F00FF","#D55E00FF","#7acfff","#0072B2FF",
         "#E69F00FF","#D55E00FF","#7acfff","#0072B2FF")

# geom_point overextends y axis and makes differences hard to see

p <- ggplot(data = covdat_melt_sub) +
  # geom_jitter(mapping = aes(x = index,
  #                          y = value,
  #                          color = variable),
  #            alpha = 0.1, 
  #            shape = 16) +
  # geom_linerange(aes(x = index,
  #                   ymin = quart(value)[1],
  #                   ymax = quart(value)[2],
  #                   color = variable),
  #                size = 1) +
  #                   #outlier.shape = NA) +
  geom_smooth(aes(x = index,
                  y = value,
                  color = variable,
                  fill = variable),
              se = T,
              level = 0.95) +
  scale_fill_manual(values = pal,
                    labels = lableg) +
  scale_color_manual(values = pal,
                     labels = lableg) +
  facet_grid(rows = vars(sigma_factor_ordered),
             labeller = labeller(sigma_factor_ordered = facet.labs)) +
  #coord_cartesian(ylim = c(-0.5, 2.5)) + 
  theme_bw(base_family = "sans") +
  geom_hline(yintercept = 0, color = "black", size = 0.5) +
  geom_vline(xintercept = 0, color = "black", size = 0.5, linetype = "dotted") +
  annotate(geom = "label",
           x = 0,
           y = laby,
           color = "black",
           angle = 0,
           label = "+1",
           size = 3) +
  # geom_vline(xintercept = -10, color = "black", size = 0.5, linetype = "dotted") +
  # annotate(geom = "label",
  #          x = -10,
  #          y = laby,
  #          color = "black",
  #          angle = 0,
  #          label = "-10",
  #          size = 3) +
  geom_vline(xintercept = -35, color = "black", size = 0.5, linetype = "dotted") +
  annotate(geom = "label",
           x = -35,
           y = laby,
           color = "black",
           angle = 0,
           label = "-35",
           size = 3) +
  geom_vline(xintercept = 75, color = "black", size = 0.5, linetype = "dotted") +
  annotate(geom = "label",
           x = 74,
           y = laby,
           color = "black",
           angle = 0,
           label = "+75",
           size = 3) +
  geom_vline(xintercept = 150, color = "black", size = 0.5, linetype = "dotted") +
  annotate(geom = "label",
           x = 149,
           y = laby,
           color = "black",
           angle = 0,
           label = "+150",
           size = 3) +
  ylab("Normalized depth") + 
  theme_classic() +
  theme(axis.title.x = element_blank(),
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        legend.title = element_blank(),
        strip.text.y = element_text(size = 12),
        axis.text.y = element_text(size = 10))
  

p
```
### ggsave
```{r}
#library(svglite)
setwd("/workdir/users/acv46/EC_PROSeq/figures/promoters")
ggsave(filename = "sigma70_32_24.minus50plus200_fixed_regdb10.9_redo.pdf",
       plot = p,
       device = "pdf",
       dpi = 600,
       width = 8,
       height = 6,
       useDingbats = F)
ggsave(filename = "sigma70_32_24.minus50plus200_fixed_regdb10.9_redo.svg",
       plot = p,
       device = "svg",
       dpi = 600,
       width = 8,
       height = 6)
```
### Cairo -- broken
```{r}
#library(Cairo)
setwd("/workdir/users/acv46/EC_PROSeq/figures/promoters")

CairoSVG(file = "sigma70_32_24.minus50plus200_2.svg",
         #type = "svg",
         dpi = 600,
         width = 8,
         height = 6)
print(p)
dev.off()

CairoPDF(file = "sigma70_32_24.minus50plus200_2.pdf",
         #type = "pdf",
         dpi = 600,
         width = 8,
         height = 6)
print(p)
dev.off()
```


## plot coverage centered at TSS - geom_smooth, RNA-seq and PRO-seq, sigma 38, 28, 54, unknown
```{r}
# facet by sigma factor

covdat_melt_sub <- covdat_melt[which(covdat_melt$sigma_factor == "Sigma38" 
                                     | covdat_melt$sigma_factor == "Sigma28" 
                                     | covdat_melt$sigma_factor == "Sigma54"
                                     | covdat_melt$sigma_factor == "unknown"),]

covdat_melt_sub$sigma_factor_ordered = factor(covdat_melt_sub$sigma_factor,
                                              levels=c("Sigma38","Sigma28","Sigma54","unknown"))

# y value for line labels
laby <- 2

# labels for legend
lableg <- c("PRO-seq control", "PRO-seq heat shock", "RNA-seq control", "RNA-seq heat shock")

facet.labs <- c(paste("\u03C3","38",", n = ", 
                      nrow(covdat_melt_sub[which(covdat_melt_sub$index == 0  
                                                 & covdat_melt_sub$variable == "PRO_control_plus" 
                                                 & covdat_melt_sub$sigma_factor_ordered == "Sigma38"),]),
                      sep = ""),
                paste("\u03C3","28",", n = ", 
                      nrow(covdat_melt_sub[which(covdat_melt_sub$index == 0  
                                                 & covdat_melt_sub$variable == "PRO_control_plus" 
                                                 & covdat_melt_sub$sigma_factor_ordered == "Sigma28"),]),
                      sep = ""),
                paste("\u03C3","54",", n = ", 
                      nrow(covdat_melt_sub[which(covdat_melt_sub$index == 0  
                                                 & covdat_melt_sub$variable == "PRO_control_plus" 
                                                 & covdat_melt_sub$sigma_factor_ordered == "Sigma54"),]),
                      sep = ""),
                paste("unknown",", n = ", 
                      nrow(covdat_melt_sub[which(covdat_melt_sub$index == 0  
                                                 & covdat_melt_sub$variable == "PRO_control_plus" 
                                                 & covdat_melt_sub$sigma_factor_ordered == "unknown"),]),
                      sep = ""))
names(facet.labs) <- c("Sigma38","Sigma28","Sigma54","unknown")

pal <- c("#E69F00FF","#D55E00FF","#56B4E9FF","#0072B2FF",
         "#E69F00FF","#D55E00FF","#56B4E9FF","#0072B2FF")

# geom_point overextends y axis and makes differences hard to see

p <- ggplot(data = covdat_melt_sub) +
  # geom_jitter(mapping = aes(x = index,
  #                          y = value,
  #                          color = variable),
  #            alpha = 0.1, 
  #            shape = 16) +
  # geom_linerange(aes(x = index,
  #                   ymin = quart(value)[1],
  #                   ymax = quart(value)[2],
  #                   color = variable),
  #                size = 1) +
  #                   #outlier.shape = NA) +
  geom_smooth(aes(x = index,
                  y = value,
                  color = variable,
                  fill = variable),
              se = T,
              level = 0.95) +
  scale_fill_manual(values = pal,
                    labels = lableg) +
  scale_color_manual(values = pal,
                     labels = lableg) +
  facet_grid(rows = vars(sigma_factor_ordered),
             labeller = labeller(sigma_factor_ordered = facet.labs)) +
  coord_cartesian(ylim = c(-0.5, 2.5)) + 
  theme_bw(base_family = "sans") +
  geom_hline(yintercept = 0, color = "black", size = 0.5) +
  geom_vline(xintercept = 0, color = "black", size = 0.5, linetype = "dotted") +
  annotate(geom = "label",
           x = 0,
           y = laby,
           color = "black",
           angle = 0,
           label = "+1",
           size = 3) +
  # geom_vline(xintercept = -10, color = "black", size = 0.5, linetype = "dotted") +
  # annotate(geom = "label",
  #          x = -10,
  #          y = laby,
  #          color = "black",
  #          angle = 0,
  #          label = "-10",
  #          size = 3) +
  geom_vline(xintercept = -35, color = "black", size = 0.5, linetype = "dotted") +
  annotate(geom = "label",
           x = -35,
           y = laby,
           color = "black",
           angle = 0,
           label = "-35",
           size = 3) +
  geom_vline(xintercept = 75, color = "black", size = 0.5, linetype = "dotted") +
  annotate(geom = "label",
           x = 74,
           y = laby,
           color = "black",
           angle = 0,
           label = "+75",
           size = 3) +
  geom_vline(xintercept = 150, color = "black", size = 0.5, linetype = "dotted") +
  annotate(geom = "label",
           x = 149,
           y = laby,
           color = "black",
           angle = 0,
           label = "+150",
           size = 3) +
  ylab("Normalized depth") + 
  theme_classic() +
  theme(axis.title.x = element_blank(),
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        legend.title = element_blank(),
        strip.text.y = element_text(size = 12),
        axis.text.y = element_text(size = 10))
  

p
```
### ggsave
```{r}
#library(svglite)
setwd("/workdir/users/acv46/EC_PROSeq/figures/promoters")
ggsave(filename = "sigma70_32_24.minus50plus200_fixed_regdb10.9.png",
       plot = p,
       device = "png",
       dpi = 600,
       width = 8,
       height = 6)
ggsave(filename = "sigma70_32_24.minus50plus200_fixed_regdb10.9.svg",
       plot = p,
       device = "svg",
       dpi = 600,
       width = 8,
       height = 6)
ggsave(filename = "sigma70_32_24.minus50plus200_fixed_regdb10.9.pdf",
       plot = p,
       device = cairo_pdf,
       dpi = 600,
       width = 8,
       height = 6)
```
### Cairo -- broken
```{r}
#library(Cairo)
setwd("/workdir/users/acv46/EC_PROSeq/figures/promoters")

CairoSVG(file = "sigma70_32_24.minus50plus200_2.svg",
         #type = "svg",
         dpi = 600,
         width = 8,
         height = 6)
print(p)
dev.off()

CairoPDF(file = "sigma70_32_24.minus50plus200_2.pdf",
         #type = "pdf",
         dpi = 600,
         width = 8,
         height = 6)
print(p)
dev.off()
```


## plot coverage centered at TSS and start codons, single promoter + single sigma operon subset
```{r}
# tss_prox object made with /workdir/users/acv46/EC_PROSeq/figures/motifs/tss_pausing.R
# trans_prox object made with /workdir/users/acv46/EC_PROSeq/figures/motifs/trans_pausing.R
```

### subset operon object by promoters and output operon regulatory ranges
```{r}
e_coli_regulondb_10.9 <- regulondb(database_conn = connect_database(),
                              organism = "E.coli",
                              database_version = "10.9",
                              genome_version = "NC_000913.3")

# get vector of promoters
promset <- get_dataset(e_coli_regulondb_10.9, 
            dataset = "OPERON") %>% as_tibble() %>%
  filter(total_sigma == 1) %>%
  select(promoter_name) %>% as_vector()

promoters <- get_dataset(e_coli_regulondb_10.9, 
                         dataset = "PROMOTER",
                         attributes = c("id","name","strand","tss","sigma_factor","regulated_operon")) %>%
  as_tibble() %>% filter(name %in% promset) %>%
  na.omit() %>% mutate(count = c(1:n()))

ops <- get_dataset(e_coli_regulondb_10.9, 
            dataset = "OPERON") %>%
            #attributes = c("id","name","total_sigma","sigma_name")) %>%
  as_tibble()

# get object with tss and firstgeneposleft for all operons
tss2op <- promoters %>% separate(col = regulated_operon, into = c("op_id","op_name"), sep = "\t") %>%
  merge(., ops %>% select(id, firstgeneposleft, lastgeneposright, tf_name) %>% rename("op_id" = "id"),
        by = "op_id") %>% drop_na(-tf_name) %>% as_tibble()

# reduce tss2op object to single regulatory range encompassing all promoters
reg_ranges <-
rbind(
  tss2op %>% filter(strand == "forward") %>%
    group_by(op_id) %>% arrange(tss) %>%
    dplyr::slice(1) %>% select(-lastgeneposright) %>%
    rename("op_start" = "firstgeneposleft"),
  tss2op %>% filter(strand == "reverse") %>%
    group_by(op_id) %>% arrange(desc(tss)) %>%
    dplyr::slice(1) %>% select(-firstgeneposleft) %>%
    rename("op_start" = "lastgeneposright")
)

reg_ranges <- reg_ranges %>% mutate(op_start = as.numeric(op_start))
```

### generate coverage object, PRO-seq and RNAseq
```{r}
coverage <- read_csv("/workdir/users/acv46/EC_PROSeq/pileup/iter_correct/all_coverage_formatted.txt")
# flip orintation of plus and minus, just for fun
# 3' and 5' ends must also be flipped for correct orientation
# orientation and end flippinf supported by tRNA mapping
# get normalized values by grouping lib types
## normalize based on full coverage values
coverage <- coverage %>% mutate(strand1 = ifelse(strand == "plus", "minus", "plus")) %>%
  select(-strand) %>% dplyr::rename(strand = strand1) %>%
  mutate(end1 = ifelse(end == "3", "5", ifelse(end == "5", "3", "full"))) %>%
  select(-end) %>% dplyr::rename(end = end1)
  # group_by(type, treatment, end) %>%
  # mutate(norm = (value / sum(value)) * 10^6) %>%
  # ungroup()

cp_sum <- coverage %>% filter(end == "3" & treatment == "control" & type == "PRO-seq") %>% select(value) %>% sum()
hp_sum <- coverage %>% filter(end == "3" & treatment == "heat shock" & type == "PRO-seq") %>% select(value) %>% sum()
cr_sum <- coverage %>% filter(end == "full" & treatment == "control" & type == "RNA-seq") %>% select(value) %>% sum()
hr_sum <- coverage %>% filter(end == "full" & treatment == "heat shock" & type == "RNA-seq") %>% select(value) %>% sum()

coverage <- coverage %>% mutate(norm = ifelse(treatment == "control" & type == "PRO-seq", (value / cp_sum) * 10^6,
                                              ifelse(treatment == "heat shock" & type == "PRO-seq", (value / hp_sum) * 10^6,
                                                     ifelse(treatment == "control" & type == "RNA-seq", (value / cr_sum) * 10^6,
                                                            ifelse(treatment == "heat shock" & type == "RNA-seq", (value / hr_sum) * 10^6, NA)
                                                            )
                                                     )
                                              )
                                )

pro_covdat <- coverage %>% filter(type == "PRO-seq") %>% filter(end %in% c("3","5"))
```

### run tss_pausing.R and trans_pausing.R, then read in
```{r}

trans_prox <- read_csv(file = "/workdir/users/acv46/EC_PROSeq/figures/motifs/PRO-seq_pausing_500bp_centertrans_v2.csv",
                       col_names = T)
tss_prox <- read_csv(file = "/workdir/users/acv46/EC_PROSeq/figures/motifs/PRO-seq_pausing_500bp_centertss_v2.csv",
                     col_names = T)

```

### plot 
```{r}
require(tidyverse)
#tss_prox <- read_csv("/workdir/users/acv46/EC_PROSeq/figures/motifs/PRO-seq_pausing_500bp_centertss.csv", col_names = T)
#trans_prox <- read_csv("/workdir/users/acv46/EC_PROSeq/figures/motifs/PRO-seq_pausing_500bp_centertrans.csv", col_names = T)

plotsigma <- function(plotdat, title, ypos) {

  counts <- plotdat %>% filter(!grepl(",", sigma)) %>%
    filter(index == 0, type == "PRO-seq", treatment == "control",
           strand == "plus", end == "3") %>%
    select(sigma) %>% table %>% as_tibble() %>% rename("sigma" = ".")
  
  plotdat2 <- left_join(plotdat, counts, by = "sigma") %>% 
    mutate(combo = paste0(type," ",treatment)) %>% filter(end != "5")
  
  ggplot(data = plotdat2 %>%
           filter(!grepl(",", sigma)) %>%
           filter(index %in% c(-100:200)) %>%
           filter(strand == "plus")) + 
    geom_smooth(mapping = aes(x = index, y = norm, color = combo, fill = combo)) +
    geom_text(mapping = aes(label = paste0(sigma,"\n","n = ",n)),
              x = -100,
              y = ypos,
              hjust = 0,
              vjust = 1,
              check_overlap = T) + 
    scale_color_manual(values = c("blue", "red", "green", "purple")) + 
    scale_fill_manual(values = c("blue", "red", "green", "purple")) + 
    geom_hline(yintercept = 0, color = "black") +
    geom_vline(xintercept = 0, color = "black", linetype = "dotted") +
    xlab("position") +
    ylab("Per-base read depth") +
    facet_wrap(~ sigma, nrow = 2) + 
    #theme_classic() + 
    ggtitle(title) +
    theme(strip.background = element_blank(),
          strip.text = element_blank(),
          panel.spacing = unit(0.2, "lines"),
          panel.background = element_rect(fill = "white"),
          panel.border = element_rect(colour = "black", size = 1, fill = NA),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank())
  
}

p1 <- plotsigma(tss_prox, "PRO-seq operon coverage profiles centered at right-most transcription start site", 2.8)
p2 <- plotsigma(trans_prox, "PRO-seq operon coverage profiles centered at first start codon", 3.2)

p1
p2

# setwd("/workdir/users/acv46/EC_PROSeq/figures/promoters")
# ggsave(filename = "proseq_perOperon_bySigma_centerTSS_500_v4.pdf",
#        plot = p1, device = "pdf", width = 8, height = 6, units = "in",
#        useDingbats = FALSE)
# ggsave(filename = "proseq_perOperon_bySigma_centerStartCodon_500_v4.pdf",
#        plot = p2, device = "pdf", width = 8, height = 6, units = "in",
#        useDingbats = FALSE)

```

# Operon paradigms

## read in data 
```{r}
library(tidyverse)
setwd("/workdir/users/acv46/EC_PROSeq")

# PRO-seq and RNA-seq coverage data
# use interation 2, see readme in file directory
coverage <- read_delim(file = "pileup/iter2/all_coverage.txt",
                       delim = "\t")

## normalize to rpm and subset for manageability

coverage$PCm_norm <- coverage$PC_minus / sum(coverage$PC_minus + coverage$PC_plus) * 10^6
coverage$PCp_norm <- coverage$PC_plus / sum(coverage$PC_minus + coverage$PC_plus) * 10^6
coverage$PHm_norm <- coverage$PH_minus / sum(coverage$PH_minus + coverage$PH_plus) * 10^6
coverage$PHp_norm <- coverage$PH_plus / sum(coverage$PH_minus + coverage$PH_plus) * 10^6
coverage$RCm_norm <- coverage$RC_minus / sum(coverage$RC_minus + coverage$RC_plus) * 10^6
coverage$RCp_norm <- coverage$RC_plus / sum(coverage$RC_minus + coverage$RC_plus) * 10^6
coverage$RHm_norm <- coverage$RH_minus / sum(coverage$RH_minus + coverage$RH_plus) * 10^6
coverage$RHp_norm <- coverage$RH_plus / sum(coverage$RH_minus + coverage$RH_plus) * 10^6

cov_norm <- coverage[,-c(3:10)]
treatments <- colnames(cov_norm)[3:10]
rm(coverage)
```

## retrieve regulonDB and create GRanges objects
```{r}
library(regutools)
library(Biostrings)
## Build a regulondb object
## stores database at /home/acv46/.cache/AnnotationHub
e_coli_regulondb <- regulondb(database_conn = connect_database(),
                              organism = "E.coli",
                              database_version = "10.6",
                              genome_version = "NC_000913.3")

#list_datasets(e_coli_regulondb)
#list_attributes(e_coli_regulondb, dataset = "PROMOTER")

## gene dataset
promoters <- get_dataset(regulondb = e_coli_regulondb,
                     dataset = "PROMOTER")
operons <- get_dataset(regulondb = e_coli_regulondb,
                     dataset = "OPERON")
# subset only for operons that have at least one promoter
operons <- operons[which(operons$total_promoter >= 1),]
operons <- as_tibble(operons)


## convert to GRanges object and change sequence name to match bam files

#genes_ranges <- convert_to_granges(genes)
#genes_ranges <- renameSeqlevels(genes_ranges, "NC_000913.3")
#promoters_ranges <- convert_to_granges(promoters)
#promoters_ranges <- renameSeqlevels(promoters_ranges, "NC_000913.3")
#ops_ranges <- convert_to_granges(operons)
#ops_ranges <- renameSeqlevels(ops_ranges, "NC_000913.3")

#dnaK_range <- genes_ranges[which(genes_ranges$operon_name == "dnaK-tpke11-dnaJ")]



```

## get ratio function (equal width of bins)
```{r}
get_ratios <- function(x, coverage, binwidth, opmin, regmin) {
  
  if (!require(tidyverse)) install.packages('tidyverse')
  library(tidyverse)
  
  # lapply does not preserve colnames, so must use column indices
  
  # x is a row from the operons file
  # cov is the coverage file
  ## assumes coverage file is sorted by position (decreasing)
  # binwidth is the width of bins into which regions are split
  # opmin is the smallest operon length allowed
  # regmin is the smallest regulatory region length allowed
  
  # for a given vector of values
  ## cuts vector into number of equal-length bins
  ## returns sum of each bin
  ## gets median of bin sums
  
  ## code if width of bins is constant
  sum_bin_ratio <- function(vector){
    
    split(vector, cut(seq_along(vector), length(vector) / binwidth, labels = F)) %>% 
      lapply(., sum) %>% 
      unlist() %>% 
      median() #%>%
      #log2()
    
  }
  
  
  ## code if number of bins is constant
  # sum_bin_ratio <- function(vector){
  #   
  #   split(vector, cut(seq_along(vector), bins, labels = F)) %>% 
  #     lapply(., sum) %>% 
  #     unlist() %>% 
  #     median()
  #   
  # }
  
  if (is.na(x[7])) {
  
    print(paste("Skipping ", x[2], ", strand not given", sep = ""))
    
  } else if (x[7] == "forward") {
    
    # range of regulatory sequence
    ## beginning of reg seq to beginning of first gene
    regrange <- c(as.numeric(x[5]),
                  as.numeric(x[3])-1)
    regsize <- regrange[2] - regrange[1]
    regset <- c(regrange[1]:regrange[2])
    
    # range of non-regulatory operon
    ## first gene to last gene
    oprange <- c(as.numeric(x[3]),
                 as.numeric(x[4]))
    opsize <- oprange[2] - oprange[1]
    opset <- c(oprange[1]:oprange[2])
    
    # do not compute coverage if range goes over edge of genome
    if (opsize < opmin) {
      
      print(paste("Skipping ", x[2], ", operon size is smaller than set minimum", sep = ""))
      
    } else if (regsize < regmin) {
      
      print(paste("Skipping ", x[2], ", regulatory region is smaller than set minimum", sep = ""))
      
    } else {
    
      # hard-coded column names
    
      # OPERON
      
      ## same strand as promoter
      PCp_Op <- coverage[opset,]$PCp_norm
      PHp_Op <- coverage[opset,]$PHp_norm
      RCp_Op <- coverage[opset,]$RCm_norm #flipped
      RHp_Op <- coverage[opset,]$RHm_norm #flipped
      ## opposite strand of promoter
      PCm_Op <- -coverage[opset,]$PCm_norm
      PHm_Op <- -coverage[opset,]$PHm_norm
      RCm_Op <- -coverage[opset,]$RCp_norm #flipped
      RHm_Op <- -coverage[opset,]$RHp_norm #flipped
      
      # REGULATOR
      
      ## same strand as promoter
      PCp_Re <- coverage[regset,]$PCp_norm
      PHp_Re <- coverage[regset,]$PHp_norm
      RCp_Re <- coverage[regset,]$RCm_norm #flipped
      RHp_Re <- coverage[regset,]$RHm_norm #flipped
      ## Reposite strand of promoter
      PCm_Re <- -coverage[regset,]$PCm_norm
      PHm_Re <- -coverage[regset,]$PHm_norm
      RCm_Re <- -coverage[regset,]$RCp_norm #flipped
      RHm_Re <- -coverage[regset,]$RHp_norm #flipped
      
      index  <- x[1] 
      name   <- x[2]
      strand <- x[7]
  
      ## get ratio of promoter median to operon median for plus strand sets
      PCRe_PCOp_ratio <- sum_bin_ratio(PCp_Re) / sum_bin_ratio(PCp_Op)
      PHRe_PHOp_ratio <- sum_bin_ratio(PHp_Re) / sum_bin_ratio(PHp_Op)
      RCRe_RCOp_ratio <- sum_bin_ratio(RCp_Re) / sum_bin_ratio(RCp_Op)
      RHRe_RHOp_ratio <- sum_bin_ratio(RHp_Re) / sum_bin_ratio(RHp_Op)
      PCRe_RCOp_ratio <- sum_bin_ratio(PCp_Re) / sum_bin_ratio(RCp_Op)
      PHRe_RHOp_ratio <- sum_bin_ratio(PHp_Re) / sum_bin_ratio(RHp_Op)
      
      tibble(index, name, strand, opsize, regsize,
             PCRe_PCOp_ratio, PHRe_PHOp_ratio,
             RCRe_RCOp_ratio, RHRe_RHOp_ratio,
             PCRe_RCOp_ratio, PHRe_RHOp_ratio)
    
    }
    
  } else if (x[7] == "reverse") {
    
    # range of regulatory sequence
    ## beginning of reg seq to beginning of first gene
    regrange <- c(as.numeric(x[6]),
                  as.numeric(x[4])+1)
    regsize <- regrange[1] - regrange[2]
    regset <- c(regrange[1]:regrange[2])
    
    # range of non-regulatory operon
    ## first gene to last gene
    oprange <- c(as.numeric(x[4]),
                 as.numeric(x[3]))
    opsize <- oprange[1] - oprange[2]
    opset <- c(oprange[1]:oprange[2])
    
    # do not compute coverage if range goes over edge of genome
    if (opsize < opmin) {
      
      print(paste("Skipping ", x[2], ", operon size is smaller than set minimum", sep = ""))
      
    } else if (regsize < regmin) {
      
      print(paste("Skipping ", x[2], ", regulatory region is smaller than set minimum", sep = ""))
      
    } else {
    
      # hard-coded column names
    
      # OPERON
      
      ## same strand as promoter
      PCp_Op <- coverage[opset,]$PCm_norm
      PHp_Op <- coverage[opset,]$PHm_norm
      RCp_Op <- coverage[opset,]$RCp_norm #flipped
      RHp_Op <- coverage[opset,]$RHp_norm #flipped
      ## opposite strand of promoter
      PCm_Op <- -coverage[opset,]$PCp_norm
      PHm_Op <- -coverage[opset,]$PHp_norm
      RCm_Op <- -coverage[opset,]$RCm_norm #flipped
      RHm_Op <- -coverage[opset,]$RHm_norm #flipped
      
      # REGULATOR
      
      ## same strand as promoter
      PCp_Re <- coverage[regset,]$PCm_norm
      PHp_Re <- coverage[regset,]$PHm_norm
      RCp_Re <- coverage[regset,]$RCp_norm #flipped
      RHp_Re <- coverage[regset,]$RHp_norm #flipped
      ## Reposite strand of promoter
      PCm_Re <- -coverage[regset,]$PCp_norm
      PHm_Re <- -coverage[regset,]$PHp_norm
      RCm_Re <- -coverage[regset,]$RCm_norm #flipped
      RHm_Re <- -coverage[regset,]$RHm_norm #flipped
      
      index  <- x[1] 
      name   <- x[2]
      strand <- x[7]
  
      ## get ratio of promoter median to operon median for plus strand sets
      
      PCRe_PCOp_ratio <- sum_bin_ratio(PCp_Re) - sum_bin_ratio(PCp_Op)
      PHRe_PHOp_ratio <- sum_bin_ratio(PHp_Re) - sum_bin_ratio(PHp_Op)
      RCRe_RCOp_ratio <- sum_bin_ratio(RCp_Re) - sum_bin_ratio(RCp_Op)
      RHRe_RHOp_ratio <- sum_bin_ratio(RHp_Re) - sum_bin_ratio(RHp_Op)
      PCRe_RCOp_ratio <- sum_bin_ratio(PCp_Re) - sum_bin_ratio(RCp_Op)
      PHRe_RHOp_ratio <- sum_bin_ratio(PHp_Re) - sum_bin_ratio(RHp_Op)
      
      tibble(index, name, strand, opsize, regsize,
             PCRe_PCOp_ratio, PHRe_PHOp_ratio,
             RCRe_RCOp_ratio, RHRe_RHOp_ratio,
             PCRe_RCOp_ratio, PHRe_RHOp_ratio)
    
    }
      
  }
  
}
```

## get bins function (equal number of bins)
```{r}
get_bins <- function(x, coverage, binwidth, opmin, regmin) {
  
  if (!require(tidyverse)) install.packages('tidyverse')
  library(tidyverse)
  
  # lapply does not preserve colnames, so must use column indices
  
  # x is a row from the operons file
  # cov is the coverage file
  ## assumes coverage file is sorted by position (decreasing)
  # binwidth is the width of bins into which regions are split
  # opmin is the smallest operon length allowed
  # regmin is the smallest regulatory region length allowed
  
  # for a given vector of values
  ## cuts vector into number of equal-length bins
  ## returns sum of each bin
  ## gets median of bin sums
  
  # ## code if width of bins is constant
  # sum_bin_ratio <- function(vector){
  #   
  #   split(vector, cut(seq_along(vector), length(vector) / binwidth, labels = F)) %>% 
  #     lapply(., sum) %>% 
  #     unlist() %>% 
  #     median() %>%
  #     log2()
  #   
  # }
  
  
  ## code if number of bins is constant
  sum_bin_ratio <- function(vector){

    split(vector, cut(seq_along(vector), bins, labels = F)) %>%
      lapply(., sum) %>%
      unlist() %>%
      median()

  }
  
  if (is.na(x[7])) {
  
    print(paste("Skipping ", x[2], ", strand not given", sep = ""))
    
  } else if (x[7] == "forward") {
    
    # range of regulatory sequence
    ## beginning of reg seq to beginning of first gene
    regrange <- c(as.numeric(x[5]),
                  as.numeric(x[3])-1)
    regsize <- regrange[2] - regrange[1]
    regset <- c(regrange[1]:regrange[2])
    
    # range of non-regulatory operon
    ## first gene to last gene
    oprange <- c(as.numeric(x[3]),
                 as.numeric(x[4]))
    opsize <- oprange[2] - oprange[1]
    opset <- c(oprange[1]:oprange[2])
    
    # do not compute coverage if range goes over edge of genome
    if (opsize < opmin) {
      
      print(paste("Skipping ", x[2], ", operon size is smaller than set minimum", sep = ""))
      
    } else if (regsize < regmin) {
      
      print(paste("Skipping ", x[2], ", regulatory region is smaller than set minimum", sep = ""))
      
    } else {
    
      # hard-coded column names
    
      # OPERON
      
      ## same strand as promoter
      PCp_Op <- coverage[opset,]$PCp_norm
      PHp_Op <- coverage[opset,]$PHp_norm
      RCp_Op <- coverage[opset,]$RCm_norm #flipped
      RHp_Op <- coverage[opset,]$RHm_norm #flipped
      ## opposite strand of promoter
      PCm_Op <- -coverage[opset,]$PCm_norm
      PHm_Op <- -coverage[opset,]$PHm_norm
      RCm_Op <- -coverage[opset,]$RCp_norm #flipped
      RHm_Op <- -coverage[opset,]$RHp_norm #flipped
      
      # REGULATOR
      
      ## same strand as promoter
      PCp_Re <- coverage[regset,]$PCp_norm
      PHp_Re <- coverage[regset,]$PHp_norm
      RCp_Re <- coverage[regset,]$RCm_norm #flipped
      RHp_Re <- coverage[regset,]$RHm_norm #flipped
      ## Reposite strand of promoter
      PCm_Re <- -coverage[regset,]$PCm_norm
      PHm_Re <- -coverage[regset,]$PHm_norm
      RCm_Re <- -coverage[regset,]$RCp_norm #flipped
      RHm_Re <- -coverage[regset,]$RHp_norm #flipped
      
      index  <- x[1] 
      name   <- x[2]
      strand <- x[7]
  
      ## get ratio of promoter median to operon median for plus strand sets
      PCRe_PCOp_ratio <- sum_bin_ratio(PCp_Re) / sum_bin_ratio(PCp_Op)
      PHRe_PHOp_ratio <- sum_bin_ratio(PHp_Re) / sum_bin_ratio(PHp_Op)
      RCRe_RCOp_ratio <- sum_bin_ratio(RCp_Re) / sum_bin_ratio(RCp_Op)
      RHRe_RHOp_ratio <- sum_bin_ratio(RHp_Re) / sum_bin_ratio(RHp_Op)
      PCRe_RCOp_ratio <- sum_bin_ratio(PCp_Re) / sum_bin_ratio(RCp_Op)
      PHRe_RHOp_ratio <- sum_bin_ratio(PHp_Re) / sum_bin_ratio(RHp_Op)
      
      tibble(index, name, strand, opsize, regsize,
             PCRe_PCOp_ratio, PHRe_PHOp_ratio,
             RCRe_RCOp_ratio, RHRe_RHOp_ratio,
             PCRe_RCOp_ratio, PHRe_RHOp_ratio)
    
    }
    
  } else if (x[7] == "reverse") {
    
    # range of regulatory sequence
    ## beginning of reg seq to beginning of first gene
    regrange <- c(as.numeric(x[6]),
                  as.numeric(x[4])+1)
    regsize <- regrange[1] - regrange[2]
    regset <- c(regrange[1]:regrange[2])
    
    # range of non-regulatory operon
    ## first gene to last gene
    oprange <- c(as.numeric(x[4]),
                 as.numeric(x[3]))
    opsize <- oprange[1] - oprange[2]
    opset <- c(oprange[1]:oprange[2])
    
    # do not compute coverage if range goes over edge of genome
    if (opsize < opmin) {
      
      print(paste("Skipping ", x[2], ", operon size is smaller than set minimum", sep = ""))
      
    } else if (regsize < regmin) {
      
      print(paste("Skipping ", x[2], ", regulatory region is smaller than set minimum", sep = ""))
      
    } else {
    
      # hard-coded column names
    
      # OPERON
      
      ## same strand as promoter
      PCp_Op <- coverage[opset,]$PCm_norm
      PHp_Op <- coverage[opset,]$PHm_norm
      RCp_Op <- coverage[opset,]$RCp_norm #flipped
      RHp_Op <- coverage[opset,]$RHp_norm #flipped
      ## opposite strand of promoter
      PCm_Op <- -coverage[opset,]$PCp_norm
      PHm_Op <- -coverage[opset,]$PHp_norm
      RCm_Op <- -coverage[opset,]$RCm_norm #flipped
      RHm_Op <- -coverage[opset,]$RHm_norm #flipped
      
      # REGULATOR
      
      ## same strand as promoter
      PCp_Re <- coverage[regset,]$PCm_norm
      PHp_Re <- coverage[regset,]$PHm_norm
      RCp_Re <- coverage[regset,]$RCp_norm #flipped
      RHp_Re <- coverage[regset,]$RHp_norm #flipped
      ## Reposite strand of promoter
      PCm_Re <- -coverage[regset,]$PCp_norm
      PHm_Re <- -coverage[regset,]$PHp_norm
      RCm_Re <- -coverage[regset,]$RCm_norm #flipped
      RHm_Re <- -coverage[regset,]$RHm_norm #flipped
      
      index  <- x[1] 
      name   <- x[2]
      strand <- x[7]
  
      ## get ratio of promoter median to operon median for plus strand sets
      
      PCRe_PCOp_ratio <- sum_bin_ratio(PCp_Re) - sum_bin_ratio(PCp_Op)
      PHRe_PHOp_ratio <- sum_bin_ratio(PHp_Re) - sum_bin_ratio(PHp_Op)
      RCRe_RCOp_ratio <- sum_bin_ratio(RCp_Re) - sum_bin_ratio(RCp_Op)
      RHRe_RHOp_ratio <- sum_bin_ratio(RHp_Re) - sum_bin_ratio(RHp_Op)
      PCRe_RCOp_ratio <- sum_bin_ratio(PCp_Re) - sum_bin_ratio(RCp_Op)
      PHRe_RHOp_ratio <- sum_bin_ratio(PHp_Re) - sum_bin_ratio(RHp_Op)
      
      tibble(index, name, strand, opsize, regsize,
             PCRe_PCOp_ratio, PHRe_PHOp_ratio,
             RCRe_RCOp_ratio, RHRe_RHOp_ratio,
             PCRe_RCOp_ratio, PHRe_RHOp_ratio)
    
    }
      
  }
  
}
```

## apply function
```{r}
library(data.table)

bw10 <- apply(operons,
                1,
                FUN = get_ratios,
                coverage = cov_norm, binwidth = 10, opmin = 300, regmin = 50)
bw10 <- bind_rows(bw10[!grepl("Skipping", bw10)])

bw5 <- apply(operons,
                1,
                FUN = get_ratios,
                coverage = cov_norm, binwidth = 5, opmin = 300, regmin = 50)
bw5 <- bind_rows(bw5[!grepl("Skipping", bw5)])

```
### histogram of ratios
```{r}
custhist <- function(vector, title){

  breaks <- max(vector[!is.infinite(vector) & !is.nan(vector)])
  
  hist(vector, breaks, main = title)
  
}


custhist(bw10$PCRe_RCOp_ratio, "bw10 Control")
custhist(bw10$PHRe_RHOp_ratio, "bw10 Heat")
custhist(bw5$PCRe_RCOp_ratio, "bw5 Control")
custhist(bw5$PHRe_RHOp_ratio, "bw5 Heat")

```

### which operons change states
```{r}
bw10$change <- bw10$PCRe_RCOp_ratio - bw10$PHRe_RHOp_ratio
bw10_sub <- bw10[,c(2,10,11,12)]
bw10_sub <- bw10_sub[order(bw10_sub$change),]

bw5$change <- bw5$PCRe_RCOp_ratio - bw5$PHRe_RHOp_ratio
bw5_sub <- bw5[,c(2,10,11,12)]
bw5_sub <- bw5_sub[order(bw5_sub$change),]

```

## visualize select operons
```{r}


plotrange <- function (pos) {
promoter <- covdat_melt[which(covdat_melt$pos == pos & covdat_melt$variable == "PRO_control_plus"),]$promoter
message(promoter)


picked <- covdat_melt[which(covdat_melt$promoter == promoter),]

trace <- ggplot(data = picked) +
  geom_line(mapping = aes(x = pos,
                          y = value,
                          color = variable)) +
  theme_classic() +
  ggtitle(label = promoter)

trace
}

#Control

plotrange(2286282)
plotrange(3946225)
plotrange(3982802)
plotrange(4175824)

# HS

plotrange(696964)
plotrange(1031625)
plotrange(1911659)
plotrange(3708617)
plotrange(4606268)
```



## compare operons function
```{r}
getcoverage <- function(x, coverage, range) {
  
  # lapply does not preserve colnames, so must use column indices
  
  # caveats -- eliminates cases where tss is positioned within range of genome end
  
  # x is a row from the operons file
  # cov is the coverage file
  ## assumes coverage file is sorted by position (decreasing)
  # treatments is a vector of treatment names corresponding to columns in the coverage file
  # range is a vector c(x,y), where x is the upstream context and y is the downstream context
  
  edge <- as.numeric(count(coverage))
  
  if (x[4] == "forward") {
    
    min <- as.numeric(x[5]) - range[1]
    max <- as.numeric(x[6]) + range[2]
    
    # do not compute coverage if range goes over edge of genome
    if (min < 1 || max < 1 || min > edge || max > edge ) {
      
      print(paste("Skipping ", x[2], ", range exceeds edge of genome", sep = ""))
      
    } else {
    
      # hard-coded column names
    
      ## same strand as promoter
      PRO_control_plus <- coverage[min:max,]$PCp_norm
      PRO_heat_plus    <- coverage[min:max,]$PHp_norm
      RNA_control_plus <- coverage[min:max,]$RCm_norm #flipped
      RNA_heat_plus    <- coverage[min:max,]$RHm_norm #flipped
      ## opposite strand of promoter
      PRO_control_minus <- -coverage[min:max,]$PCm_norm
      PRO_heat_minus    <- -coverage[min:max,]$PHm_norm
      RNA_control_minus <- -coverage[min:max,]$RCp_norm #flipped
      RNA_heat_minus    <- -coverage[min:max,]$RHp_norm #flipped
      
      # hard-coded treatments
      
      index   <- c(min:max)
      name    <- c(rep(x[2], length(index)))
      strand  <- c(rep(x[4], length(index)))
      op_ID   <- c(rep(x[1], length(index)))
      length  <- c(rep(x[7], length(index)))
  
      tibble(op_ID, name, strand, length, index,
                 PRO_control_plus, PRO_heat_plus, RNA_control_plus, RNA_heat_plus,
                 PRO_control_minus, PRO_heat_minus, RNA_control_minus, RNA_heat_minus)
    
    }
    
  } else if (x[4] == "reverse") {
    
    min <- as.numeric(x[6]) + range[1]
    max <- as.numeric(x[5]) - range[2]
    
    # do not compute coverage if range goes over edge of genome
    if (min < 1 || max < 1 || min > edge || max > edge ) {
      
      
      print(paste("Skipping ", x[2], ", range exceeds edge of genome", sep = ""))
      
    } else {
    
      # hard-coded column names
    
      ## same strand as promoter
      PRO_control_plus <- coverage[min:max,]$PCm_norm
      PRO_heat_plus    <- coverage[min:max,]$PHm_norm
      RNA_control_plus <- coverage[min:max,]$RCp_norm #flipped
      RNA_heat_plus    <- coverage[min:max,]$RHp_norm #flipped
      ## opposite strand of promoter
      PRO_control_minus <- -coverage[min:max,]$PCp_norm
      PRO_heat_minus    <- -coverage[min:max,]$PHp_norm
      RNA_control_minus <- -coverage[min:max,]$RCm_norm #flipped
      RNA_heat_minus    <- -coverage[min:max,]$RHm_norm #flipped
      
      # hard-coded treatments
      
      index   <- c(min:max)
      name    <- c(rep(x[2], length(index)))
      strand  <- c(rep(x[4], length(index)))
      op_ID   <- c(rep(x[1], length(index)))
      length  <- c(rep(x[6], length(index)))
  
      tibble(op_ID, name, strand, length, index,
                 PRO_control_plus, PRO_heat_plus, RNA_control_plus, RNA_heat_plus,
                 PRO_control_minus, PRO_heat_minus, RNA_control_minus, RNA_heat_minus)
    
    }
      
  }
  
}
```
# Transcription factors
## read in data

```{r}
library(tidyverse)
setwd("/workdir/users/acv46/EC_PROSeq")

# see script at /workdir/users/acv46/EC_PROSeq/index/U00096.3/regulonDB/get_activators_repressors.sh
tfdat <- read_delim(file = "index/U00096.3/regulonDB/tf2promoters.txt",
                    delim = "\t",
                    col_names = T)

# PRO-seq and RNA-seq coverage data
# use interation 2, see readme in file directory
coverage <- read_delim(file = "pileup/iter2/all_coverage.txt",
                       delim = "\t")

## normalize to rpm and subset for manageability

coverage$PCm_norm <- coverage$PC_minus / sum(coverage$PC_minus + coverage$PC_plus) * 10^6
coverage$PCp_norm <- coverage$PC_plus / sum(coverage$PC_minus + coverage$PC_plus) * 10^6
coverage$PHm_norm <- coverage$PH_minus / sum(coverage$PH_minus + coverage$PH_plus) * 10^6
coverage$PHp_norm <- coverage$PH_plus / sum(coverage$PH_minus + coverage$PH_plus) * 10^6
coverage$RCm_norm <- coverage$RC_minus / sum(coverage$RC_minus + coverage$RC_plus) * 10^6
coverage$RCp_norm <- coverage$RC_plus / sum(coverage$RC_minus + coverage$RC_plus) * 10^6
coverage$RHm_norm <- coverage$RH_minus / sum(coverage$RH_minus + coverage$RH_plus) * 10^6
coverage$RHp_norm <- coverage$RH_plus / sum(coverage$RH_minus + coverage$RH_plus) * 10^6

cov_norm <- coverage[,-c(3:10)]
treatments <- colnames(cov_norm)[3:10]
rm(coverage)

```


# Pause sites (defunct)
## read in data
```{r}
library(tidyverse)
setwd("/workdir/users/acv46/EC_PROSeq")

# PRO-seq and RNA-seq coverage data (as read in above)
# use interation 2, see readme in file directory
coverage <- read_delim(file = "pileup/iter2/all_coverage.txt",
                       delim = "\t")

## normalize to rpm and subset for manageability

coverage$PCm_norm <- coverage$PC_minus / sum(coverage$PC_minus + coverage$PC_plus) * 10^6
coverage$PCp_norm <- coverage$PC_plus / sum(coverage$PC_minus + coverage$PC_plus) * 10^6
coverage$PHm_norm <- coverage$PH_minus / sum(coverage$PH_minus + coverage$PH_plus) * 10^6
coverage$PHp_norm <- coverage$PH_plus / sum(coverage$PH_minus + coverage$PH_plus) * 10^6
coverage$RCm_norm <- coverage$RC_minus / sum(coverage$RC_minus + coverage$RC_plus) * 10^6
coverage$RCp_norm <- coverage$RC_plus / sum(coverage$RC_minus + coverage$RC_plus) * 10^6
coverage$RHm_norm <- coverage$RH_minus / sum(coverage$RH_minus + coverage$RH_plus) * 10^6
coverage$RHp_norm <- coverage$RH_plus / sum(coverage$RH_minus + coverage$RH_plus) * 10^6

cov_norm <- coverage[,-c(3:10)]
treatments <- colnames(cov_norm)[3:10]
```

## implement pause scoring from Sun 2021, median, point inclusive
```{r}
# "ends of all uniquely mapped RNA reads (bottom lane) were determined and the read count for each 3 end position was calculated and plotted (top lane). The genomic positions where 3 end/3 end median (51-bp window) read counts ratio (pause score) was  20 and read counts/10^6 reads was  10 satisfied our stringent definition for a pause site."

# pseudocode for 1-based circular genome 

## (((position - 1) +/- range) modulo genome_length) + 1 

get_pause_score1 <- function(vector, range){
  
  pause_score1 <- function(i, vector, genome_length, range){
  
    # i is the index of a value in the vector
    # vector is an ordered numeric vector representing depth / read counts across a the genome
    # genome_length is the length of the circular genome
    # range is the context around a position to calculate median depth, as an integer
  
    ## generate vector of positions at (position +/- range)
    
    fullrange <- sort(c(
      c(((i - 1) - c(1:range)) %% genome_length + 1),
      i,
      c(((i - 1) + c(1:range)) %% genome_length + 1)
      ))
    
    # pause score is normalized depth at position divided by median across range
    
    vector[i] / median(vector[fullrange])

  }  
      
  unlist(lapply(X = seq_along(vector),
                FUN = pause_score1,
                vector = vector,
                genome_length = length(vector),
                range = range))
  
}

```
## implement pause scoring, mean, point excluded
```{r}
# "ends of all uniquely mapped RNA reads (bottom lane) were determined and the read count for each 3 end position was calculated and plotted (top lane). The genomic positions where 3 end/3 end median (51-bp window) read counts ratio (pause score) was  20 and read counts/10^6 reads was  10 satisfied our stringent definition for a pause site."

# pseudocode for 1-based circular genome 

## (((position - 1) +/- range) modulo genome_length) + 1 

get_pause_score2 <- function(vector, range){
  
  pause_score2 <- function(i, vector, genome_length, range){
  
    # i is the index of a value in the vector
    # vector is an ordered numeric vector representing depth / read counts across a the genome
    # genome_length is the length of the circular genome
    # range is the context around a position to calculate median depth, as an integer
  
    ## generate vector of positions at (position +/- range)
    
    fullrange <- sort(c(
      c(((i - 1) - c(1:range)) %% genome_length + 1),
      #i,
      c(((i - 1) + c(1:range)) %% genome_length + 1)
      ))
    
    # pause score is normalized depth at position divided by median across range
    
    vector[i] / mean(vector[fullrange])

  }  
      
  unlist(lapply(X = seq_along(vector),
                FUN = pause_score2,
                vector = vector,
                genome_length = length(vector),
                range = range))
  
}

```
## calculate pause score on normalized data
```{r}
# reset cov_norm first if trying new range
range <- 15

cov_norm$PCm_pause <- get_pause_score1(cov_norm$PCm_norm, range)
cov_norm$PCp_pause <- get_pause_score1(cov_norm$PCp_norm, range)
cov_norm$PHm_pause <- get_pause_score1(cov_norm$PHm_norm, range)
cov_norm$PHp_pause <- get_pause_score1(cov_norm$PHp_norm, range)

cov_norm[sapply(cov_norm, is.nan)] <- NA

# write out to avoid running long code again
setwd("/workdir/users/acv46/EC_PROSeq/pileup")
write.table(x = cov_norm,
            file = paste("coverage_normalized_pausescores2_range", range, ".txt", sep = ""),
            quote = F,
            col.names = T,
            row.names = F,
            sep = "\t")

```

## histogram of pause scores
```{r}
setwd("/workdir/users/acv46/EC_PROSeq/pileup")
cov_inftransform <- read_delim(file = "coverage_normalized_pausescores2_range25.txt",
                     delim = "\t",
                     col_names = T)
```
```{r}
# transform 
cov_inftransform[sapply(cov_inftransform, is.infinite)] <- 100
cov_inftransform <- cov_inftransform[,-c(1,c(3:10))]
cov_inftransform <- data.table::melt(data = cov_inftransform,
                    id.vars = c("position"),
                    measure.vars = c("PCm_pause","PCp_pause","PHm_pause","PHp_pause"))

p <- ggplot(data = cov_inftransform) +
  geom_histogram(mapping = aes(x = value),
                 binwidth=0.1, position="dodge") +
  scale_y_log10()

p
```

## histogram of normalized depth
```{r}

cov_inftransform <- cov_norm

# transform 
cov_inftransform[sapply(cov_inftransform, is.infinite)] <- 100
cov_inftransform <- cov_inftransform[,c(2:6/)]
cov_inftransform <- data.table::melt(data = cov_inftransform,
                    id.vars = c("position"),
                    measure.vars = c("PCm_norm","PCp_norm","PHm_norm","PHp_norm"))

p <- ggplot(data = cov_inftransform) +
  geom_histogram(mapping = aes(x = value),
                 binwidth=1, position="dodge") +
  scale_y_log10()

p
```

## pause sites counting function
```{r}
# count pause sites with different parameters

pause_count <- function(data, min_depth, min_pause){
  
  # data is a subset of cov_norm where [,1] is position, [,2] is norm depth, [,3] is pause score
  # min_pause is minimum pause score (>=)
  # min_pause is minimum norm depth (>=)
  
  nrow(data[which(data[,2] >= min_depth & data[,3] >= min_pause),])
  
}

pause_site <- function(data, min_depth, min_pause){
  
  # data is a subset of cov_norm where [,1] is position, [,2] is norm depth, [,3] is pause score
  # min_pause is minimum pause score (>=)
  # min_pause is minimum norm depth (>=)
  
  data[which(data[,2] >= min_depth & data[,3] >= min_pause),]
  
}
```

### count pause sites with range = 25
```{r}
setwd("/workdir/users/acv46/EC_PROSeq/pileup")
data25 <- read_delim(file = "coverage_normalized_pausescores2_range25.txt",
                     delim = "\t",
                     col_names = T)
```
```{r}
min_d <- 10
min_p <- 2

# PCm
pause_count(data = data25[,c(2,3,11)], min_depth = min_d, min_pause = min_p)
# PCp
pause_count(data = data25[,c(2,4,12)], min_depth = min_d, min_pause = min_p)
# PHm
pause_count(data = data25[,c(2,5,13)], min_depth = min_d, min_pause = min_p)
#PHp
pause_count(data = data25[,c(2,6,14)], min_depth = min_d, min_pause = min_p)
```


### count pause sites with range = 15
```{r}
setwd("/workdir/users/acv46/EC_PROSeq/pileup")
data15 <- read_delim(file = "coverage_normalized_pausescores2_range15.txt",
                     delim = "\t",
                     col_names = T)
```
```{r}
min_d <- 10
min_p <- 2

# PCm
pause_count(data = data15[,c(2,3,11)], min_depth = min_d, min_pause = min_p)
# PCp
pause_count(data = data15[,c(2,4,12)], min_depth = min_d, min_pause = min_p)
# PHm
pause_count(data = data15[,c(2,5,13)], min_depth = min_d, min_pause = min_p)
#PHp
pause_count(data = data15[,c(2,6,14)], min_depth = min_d, min_pause = min_p)
```

### get pause positions with range = 25, depth >= 5, pause score >= 3
```{r}
setwd("/workdir/users/acv46/EC_PROSeq/pileup")
data25 <- read_delim(file = "coverage_normalized_pausescores_range25.txt",
                     delim = "\t",
                     col_names = T)
```
```{r}
min_d = 10
min_p = 2

# PCm
PCm_psites <- pause_site(data = data25[,c(2,3,11)], min_depth = min_d, min_pause = min_p)
# PCp
PCp_psites <- pause_site(data = data25[,c(2,4,12)], min_depth = min_d, min_pause = min_p)
# PHm
PHm_psites <- pause_site(data = data25[,c(2,5,13)], min_depth = min_d, min_pause = min_p)
#PHp
PHp_psites <- pause_site(data = data25[,c(2,6,14)], min_depth = min_d, min_pause = min_p)

sitelist <- list(PCm_psites$position, PCp_psites$position, PHm_psites$position, PHm_psites$position)

```
```{r}
ranges <- lapply(sitelist, function(x) {
  diffs <- c(1, diff(x))
  start_indexes <- c(1, which(diffs > 1))
  end_indexes <- c(start_indexes - 1, length(x))
  coloned <- paste(x[start_indexes], x[end_indexes], sep=":")
  paste0(coloned, collapse=", ")
})
```
### plot
```{r}
# need covdat_melt data from promoter section

plotrange <- function (pos) {
name <- cov_norm[which(covdat_melt$index == pos & cov_norm$variable == "PRO_control_plus"),]$name
message(name)


picked <- covdat_melt[which(covdat_melt$name == name),]

trace <- ggplot(data = picked) +
  geom_line(mapping = aes(x = index,
                          y = value,
                          color = variable)) +
  theme_classic()

trace
}

```
```{r}
plotrange(1992041)

```



# metagene plots
## load libraries
```{r}
#if (!requireNamespace("BiocManager", quietly = TRUE))
#    install.packages("BiocManager")

#BiocManager::install("metagene2")
#BiocManager::install("regutools")

library(metagene2)
library(regutools)
library(Biostrings)
```

## metagene2 test
```{r}
demo_ranges <- get_demo_rna_regions()
demo_bams <- get_demo_rna_bam_files()
demo_mg <- metagene2$new(regions = demo_ranges, 
                   bam_files = demo_bams, 
                   assay = 'rnaseq',
                   padding = 50)

demo_mg$produce_metagene(title = "Demo metagene plot")
```

## create bam list, all bams
```{r}
# bam files resorted and indexed following 
# create named vector of bam files
setwd("/workdir/users/acv46/EC_PROSeq/proseq2.0/out3/bams/sort")

bams <- c("PC1_dedup_QC_end.sort.bam",
          "PC2_dedup_QC_end.sort.bam",
          "PC3_dedup_QC_end.sort.bam",
          "PH1_dedup_QC_end.sort.bam",
          "PH2_dedup_QC_end.sort.bam",
          "PH3_dedup_QC_end.sort.bam",
          "RCD1_QC_end.sort.bam",
          "RCD2_QC_end.sort.bam",
          "RHD1_QC_end.sort.bam",
          "RHD2_QC_end.sort.bam")
names(bams) <- c("PC1",
          "PC2",
          "PC3",
          "PH1",
          "PH2",
          "PH3",
          "RCD1",
          "RCD2",
          "RHD1",
          "RHD2")

```

## create bam list, just RNA-seq
```{r}
# bam files resorted and indexed following 
# create named vector of bam files
setwd("/workdir/users/acv46/EC_PROSeq/proseq2.0/out3/bams/sort")

bams_r <- c(
          "RCD1_QC_end.sort.bam",
          "RCD2_QC_end.sort.bam",
          "RHD1_QC_end.sort.bam",
          "RHD2_QC_end.sort.bam")
names(bams_r) <- c(
          "RCD1",
          "RCD2",
          "RHD1",
          "RHD2")
  
```

## create bam list, just PRO-seq
```{r}
# bam files resorted and indexed following 
# create named vector of bam files
setwd("/workdir/users/acv46/EC_PROSeq/proseq2.0/out3/bams/sort")

bams_p <- c("PC1_dedup_QC_end.sort.bam",
          "PC2_dedup_QC_end.sort.bam",
          "PC3_dedup_QC_end.sort.bam",
          "PH1_dedup_QC_end.sort.bam",
          "PH2_dedup_QC_end.sort.bam",
          "PH3_dedup_QC_end.sort.bam")
names(bams_p) <- c("PC1",
          "PC2",
          "PC3",
          "PH1",
          "PH2",
          "PH3")
```

## retrieve regulonDB and create GRanges objects
```{r}
## Build a regulondb object
## stores database at /home/acv46/.cache/AnnotationHub
e_coli_regulondb <- regulondb(database_conn = connect_database(),
                              organism = "E.coli",
                              database_version = "10.6",
                              genome_version = "NC_000913.3")

#list_datasets(e_coli_regulondb)
#list_attributes(e_coli_regulondb, dataset = "PROMOTER")

## gene dataset
genes <- get_dataset(regulondb = e_coli_regulondb,
                     dataset = "GENE",
                     attributes = c("posleft", "posright", "strand", "name", "sigma_factor", "operon_name"))
promoters <- get_dataset(regulondb = e_coli_regulondb,
                     dataset = "PROMOTER",
                     attributes = c("tss", "name", "strand", "sigma_factor", "regulated_tu", "regulated_operon"))
operons <- get_dataset(regulondb = e_coli_regulondb,
                     dataset = "OPERON",
                     attributes = c("name","strand", "firstgeneposleft", "lastgeneposright","regulationposleft", "regulationposright",  "sigma_name", "promoter_name", "tf_name"))

## convert to GRanges object and change sequence name to match bam files

genes_ranges <- convert_to_granges(genes)
genes_ranges <- renameSeqlevels(genes_ranges, "NC_000913.3")
#promoters_ranges <- convert_to_granges(promoters)
#promoters_ranges <- renameSeqlevels(promoters_ranges, "NC_000913.3")
ops_ranges <- convert_to_granges(operons)
ops_ranges <- renameSeqlevels(ops_ranges, "NC_000913.3")

dnaK_range <- genes_ranges[which(genes_ranges$operon_name == "dnaK-tpke11-dnaJ")]

ops_sig70_range <- ops_ranges[which(ops_ranges$sigma_name == "Sigma70")]
ops_sig32_range <- ops_ranges[which(ops_ranges$sigma_name == "Sigma32")]

```

## generate metadata table
```{r}

ops_ranges_list <- GRangesList(ops_ranges[which(ops_ranges$sigma_name == "Sigma70")],
            ops_ranges[which(ops_ranges$sigma_name == "Sigma32")],
            ops_ranges[which(ops_ranges$sigma_name == "Sigma54")],
            ops_ranges[which(ops_ranges$sigma_name == "Sigma28")],
            ops_ranges[which(ops_ranges$sigma_name == "Sigma24")])

names(ops_ranges_list) <- c("Sigma70","Sigma32", "Sigma54", "Sigma28", "Sigma24")

ops_meta = data.frame(BedName=names(ops_ranges_list),
                           EvenStart=ifelse((start(ops_ranges_list) %% 2) == 0, "Even", "Odd"),
                           Strand=strand(regions_gr))
head(demo_metadata)
```

## generate metagene object
```{r}
setwd("/workdir/users/acv46/EC_PROSeq/proseq2.0/out3/bams/sort")

get_mgobj <- function(regions, bam_files){
  
  metagene2$new(regions = regions,
                    bam_files = bam_files,
                    padding_size = 0,
                    verbose = T,
                    force_seqlevels = F,
                    paired_end = T,
                    assay = "rnaseq",
                    strand_specific = T,
                    paired_end_strand_mode = 2,
                    region_mode = "separate",
                    region_metadata = NULL,
                    extend_reads = 0,
                    invert_strand = T)

}

#mg <- get_mgobj(genes_ranges, bams, NULL)

mg_r <- get_mgobj(ops_sig32_range, bams_r)
mg_p <- get_mgobj(ops_sig32_range, bams_p)

```

## experiment design
```{r}
design <- data.frame(Samples = bams,
                     align1 = c(1,1,1,0,0,0,0,0,0,0),
                     align2 = c(0,0,0,1,1,1,0,0,0,0),
                     align3 = c(0,0,0,0,0,0,1,1,0,0),
                     align4 = c(0,0,0,0,0,0,0,0,1,1))

design_r <- data.frame(Samples = bams_r,
                     control = c(1,1,0,0),
                     heat_shock = c(0,0,1,1))

design_p <- data.frame(Samples = bams_p,
                     control = c(1,1,1,0,0,0),
                     heat_shock = c(0,0,0,1,1,1))

design_r_meta <- data.frame(design = mg_r$get_design_group_names(),
                       Align=c("Control", "Control", "Heat Shock", "Heat Shock"),
                         Rep=c(1, 2, 1, 2))

design_p_meta <- data.frame(design = mg_p$get_design_group_names(),
                       Align=c("Control", "Control", "Control", "Heat Shock", "Heat Shock", "Heat Shock"),
                         Rep=c(1, 2, 3, 1, 2, 3))
```

## metagene plot, RNA-seq
```{r}
setwd("/workdir/users/acv46/EC_PROSeq/proseq2.0/out3/bams/sort")
p1 <- mg_r$produce_metagene(design = design_r,
                      #design_metadata = design_r_meta,
                      bin_count = 100,
                      normalization = "RPM")

p2 <- mg_p$produce_metagene(design = design_p,
                      #design_metadata = design_p_meta,
                      bin_count = 100,
                      normalization = "RPM")

p1
p2
```

## metagene plot, single regions
```{r}
setwd("/workdir/users/acv46/EC_PROSeq/proseq2.0/out3/bams/sort")

region <- 4
#region <- genes_ranges[which(genes_ranges$name == "dnaK")]
mg_r$plot_single_region(region = region)
```
# Differential expression volcano plots, OPERONS, highlight sigma factors

## BiocManager Installations
```{r}
# Bioconductor installation only works with R 4.0

#if (!requireNamespace("BiocManager", quietly = TRUE))
#    install.packages("BiocManager")
#BiocManager::install(version = "3.11")

#if (!requireNamespace("BiocManager", quietly = TRUE))
#    install.packages("BiocManager")

#BiocManager::install("Rsubread")
#BiocManager::install("BRGenomics")
#BiocManager::install("rtracklayer")
library(Rsubread)
library(rtracklayer)
library(BRGenomics)
#devtools::install_github('kevinblighe/EnhancedVolcano')
library(EnhancedVolcano)
library(regutools)
library(DESeq2)
library(ashr)
```

## create bam list, all bams
```{r}
# bam files resorted and indexed following 
# create named vector of bam files

files <- c("PC1_dedup_QC_end.sort.bam",
          "PC2_dedup_QC_end.sort.bam",
          "PC3_dedup_QC_end.sort.bam",
          "PH1_dedup_QC_end.sort.bam",
          "PH2_dedup_QC_end.sort.bam",
          "PH3_dedup_QC_end.sort.bam",
          "RCD1_QC_end.sort.bam",
          "RCD2_QC_end.sort.bam",
          "RHD1_QC_end.sort.bam",
          "RHD2_QC_end.sort.bam")
filenames <- c("PC1",
          "PC2",
          "PC3",
          "PH1",
          "PH2",
          "PH3",
          "RCD1",
          "RCD2",
          "RHD1",
          "RHD2")
bam_list <- tibble(files, filenames)

```

## retrieve regulonDB and create GRanges objects
```{r}
## Build a regulondb object
## stores database at /home/acv46/.cache/AnnotationHub
e_coli_regulondb_10.9 <- regulondb(database_conn = connect_database(),
                              organism = "E.coli",
                              database_version = "10.9",
                              genome_version = "NC_000913.3")

#list_datasets(e_coli_regulondb)
#list_attributes(e_coli_regulondb, dataset = "PROMOTER")

## datasets
genes <- get_dataset(regulondb = e_coli_regulondb_10.9,
                     dataset = "GENE",
                     attributes = c("posleft", "posright", "strand", "name", "sigma_factor", "operon_name"))
promoters <- get_dataset(regulondb = e_coli_regulondb_10.9,
                     dataset = "PROMOTER",
                     attributes = c("tss", "name", "strand", "sigma_factor", "regulated_tu", "regulated_operon"))
operons <- get_dataset(regulondb = e_coli_regulondb_10.9,
                     dataset = "OPERON",
                     attributes = c("name","strand", "firstgeneposleft", "lastgeneposright","regulationposleft", "regulationposright",  "sigma_name", "promoter_name", "tf_name"))

dna_objects <- get_dataset(e_coli_regulondb_10.9, dataset = "DNA_OBJECTS")
dna_objects <- convert_to_granges(dna_objects)

## convert to GRanges object and change sequence name to match bam files

genes_ranges <- convert_to_granges(genes)
genes_ranges <- renameSeqlevels(genes_ranges, "NC_000913.3")
#promoters_ranges <- convert_to_granges(promoters)
#promoters_ranges <- renameSeqlevels(promoters_ranges, "NC_000913.3")
ops_ranges <- convert_to_granges(operons)
ops_ranges <- renameSeqlevels(ops_ranges, "NC_000913.3")

dnaK_range <- genes_ranges[which(genes_ranges$operon_name == "dnaK-tpke11-dnaJ")]

ops_sig70_range <- ops_ranges[which(ops_ranges$sigma_name == "Sigma70")]
ops_sig32_range <- ops_ranges[which(ops_ranges$sigma_name == "Sigma32")]


```

## export granges objects as gtf
```{r}
setwd("/workdir/users/acv46/EC_PROSeq/proseq2.0/out3/bams/sort")

export(ops_ranges, "operons.gtf")
export(dna_objects, "dna_objects.gtf")
```

## readcounts function using Rsubread::featureCounts
```{r}
readcounts <- function(bam, gtf) {
  
  prof <- featureCounts(files = bam[1], 
                         isPairedEnd = T, 
                         annot.ext = gtf, 
                         isGTFAnnotationFile = T, 
                         GTF.attrType = "name", 
                         requireBothEndsMapped = T, 
                         GTF.featureType = c("sequence_feature")) #c("CDS","exon","gene") 

  counts <- as.data.frame(prof[["counts"]])
  counts <- cbind(rownames(counts), data.frame(counts, row.names = NULL))
  colnames(counts) <- c("operon", bam[2])

  counts[order(counts$operon),]

}

#https://support.bioconductor.org/p/110807/
```

## apply readcounts function (creates list of dataframes as counts results)
```{r}

setwd("/workdir/users/acv46/EC_PROSeq/proseq2.0/out3/bams/sort")

counts <- apply(X = bam_list, MARGIN = 1, readcounts, gtf = "operons.gtf")
names(counts) <- bam_list$filenames

```

## merge and subset data, and load coldata
```{r}

allCounts <- counts %>% purrr::reduce(left_join, by = "operon") %>% na.omit()

# get the subset of operons that contain a Sigma32 recognition site in their regulatory region
HSall <- operons[grepl("Sigma32", operons$sigma_name),]
HSall.labs <- HSall$name

# get the subset of operons that are only under control of Sigma32
HSonly <- operons[which(operons$sigma_name == "Sigma32"),]
HSonly.labs <- HSonly$name

coldata <- read.table(file = "/local/workdir/users/acv46/EC_PROSeq/proseq2.0/out3/coldata_noU",
                      header = T,
                      sep = "\t")

#order of rownames must match order of countData columns
rownames(coldata) <- c(bam_list$filenames)

# create matrix for DESEQ2
countMatrix <- as.matrix(allCounts[,-1])
rownames(countMatrix) <- allCounts[,1]
```

## generate DESeq2 object from counts matrix
```{r}
dds <- DESeqDataSetFromMatrix(countData = countMatrix, colData = coldata, design = ~ condition)
featureData <- data.frame(operon = rownames(countMatrix))
mcols(dds) <- DataFrame(mcols(dds), featureData)
mcols(dds)
dds <- DESeq(dds)
res <- results(dds)
res.data <- as.data.frame(res)

```

## get shrunken log2 fold changes for pairwise analyses of interest
```{r}

LFC <- function(data, condition1, condition2, estimator){
  
  lfcShrink(dds = data, contrast = c("condition", condition1, condition2), type = estimator) %>%
    as.data.frame()
  
}

res_PCvPH <- LFC(dds, "PRO-seq_HeatShock", "PRO-seq_Control", "ashr")
res_RCvRH <- LFC(dds, "RNA-seq_HeatShock", "RNA-seq_Control", "ashr")
res_PCvRC <- LFC(dds, "RNA-seq_Control", "PRO-seq_Control", "ashr")
res_PHvRH <- LFC(dds, "RNA-seq_HeatShock", "PRO-seq_HeatShock", "ashr")

```

## get lists of operons for each sigma group
```{r}

get_oplist <- function(sigma) {
  
  # uses closest_promoters object from Promoter Proximal Coverage section
  
  closest_promoters %>% filter(sigma_factor == sigma) %>% separate(., regulated_operon, into = c("op_id","op_name"), sep = "\t")

}

# classifies all operons by their right-most promoter sequence
s70_list_closest <- get_oplist("Sigma70")
s32_list_closest <- get_oplist("Sigma32")
s24_list_closest <- get_oplist("Sigma24")

# classifies all single-promoter operons
s70_list_single <- ops_sub[ops_sub$sigma_name == "Sigma70",]
s32_list_single <- ops_sub[ops_sub$sigma_name == "Sigma32",]
s24_list_single <- ops_sub[ops_sub$sigma_name == "Sigma24",]
```

## plot volcano function
```{r}

# original plotting function

plotVolcano <- function(res, Title, featuretype, labs = F) {

  #order is important here for proper coloration of groups 

  key.col <- rep('gray', nrow(res))
  names(key.col) <- rep('Other Operons', nrow(res))

  key.col[which(res$log2FoldChange > 3 & res$padj < 1e-100)] <- 'royalblue'
  names(key.col)[which(res$log2FoldChange > 3 & res$padj < 1e-100)] <- '> 8-fold change, P < 1e-100'

  key.col[which(res$log2FoldChange < -3 & res$pvalue < 1e-100)] <- 'royalblue'
  names(key.col)[which(res$log2FoldChange < -3 & res$padj < 1e-100)] <- '> 8-fold change, P < 1e-100'

  key.col[which(rownames(res) %in% HSlabs)] <- 'red'
  names(key.col)[which(rownames(res) %in% HSlabs)] <- 'Sigma32 Operons'

  #key.col[which(rownames(res) %in% NClabs)] <- 'darkgoldenrod2'
  #names(key.col)[which(rownames(res) %in% NClabs)] <- 'ncRNAs'
  
  #templab <- as.data.frame(subset(res, rownames(res) %in% HSlabs))
  
  nm <- deparse(substitute(res))
  
  if (labs) {
    
    labs_edit <- c(rownames(res[(res$log2FoldChange <= -3 | res$log2FoldChange >= 3) & res$padj <= 1e-100,]))
    fname <- paste(nm, featuretype, "padj_flipped_labs.pdf", sep = "_")
    
  } else if (!labs) {
    
    labs_edit <- NA
    fname <- paste(nm, featuretype, "padj_flipped.pdf", sep = "_")
    
  }
  
  #pdf(file = fname, useDingbats = F)
  
  vc1 <- EnhancedVolcano(res,
      lab = rownames(res),
      x = 'log2FoldChange',
      y = 'padj',
      xlim = c(-5, 5),
      title = Title,
      subtitle = featuretype,
      caption = '',
      titleLabSize = 12,
      subtitleLabSize = 10,
      pCutoff = 1e-100,
      FCcutoff = 3,
      cutoffLineType = 'blank',
      #cutoffLineCol = 'blank',
      pointSize = 1,
      labSize = 2.5,
      col=c('black', 'black', 'black', 'royalblue'),
      colAlpha = 1,
      legendPosition = "right",
      legendLabSize = 8,
      legendIconSize = 2.5,
      cutoffLineCol = "black",
      ylim = c(0,100),
      labCol = 'black',
      #labFace = 'bold',
      boxedLabels = T,
      selectLab = labs_edit,
      drawConnectors = T,
      widthConnectors = 0.4,
      colConnectors = "gray50",
      colCustom = key.col)

  print(vc1)

  #dev.off()

}
```

## plot volcano function, modified to create supplemental volcanos for promoter plot
```{r}

# original plotting function

plotVolcano2 <- function(res, sigma_labs, Title, featuretype, labs = F) {
  
  # res1 <- res[-which(rownames(res) %in% sigma_labs),]
  # res2 <- res[which(rownames(res) %in% sigma_labs),]
  # 
  # res_order <- rbind(res2, res1)
  
  res_order <- res[which(rownames(res) %in% sigma_labs),]
  
  key.col <- rep('gray50', nrow(res_order))
  names(key.col) <- rep('Other Operons', nrow(res_order))

  key.col[which(rownames(res_order) %in% sigma_labs)] <- 'red'
  names(key.col)[which(rownames(res_order) %in% sigma_labs)] <- 'Sigma Operons'
  
  nm <- deparse(substitute(res))
  
  if (labs) {
    
    labs_edit <- c(rownames(res_order[(res_order$log2FoldChange <= -3 | res_order$log2FoldChange >= 3) & res_order$padj <= 1e-100,]))
    fname <- paste(nm, featuretype, "padj_flipped_labs.pdf", sep = "_")
    
  } else if (!labs) {
    
    labs_edit <- NA
    fname <- paste(nm, featuretype, "padj_flipped.pdf", sep = "_")
    
  }
  
  #pdf(file = fname, useDingbats = F)
  
  vc1 <- EnhancedVolcano(res_order,
      lab = rownames(res_order),
      x = 'log2FoldChange',
      y = 'padj',
      xlim = c(-5, 5),
      title = Title,
      subtitle = featuretype,
      caption = '',
      titleLabSize = 12,
      subtitleLabSize = 10,
      pCutoff = 1e-100,
      FCcutoff = 3,
      cutoffLineType = 'solid',
      #cutoffLineCol = 'black',
      pointSize = 1,
      labSize = 2.5,
      col=c('black', 'black', 'black', 'royalblue'),
      colAlpha = 1,
      legendPosition = "right",
      legendLabSize = 8,
      legendIconSize = 2.5,
      cutoffLineCol = "black",
      ylim = c(0,100),
      labCol = 'black',
      #labFace = 'bold',
      boxedLabels = T,
      selectLab = labs_edit,
      drawConnectors = T,
      widthConnectors = 0.4,
      colConnectors = "gray50",
      colCustom = key.col,
      gridlines.major = FALSE,
    gridlines.minor = FALSE)

  print(vc1)

  #dev.off()

}
```

## apply plotvolcano function
```{r}
setwd(dir = "/local/workdir/users/acv46/EC_PROSeq/figures/volcano")

#HSlans <- HSonly.labs
HSlabs <- HSall.labs
featuretype <- "Operons"

plotVolcano(res_PCvPH, 'PRO-seq HS v. PRO-seq Control', featuretype, labs = T)
plotVolcano(res_RCvRH, 'RNA-seq HS v. RNA-seq Control', featuretype, labs = T)
plotVolcano(res_PCvRC, 'PRO-seq Control v. RNA-seq Control', featuretype, labs = T)
plotVolcano(res_PHvRH, 'PRO-seq HS v. RNA-seq HS', featuretype, labs = T)
```

## apply plotvolcano2 function
```{r}
setwd(dir = "/local/workdir/users/acv46/EC_PROSeq/figures/volcano")

#HSlabs <- HSall.labs
featuretype <- "Operons"

plotVolcano2(res_RCvRH, s70_list_single$name, 'RNA-seq HS v. RNA-seq Control, s70', featuretype, labs = F)
plotVolcano2(res_RCvRH, s32_list_single$name, 'RNA-seq HS v. RNA-seq Control, s32', featuretype, labs = F)
plotVolcano2(res_RCvRH, s24_list_single$name, 'RNA-seq HS v. RNA-seq Control, s24', featuretype, labs = F)
```

# Differential expression volcano plots, sRNAs

## BiocManager Installations
```{r}
# Bioconductor installation only works with R 4.0

#if (!requireNamespace("BiocManager", quietly = TRUE))
#    install.packages("BiocManager")
#BiocManager::install(version = "3.11")

if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

BiocManager::install("Rsubread")
BiocManager::install("BRGenomics")
BiocManager::install("rtracklayer")
library(Rsubread)
library(rtracklayer)
library(BRGenomics)
devtools::install_github('kevinblighe/EnhancedVolcano')
library(EnhancedVolcano)
library(regutools)
library(DESeq2)
library(ashr)
```

## create bam list, all bams
```{r}
# bam files resorted and indexed following 
# create named vector of bam files

files <- c("PC1_dedup_QC_end.sort.bam",
          "PC2_dedup_QC_end.sort.bam",
          "PC3_dedup_QC_end.sort.bam",
          "PH1_dedup_QC_end.sort.bam",
          "PH2_dedup_QC_end.sort.bam",
          "PH3_dedup_QC_end.sort.bam",
          "RCD1_QC_end.sort.bam",
          "RCD2_QC_end.sort.bam",
          "RHD1_QC_end.sort.bam",
          "RHD2_QC_end.sort.bam")
filenames <- c("PC1",
          "PC2",
          "PC3",
          "PH1",
          "PH2",
          "PH3",
          "RCD1",
          "RCD2",
          "RHD1",
          "RHD2")
bam_list <- tibble(files, filenames)

```

## retrieve regulonDB and create GRanges objects
```{r}
## Build a regulondb object
## stores database at /home/acv46/.cache/AnnotationHub
e_coli_regulondb <- regulondb(database_conn = connect_database(),
                              organism = "E.coli",
                              database_version = "10.6",
                              genome_version = "NC_000913.3")

#list_datasets(e_coli_regulondb)
#list_attributes(e_coli_regulondb, dataset = "PROMOTER")

## datasets

dna_objects <- get_dataset(e_coli_regulondb, dataset = "DNA_OBJECTS") %>%
  convert_to_granges(.) %>%
  renameSeqlevels(., "NC_000913.3")

sRNA_labs <- get_dataset(e_coli_regulondb, dataset = "DNA_OBJECTS")
sRNA_labs <- sRNA_labs[which(sRNA_labs$type == "sRNA interaction"),]
sRNA_labs <- sRNA_labs$name

HSall <- operons[grepl("Sigma32", operons$sigma_name),]
HSall.labs <- HSall$name

```

## export granges objects as gtf
```{r}
setwd("/workdir/users/acv46/EC_PROSeq/proseq2.0/out3/bams/sort")

export(dna_objects, "dna_objects.gtf")

## bash edits

#sed "s/sRNA binds to /(/g" dna_objects.gtf | sed "s/ gene as//g" | sed "s/activator\"/activator)\"/g" | sed "s/repressor\"/repressor)\"/g" | sed "s/ryeA\"/ryeA)\"/g" > dna_objects_sRNA_edit.gtf

# rhyB manually annotated as translational regulator per https://pubmed.ncbi.nlm.nih.gov/20696910/#&gid=article-figures&pid=fig-4-uid-3

#sed "s/sRNA binds to /(/g" dna_objects.gtf | sed "s/ gene as//g" | sed "s/activator\"/activator)\"/g" | sed "s/repressor\"/repressor)\"/g" | sed "s/ryeA\"/ryeA)\"/g" | sed "s/\"\; name \"/ - /g" | sed "s/ryhB (cysE repressor)\"\;/ryhB (cysE repressor)\"\; description \"translational regulation\"/g"> dna_objects_sRNA_edit2.gtf

# gcvB regulation of dppA changed from transcriptional to post-transcriptional, per https://pubmed.ncbi.nlm.nih.gov/18312576/
```

## import manually edited gtf and create labels for plot
```{r}
sRNA_ranges <- rtracklayer::import("/workdir/users/acv46/EC_PROSeq/proseq2.0/out3/bams/sort/dna_objects_sRNA_edit2.gtf")
sRNA_ranges <- sRNA_ranges[sRNA_ranges$type == "sRNA interaction",]

txn <- sRNA_ranges[grepl("post-transcriptional", sRNA_ranges$description),]$id
trl <- sRNA_ranges[grepl("translational", sRNA_ranges$description),]$id
```

## readcounts function using Rsubread::featureCounts
```{r}
readcounts <- function(bam, gtf) {
  
  prof <- featureCounts(files = bam[1], 
                         isPairedEnd = T, 
                         annot.ext = gtf, 
                         isGTFAnnotationFile = T, 
                         GTF.attrType = "id", 
                         requireBothEndsMapped = T, 
                         GTF.featureType = c("sRNA interaction")) #c("CDS","exon","gene") 

  counts <- as.data.frame(prof[["counts"]])
  counts <- cbind(rownames(counts), data.frame(counts, row.names = NULL))
  colnames(counts) <- c("sRNA", bam[2])

  counts[order(counts$sRNA),]

}

#https://support.bioconductor.org/p/110807/
```

## apply readcounts function (creates list of dataframes as counts results)
```{r}

setwd("/workdir/users/acv46/EC_PROSeq/proseq2.0/out3/bams/sort")

counts <- apply(X = bam_list, MARGIN = 1, readcounts, gtf = "dna_objects_sRNA_edit2.gtf")
names(counts) <- bam_list$filenames

```

## merge and subset data, and load coldata
```{r}

allCounts <- counts %>% reduce(left_join, by = "sRNA") %>% na.omit()

coldata <- read.table(file = "/local/workdir/users/acv46/EC_PROSeq/proseq2.0/out3/coldata_noU",
                      header = T,
                      sep = "\t")

#order of rownames must match order of countData columns
rownames(coldata) <- c(bam_list$filenames)

# create matrix for DESEQ2
countMatrix <- as.matrix(allCounts[,-1])
rownames(countMatrix) <- allCounts[,1]
```

## generate DESeq2 object from counts matrix
```{r}
dds <- DESeqDataSetFromMatrix(countData = countMatrix, colData = coldata, design = ~ condition)
featureData <- data.frame(sRNA = rownames(countMatrix))
mcols(dds) <- DataFrame(mcols(dds), featureData)
mcols(dds)
dds <- DESeq(dds)
res <- results(dds)
res.data <- as.data.frame(res)

```

## get shrunken log2 fold changes for pairwise analyses of interest
```{r}

LFC <- function(data, condition1, condition2, estimator){
  
  lfcShrink(dds = data, contrast = c("condition", condition1, condition2), type = estimator) %>%
    as.data.frame()
  
}

res_PCvPH <- LFC(dds, "PRO-seq_HeatShock", "PRO-seq_Control", "ashr")
res_RCvRH <- LFC(dds, "RNA-seq_HeatShock", "RNA-seq_Control", "ashr")
res_PCvRC <- LFC(dds, "RNA-seq_Control", "PRO-seq_Control", "ashr")
res_PHvRH <- LFC(dds, "RNA-seq_HeatShock", "PRO-seq_HeatShock", "ashr")

```

## plot volcano function
```{r}

plotVolcano <- function(res, Title, featuretype, labs = F) {

  #order is important here for proper coloration of groups 

  key.col <- rep('black', nrow(res))
  names(key.col) <- rep('', nrow(res))

  key.col[which(res$log2FoldChange > 2 & res$padj < 1e-5)] <- 'royalblue'
  names(key.col)[which(res$log2FoldChange > 2 & res$padj < 1e-5)] <- '> 8-fold change, P < 1e-100'

  key.col[which(res$log2FoldChange < -2 & res$pvalue < 1e-5)] <- 'royalblue'
  names(key.col)[which(res$log2FoldChange < -2 & res$padj < 1e-5)] <- '> 8-fold change, P < 1e-100'

  key.col[which(rownames(res) %in% txn)] <- 'orange'
  names(key.col)[which(rownames(res) %in% txn)] <- 'Sites of post-transcriptional regulation by sRNA'
  key.col[which(rownames(res) %in% trl)] <- 'blue'
  names(key.col)[which(rownames(res) %in% trl)] <- 'Sites of translational regulation by sRNA'

  #key.col[which(rownames(res) %in% NClabs)] <- 'darkgoldenrod2'
  #names(key.col)[which(rownames(res) %in% NClabs)] <- 'ncRNAs'
  
  #templab <- as.data.frame(subset(res, rownames(res) %in% HSlabs))
  
  nm <- deparse(substitute(res))
  
  if (labs) {
    
    labs_edit <- c(rownames(res[(res$log2FoldChange <= -3 | res$log2FoldChange >= 3) & res$padj <= 1e-100,]))
    fname <- paste(nm, featuretype, "padj_labs.pdf", sep = "_")
    
  } else if (!labs) {
    
    labs_edit <- NA
    fname <- paste(nm, featuretype, "padj.pdf", sep = "_")
    
  }
  
  #pdf(file = fname, useDingbats = F)
  
  vc1 <- EnhancedVolcano(res,
      lab = rownames(res),
      x = 'log2FoldChange',
      y = 'padj',
      xlim = c(-5, 5),
      title = Title,
      subtitle = featuretype,
      caption = '',
      titleLabSize = 12,
      subtitleLabSize = 10,
      pCutoff = 1e-5,
      FCcutoff = 2,
      pointSize = 1,
      labSize = 2.5,
      col=c('black', 'black', 'black', 'royalblue'),
      colAlpha = 1,
      legendPosition = "right",
      legendLabSize = 8,
      legendIconSize = 2.5,
      cutoffLineCol = "black",
      ylim = c(0,15),
      labCol = 'black',
      #labFace = 'bold',
      boxedLabels = T,
      selectLab = labs_edit,
      drawConnectors = T,
      widthConnectors = 0.4,
      colConnectors = "gray50",
      colCustom = key.col)

  print(vc1)

  #dev.off()

}
```

## apply plot volcano function
```{r}
setwd(dir = "/local/workdir/users/acv46/EC_PROSeq/figures/volcano")

#HSlans <- HSonly.labs
featuretype <- "sRNA"

plotVolcano(res_PCvPH, 'PRO-seq HS v. PRO-seq Control', featuretype, labs = T)
plotVolcano(res_RCvRH, 'RNA-seq HS v. RNA-seq Control', featuretype, labs = T)
plotVolcano(res_PCvRC, 'PRO-seq Control v. RNA-seq Control', featuretype, labs = T)
plotVolcano(res_PHvRH, 'PRO-seq HS v. RNA-seq HS', featuretype, labs = T)
```



# Differential expression volcano plots, all DNA objects, highlight RNA types

## BiocManager Installations
```{r}
# Bioconductor installation only works with R 4.0

#if (!requireNamespace("BiocManager", quietly = TRUE))
#    install.packages("BiocManager")
#BiocManager::install(version = "3.11")

if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

BiocManager::install("Rsubread")
BiocManager::install("BRGenomics")
BiocManager::install("rtracklayer")
library(Rsubread)
library(rtracklayer)
library(BRGenomics)
devtools::install_github('kevinblighe/EnhancedVolcano')
library(EnhancedVolcano)
library(regutools)
library(DESeq2)
library(ashr)
```

## create bam list, all bams
```{r}
# bam files resorted and indexed following 
# create named vector of bam files

files <- c("PC1_dedup_QC_end.sort.bam",
          "PC2_dedup_QC_end.sort.bam",
          "PC3_dedup_QC_end.sort.bam",
          "PH1_dedup_QC_end.sort.bam",
          "PH2_dedup_QC_end.sort.bam",
          "PH3_dedup_QC_end.sort.bam",
          "RCD1_QC_end.sort.bam",
          "RCD2_QC_end.sort.bam",
          "RHD1_QC_end.sort.bam",
          "RHD2_QC_end.sort.bam")
filenames <- c("PC1",
          "PC2",
          "PC3",
          "PH1",
          "PH2",
          "PH3",
          "RCD1",
          "RCD2",
          "RHD1",
          "RHD2")
bam_list <- tibble(files, filenames)

```

## retrieve regulonDB and create GRanges objects
```{r}
## Build a regulondb object
## stores database at /home/acv46/.cache/AnnotationHub
e_coli_regulondb_10.9 <- regulondb(database_conn = connect_database(),
                              organism = "E.coli",
                              database_version = "10.9",
                              genome_version = "NC_000913.3")

#list_datasets(e_coli_regulondb)
#list_attributes(e_coli_regulondb, dataset = "PROMOTER")

## datasets

genes <- get_dataset(e_coli_regulondb_10.9, 
                     dataset = "GENE") %>%
  convert_to_granges(.) %>%
  renameSeqlevels(., "NC_000913.3")


# Subread doesn't work with some combinations of attribute names
genes_sub <- get_dataset(e_coli_regulondb_10.9, 
                     dataset = "GENE",
                     attributes = c("posleft", "posright", "strand", "name", "sigma_factor", "operon_name", "id")) %>%
  convert_to_granges(.) %>%
  renameSeqlevels(., "NC_000913.3")

```

## export granges objects as gtf
```{r}
setwd("/workdir/users/acv46/EC_PROSeq/proseq2.0/out3/bams/sort")

export(genes_sub, "genes.gtf")

## bash edits

#sed "s/sRNA binds to /(/g" dna_objects.gtf | sed "s/ gene as//g" | sed "s/activator\"/activator)\"/g" | sed "s/repressor\"/repressor)\"/g" | sed "s/ryeA\"/ryeA)\"/g" > dna_objects_sRNA_edit.gtf

# rhyB manually annotated as translational regulator per https://pubmed.ncbi.nlm.nih.gov/20696910/#&gid=article-figures&pid=fig-4-uid-3

#sed "s/sRNA binds to /(/g" dna_objects.gtf | sed "s/ gene as//g" | sed "s/activator\"/activator)\"/g" | sed "s/repressor\"/repressor)\"/g" | sed "s/ryeA\"/ryeA)\"/g" | sed "s/\"\; name \"/ - /g" | sed "s/ryhB (cysE repressor)\"\;/ryhB (cysE repressor)\"\; description \"translational regulation\"/g"> dna_objects_sRNA_edit2.gtf

# gcvB regulation of dppA changed from transcriptional to post-transcriptional, per https://pubmed.ncbi.nlm.nih.gov/18312576/
```

## import manually edited gtf and create labels for plot
```{r}
rRNA <- genes[which(genes$product_type == "rRNA"),]$id
tRNA <- genes[which(genes$product_type == "tRNAs"),]$id
sRNA <- genes[which(genes$product_type == "small RNA"),]$id
```

## readcounts function using Rsubread::featureCounts
```{r}
readcounts <- function(bam, gtf) {
  
  prof <- featureCounts(files = bam[1], 
                         isPairedEnd = T, 
                         annot.ext = gtf, 
                         isGTFAnnotationFile = T, 
                         GTF.attrType = "id", 
                         requireBothEndsMapped = T, 
                         GTF.featureType = c("sequence_feature")) #c("CDS","exon","gene") 

  counts <- as.data.frame(prof[["counts"]])
  counts <- cbind(rownames(counts), data.frame(counts, row.names = NULL))
  colnames(counts) <- c("id", bam[2])

  counts[order(counts$id),]

}

#https://support.bioconductor.org/p/110807/
```

## apply readcounts function (creates list of dataframes as counts results)
```{r}

setwd("/workdir/users/acv46/EC_PROSeq/proseq2.0/out3/bams/sort")

counts <- apply(X = bam_list, MARGIN = 1, readcounts, gtf = "genes.gtf")
names(counts) <- bam_list$filenames

```

## merge and subset data, and load coldata
```{r}

allCounts <- counts %>% reduce(left_join, by = "id") %>% na.omit()

coldata <- read.table(file = "/local/workdir/users/acv46/EC_PROSeq/proseq2.0/out3/coldata_noU",
                      header = T,
                      sep = "\t")

#order of rownames must match order of countData columns
rownames(coldata) <- c(bam_list$filenames)

# create matrix for DESEQ2
countMatrix <- as.matrix(allCounts[,-1])
rownames(countMatrix) <- allCounts[,1]
```

## generate DESeq2 object from counts matrix
```{r}
dds <- DESeqDataSetFromMatrix(countData = countMatrix, colData = coldata, design = ~ condition)
featureData <- data.frame(sRNA = rownames(countMatrix))
mcols(dds) <- DataFrame(mcols(dds), featureData)
mcols(dds)
dds <- DESeq(dds)
res <- results(dds)
res.data <- as.data.frame(res)

```

## get shrunken log2 fold changes for pairwise analyses of interest
```{r}

LFC <- function(data, condition1, condition2, estimator){
  
  lfcShrink(dds = data, contrast = c("condition", condition1, condition2), type = estimator) %>%
    as.data.frame()
  
}

res_PCvPH <- LFC(dds, "PRO-seq_HeatShock", "PRO-seq_Control", "ashr")
res_RCvRH <- LFC(dds, "RNA-seq_HeatShock", "RNA-seq_Control", "ashr")
res_PCvRC <- LFC(dds, "RNA-seq_Control", "PRO-seq_Control", "ashr")
res_PHvRH <- LFC(dds, "RNA-seq_HeatShock", "PRO-seq_HeatShock", "ashr")

```

## plot volcano function
```{r}

plotVolcano <- function(res, Title, featuretype, labs = F) {

  #order is important here for proper coloration of groups 

  key.col <- rep('gray30', nrow(res))
  names(key.col) <- rep('protein-coding genes', nrow(res))

  #key.col[which(res$log2FoldChange > 2 & res$padj < 1e-5)] <- 'royalblue'
  #names(key.col)[which(res$log2FoldChange > 2 & res$padj < 1e-5)] <- '> 8-fold change, P < 1e-100'

  #key.col[which(res$log2FoldChange < -2 & res$pvalue < 1e-5)] <- 'royalblue'
  #names(key.col)[which(res$log2FoldChange < -2 & res$padj < 1e-5)] <- '> 8-fold change, P < 1e-100'
  
  # reorder res so that all "genes" are plotted first
  # rRNA, tRNA, sRNA dataframes from above
  
  second <- res[which(rownames(res) %in% rRNA | rownames(res) %in% tRNA | rownames(res) %in% sRNA),]
  first <- res[-which(rownames(res) %in% rRNA | rownames(res) %in% tRNA | rownames(res) %in% sRNA),]
  
  res_ordered <- rbind(first, second)
  
  key.col[which(rownames(res_ordered) %in% rRNA)] <- '#1b9e77'
  names(key.col)[which(rownames(res_ordered) %in% rRNA)] <- 'rRNAs'
  key.col[which(rownames(res_ordered) %in% tRNA)] <- '#d95f02'
  names(key.col)[which(rownames(res_ordered) %in% tRNA)] <- 'tRNAs'
  key.col[which(rownames(res_ordered) %in% sRNA)] <- '#7570b3'
  names(key.col)[which(rownames(res_ordered) %in% sRNA)] <- 'sRNAs'

  #key.col[which(rownames(res) %in% NClabs)] <- 'darkgoldenrod2'
  #names(key.col)[which(rownames(res) %in% NClabs)] <- 'ncRNAs'
  
  #templab <- as.data.frame(subset(res, rownames(res) %in% HSlabs))
  
  nm <- deparse(substitute(res))
  
  if (labs) {
    
    labs_edit <- c(rownames(res_ordered[(res_ordered$log2FoldChange <= -3 | res_ordered$log2FoldChange >= 3) & res_ordered$padj <= 1e-100,]))
    fname <- paste(nm, featuretype, "padj_labs.pdf", sep = "_")
    
  } else if (!labs) {
    
    labs_edit <- NA
    fname <- paste(nm, featuretype, "padj.pdf", sep = "_")
    
  }
  
  pdf(file = fname, useDingbats = F)
  
  vc1 <- EnhancedVolcano(res_ordered,
      lab = rownames(res_ordered),
      x = 'log2FoldChange',
      y = 'padj',
      xlim = c(-5, 5),
      title = Title,
      subtitle = featuretype,
      caption = '',
      titleLabSize = 12,
      subtitleLabSize = 10,
      pCutoff = 1e-100,
      FCcutoff = 3,
      pointSize = c(ifelse(rownames(res_ordered) %in% rownames(second), 2, 1)),
      labSize = 2.5,
      col = c('black', 'black', 'black', 'royalblue'),
      colAlpha = 0.5,
      legendPosition = "right",
      legendLabSize = 8,
      legendIconSize = 2.5,
      cutoffLineCol = "black",
      ylim = c(0,250),
      labCol = 'black',
      #labFace = 'bold',
      boxedLabels = T,
      selectLab = labs_edit,
      drawConnectors = T,
      widthConnectors = 0.4,
      colConnectors = "gray60",
      colCustom = key.col)

  print(vc1)

  dev.off()

}
```

## apply plot volcano function
```{r}
setwd(dir = "/local/workdir/users/acv46/EC_PROSeq/figures/volcano")

#HSlans <- HSonly.labs
featuretype <- "Genes"

plotVolcano(res_PCvPH, 'PRO-seq HS v. PRO-seq Control', featuretype, labs = F)
plotVolcano(res_RCvRH, 'RNA-seq HS v. RNA-seq Control', featuretype, labs = F)
plotVolcano(res_PCvRC, 'PRO-seq Control v. RNA-seq Control', featuretype, labs = F)
plotVolcano(res_PHvRH, 'PRO-seq HS v. RNA-seq HS', featuretype, labs = F)
```

# Differential expression volcano plots, all DNA objects, highlight sigma factors

## BiocManager Installations
```{r}
# Bioconductor installation only works with R 4.0

#if (!requireNamespace("BiocManager", quietly = TRUE))
#    install.packages("BiocManager")
#BiocManager::install(version = "3.11")

if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

BiocManager::install("Rsubread")
BiocManager::install("BRGenomics")
BiocManager::install("rtracklayer")
library(Rsubread)
library(rtracklayer)
library(BRGenomics)
devtools::install_github('kevinblighe/EnhancedVolcano')
library(EnhancedVolcano)
library(regutools)
library(DESeq2)
library(ashr)
```

## create bam list, all bams
```{r}
# bam files resorted and indexed following 
# create named vector of bam files

files <- c("PC1_dedup_QC_end.sort.bam",
          "PC2_dedup_QC_end.sort.bam",
          "PC3_dedup_QC_end.sort.bam",
          "PH1_dedup_QC_end.sort.bam",
          "PH2_dedup_QC_end.sort.bam",
          "PH3_dedup_QC_end.sort.bam",
          "RCD1_QC_end.sort.bam",
          "RCD2_QC_end.sort.bam",
          "RHD1_QC_end.sort.bam",
          "RHD2_QC_end.sort.bam")
filenames <- c("PC1",
          "PC2",
          "PC3",
          "PH1",
          "PH2",
          "PH3",
          "RCD1",
          "RCD2",
          "RHD1",
          "RHD2")
bam_list <- tibble(files, filenames)

```

## retrieve regulonDB and create GRanges objects
```{r}
## Build a regulondb object
## stores database at /home/acv46/.cache/AnnotationHub
e_coli_regulondb_10.9 <- regulondb(database_conn = connect_database(),
                              organism = "E.coli",
                              database_version = "10.9",
                              genome_version = "NC_000913.3")

#list_datasets(e_coli_regulondb)
#list_attributes(e_coli_regulondb, dataset = "PROMOTER")

## datasets

genes <- get_dataset(e_coli_regulondb_10.9, 
                     dataset = "GENE") %>%
  convert_to_granges(.) %>%
  renameSeqlevels(., "NC_000913.3")


# Subread doesn't work with some combinations of attribute names
genes_sub <- get_dataset(e_coli_regulondb_10.9, 
                     dataset = "GENE",
                     attributes = c("posleft", "posright", "strand", "name", "sigma_factor", "operon_name", "id")) %>%
  convert_to_granges(.) %>%
  renameSeqlevels(., "NC_000913.3")

```

## export granges objects as gtf
```{r}
setwd("/workdir/users/acv46/EC_PROSeq/proseq2.0/out3/bams/sort")

export(genes_sub, "genes.gtf")

## bash edits

#sed "s/sRNA binds to /(/g" dna_objects.gtf | sed "s/ gene as//g" | sed "s/activator\"/activator)\"/g" | sed "s/repressor\"/repressor)\"/g" | sed "s/ryeA\"/ryeA)\"/g" > dna_objects_sRNA_edit.gtf

# rhyB manually annotated as translational regulator per https://pubmed.ncbi.nlm.nih.gov/20696910/#&gid=article-figures&pid=fig-4-uid-3

#sed "s/sRNA binds to /(/g" dna_objects.gtf | sed "s/ gene as//g" | sed "s/activator\"/activator)\"/g" | sed "s/repressor\"/repressor)\"/g" | sed "s/ryeA\"/ryeA)\"/g" | sed "s/\"\; name \"/ - /g" | sed "s/ryhB (cysE repressor)\"\;/ryhB (cysE repressor)\"\; description \"translational regulation\"/g"> dna_objects_sRNA_edit2.gtf

# gcvB regulation of dppA changed from transcriptional to post-transcriptional, per https://pubmed.ncbi.nlm.nih.gov/18312576/
```

## single sigma groups
```{r}
# 1719 objects under control of a single sigma factor
# 392 objects under control of multiple sigma factors
# 2472 objects "NA"

s38 <- genes[which(genes$sigma_factor == "Sigma38"),]
s32 <- genes[which(genes$sigma_factor == "Sigma32"),]
s70 <- genes[which(genes$sigma_factor == "Sigma70"),]
s28 <- genes[which(genes$sigma_factor == "Sigma28"),]
s24 <- genes[which(genes$sigma_factor == "Sigma24"),]
s54 <- genes[which(genes$sigma_factor == "Sigma54"),]
single <- c(s28,s32,s24,s54,s38,s70)

combo_single <- granges(single, use.mcols = T)
```

## readcounts function using Rsubread::featureCounts
```{r}
readcounts <- function(bam, gtf) {
  
  prof <- featureCounts(files = bam[1], 
                         isPairedEnd = T, 
                         annot.ext = gtf, 
                         isGTFAnnotationFile = T, 
                         GTF.attrType = "id", 
                         requireBothEndsMapped = T, 
                         GTF.featureType = c("sequence_feature")) #c("CDS","exon","gene") 

  counts <- as.data.frame(prof[["counts"]])
  counts <- cbind(rownames(counts), data.frame(counts, row.names = NULL))
  colnames(counts) <- c("id", bam[2])

  counts[order(counts$id),]

}

#https://support.bioconductor.org/p/110807/
```

## apply readcounts function (creates list of dataframes as counts results)
```{r}

setwd("/workdir/users/acv46/EC_PROSeq/proseq2.0/out3/bams/sort")

counts <- apply(X = bam_list, MARGIN = 1, readcounts, gtf = "genes.gtf")
names(counts) <- bam_list$filenames

```

## merge and subset data, and load coldata
```{r}

allCounts <- counts %>% reduce(left_join, by = "id") %>% na.omit()

coldata <- read.table(file = "/local/workdir/users/acv46/EC_PROSeq/proseq2.0/out3/coldata_noU",
                      header = T,
                      sep = "\t")

#order of rownames must match order of countData columns
rownames(coldata) <- c(bam_list$filenames)

# create matrix for DESEQ2
countMatrix <- as.matrix(allCounts[,-1])
rownames(countMatrix) <- allCounts[,1]
```

## generate DESeq2 object from counts matrix
```{r}
dds <- DESeqDataSetFromMatrix(countData = countMatrix, colData = coldata, design = ~ condition)
featureData <- data.frame(sRNA = rownames(countMatrix))
mcols(dds) <- DataFrame(mcols(dds), featureData)
mcols(dds)
dds <- DESeq(dds)
res <- results(dds)
res.data <- as.data.frame(res)

```

## get shrunken log2 fold changes for pairwise analyses of interest
```{r}

LFC <- function(data, condition1, condition2, estimator){
  
  lfcShrink(dds = data, contrast = c("condition", condition1, condition2), type = estimator) %>%
    as.data.frame()
  
}

res_PCvPH <- LFC(dds, "PRO-seq_HeatShock", "PRO-seq_Control", "ashr")
res_RCvRH <- LFC(dds, "RNA-seq_HeatShock", "RNA-seq_Control", "ashr")
res_PCvRC <- LFC(dds, "RNA-seq_Control", "PRO-seq_Control", "ashr")
res_PHvRH <- LFC(dds, "RNA-seq_HeatShock", "PRO-seq_HeatShock", "ashr")

```

## plot volcano function
```{r}

plotVolcano <- function(res, Title, featuretype, labs = F) {

  #order is important here for proper coloration of groups 
  
  pal <- c("#56a3a6","#ffc857","#e9724c","#c5283d","#4e4187","#d30c7b","#6eeb83")

  key.col <- rep('gray30', nrow(res))
  names(key.col) <- rep('unannotated', nrow(res))

  #key.col[which(res$log2FoldChange > 2 & res$padj < 1e-5)] <- 'royalblue'
  #names(key.col)[which(res$log2FoldChange > 2 & res$padj < 1e-5)] <- '> 8-fold change, P < 1e-100'

  #key.col[which(res$log2FoldChange < -2 & res$pvalue < 1e-5)] <- 'royalblue'
  #names(key.col)[which(res$log2FoldChange < -2 & res$padj < 1e-5)] <- '> 8-fold change, P < 1e-100'
  
  # reorder res so that all "genes" are plotted first
  # rRNA, tRNA, sRNA dataframes from above
  
  first <- res[-which(rownames(res) %in% combo_single$id),]
  second <- res[which(rownames(res) %in% combo_single$id),]
  
  res_ordered <- rbind(first, second)
  
  key.col[which(rownames(res_ordered) %in% s38$id)] <- pal[1]
  names(key.col)[which(rownames(res_ordered) %in% s38$id)] <- 'sigma38'
  key.col[which(rownames(res_ordered) %in% s32$id)] <- pal[2]
  names(key.col)[which(rownames(res_ordered) %in% s32$id)] <- 'sigma32'
  key.col[which(rownames(res_ordered) %in% s70$id)] <- pal[3]
  names(key.col)[which(rownames(res_ordered) %in% s70$id)] <- 'sigma70'
  key.col[which(rownames(res_ordered) %in% s28$id)] <- pal[4]
  names(key.col)[which(rownames(res_ordered) %in% s28$id)] <- 'sigma28'
  key.col[which(rownames(res_ordered) %in% s24$id)] <- pal[5]
  names(key.col)[which(rownames(res_ordered) %in% s24$id)] <- 'sigma24'
  key.col[which(rownames(res_ordered) %in% s54$id)] <- pal[6]
  names(key.col)[which(rownames(res_ordered) %in% s54$id)] <- 'sigma54'
  key.col[which(rownames(res_ordered) %in% genes[is.na(genes$sigma_factor)]$id)] <- pal[7]
  names(key.col)[which(rownames(res_ordered) %in% genes[is.na(genes$sigma_factor)]$id)] <- 'sigma38'

  #key.col[which(rownames(res) %in% NClabs)] <- 'darkgoldenrod2'
  #names(key.col)[which(rownames(res) %in% NClabs)] <- 'ncRNAs'
  
  #templab <- as.data.frame(subset(res, rownames(res) %in% HSlabs))
  
  nm <- deparse(substitute(res))
  
  if (labs) {
    
    labs_edit <- c(rownames(res_ordered[(res_ordered$log2FoldChange <= -3 | res_ordered$log2FoldChange >= 3) & res_ordered$padj <= 1e-100,]))
    fname <- paste(nm, featuretype, "padj_bysigma_labs.png", sep = "_")
    
  } else if (!labs) {
    
    labs_edit <- NA
    fname <- paste(nm, featuretype, "padj_bysigma.png", sep = "_")
    
  }
  
  png(file = fname, res = 600, width = 8, height = 6)
  
  vc1 <- EnhancedVolcano(res_ordered,
      lab = rownames(res_ordered),
      x = 'log2FoldChange',
      y = 'padj',
      xlim = c(-5, 5),
      title = Title,
      subtitle = featuretype,
      caption = '',
      titleLabSize = 12,
      subtitleLabSize = 10,
      pCutoff = 1e-100,
      FCcutoff = 3,
      pointSize = c(ifelse(rownames(res_ordered) %in% rownames(second), 2, 1)),
      labSize = 2.5,
      col = c('black', 'black', 'black', 'royalblue'),
      colAlpha = 0.5,
      legendPosition = "right",
      legendLabSize = 8,
      legendIconSize = 2.5,
      cutoffLineCol = "black",
      ylim = c(0,200),
      labCol = 'black',
      #labFace = 'bold',
      boxedLabels = T,
      selectLab = labs_edit,
      drawConnectors = T,
      widthConnectors = 0.4,
      colConnectors = "gray60",
      colCustom = key.col)

  print(vc1)

  dev.off()

}
```

## apply plot volcano function
```{r}
setwd(dir = "/local/workdir/users/acv46/EC_PROSeq/figures/volcano")

#HSlans <- HSonly.labs
featuretype <- "Genes"

plotVolcano(res_PCvPH, 'PRO-seq HS v. PRO-seq Control', featuretype, labs = F)
plotVolcano(res_RCvRH, 'RNA-seq HS v. RNA-seq Control', featuretype, labs = F)
plotVolcano(res_PCvRC, 'PRO-seq Control v. RNA-seq Control', featuretype, labs = F)
plotVolcano(res_PHvRH, 'PRO-seq HS v. RNA-seq HS', featuretype, labs = F)
```

# rRNA abundance plot

## BiocManager Installations
```{r}
# Bioconductor installation only works with R 4.0

#if (!requireNamespace("BiocManager", quietly = TRUE))
#    install.packages("BiocManager")
#BiocManager::install(version = "3.11")

if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

BiocManager::install("Rsubread")
#BiocManager::install("BRGenomics")
#BiocManager::install("rtracklayer")
library(Rsubread)
library(rtracklayer)
library(BRGenomics)
#devtools::install_github('kevinblighe/EnhancedVolcano')
#library(EnhancedVolcano)
library(regutools)
library(DESeq2)
#library(ashr)
library(tidyverse)
```

## create bam list, all bams
```{r}
# bam files resorted and indexed following 
# create named vector of bam files

files <- c("PC1_dedup_QC_end.sort.bam",
          "PC2_dedup_QC_end.sort.bam",
          "PC3_dedup_QC_end.sort.bam",
          "PH1_dedup_QC_end.sort.bam",
          "PH2_dedup_QC_end.sort.bam",
          "PH3_dedup_QC_end.sort.bam",
          "RCD1_QC_end.sort.bam",
          "RCD2_QC_end.sort.bam",
          "RHD1_QC_end.sort.bam",
          "RHD2_QC_end.sort.bam",
          "RCU1_QC_end.sort.bam",
          "RCU2_QC_end.sort.bam",
          "RHU1_QC_end.sort.bam",
          "RHU2_QC_end.sort.bam")
filenames <- c("PC1",
          "PC2",
          "PC3",
          "PH1",
          "PH2",
          "PH3",
          "RCD1",
          "RCD2",
          "RHD1",
          "RHD2",
          "RCU1",
          "RCU2",
          "RHU1",
          "RHU2")
bam_list <- tibble(files, filenames)

```

## retrieve regulonDB and create GRanges objects
```{r}
## Build a regulondb object
## stores database at /home/acv46/.cache/AnnotationHub
e_coli_regulondb_10.9 <- regulondb(database_conn = connect_database(),
                              organism = "E.coli",
                              database_version = "10.9",
                              genome_version = "NC_000913.3")

#list_datasets(e_coli_regulondb)
#list_attributes(e_coli_regulondb, dataset = "PROMOTER")

## datasets

genes <- get_dataset(e_coli_regulondb_10.9, 
                     dataset = "GENE") %>%
  convert_to_granges(.) %>%
  renameSeqlevels(., "NC_000913.3")


# Subread doesn't work with some combinations of attribute names
genes_sub <- get_dataset(e_coli_regulondb_10.9, 
                     dataset = "GENE",
                     attributes = c("posleft", "posright", "strand", "name", "sigma_factor", "operon_name", "id")) %>%
  convert_to_granges(.) %>%
  renameSeqlevels(., "NC_000913.3")

rRNA <- genes[which(genes$product_type == "rRNA"),]
```

## export granges objects as gtf
```{r}
setwd("/workdir/users/acv46/EC_PROSeq/proseq2.0/out3/bams/sort")

export(genes_sub, "genes.gtf")

## bash edits

#sed "s/sRNA binds to /(/g" dna_objects.gtf | sed "s/ gene as//g" | sed "s/activator\"/activator)\"/g" | sed "s/repressor\"/repressor)\"/g" | sed "s/ryeA\"/ryeA)\"/g" > dna_objects_sRNA_edit.gtf

# rhyB manually annotated as translational regulator per https://pubmed.ncbi.nlm.nih.gov/20696910/#&gid=article-figures&pid=fig-4-uid-3

#sed "s/sRNA binds to /(/g" dna_objects.gtf | sed "s/ gene as//g" | sed "s/activator\"/activator)\"/g" | sed "s/repressor\"/repressor)\"/g" | sed "s/ryeA\"/ryeA)\"/g" | sed "s/\"\; name \"/ - /g" | sed "s/ryhB (cysE repressor)\"\;/ryhB (cysE repressor)\"\; description \"translational regulation\"/g"> dna_objects_sRNA_edit2.gtf

# gcvB regulation of dppA changed from transcriptional to post-transcriptional, per https://pubmed.ncbi.nlm.nih.gov/18312576/
```

## readcounts function using Rsubread::featureCounts
```{r}
readcounts <- function(bam, gtf) {
  
  prof <- featureCounts(files = bam[1], 
                         isPairedEnd = T, 
                         annot.ext = gtf, 
                         isGTFAnnotationFile = T, 
                         GTF.attrType = "id", 
                         requireBothEndsMapped = T, 
                         GTF.featureType = c("sequence_feature")) #c("CDS","exon","gene") 

  counts <- as.data.frame(prof[["counts"]])
  counts <- cbind(rownames(counts), data.frame(counts, row.names = NULL))
  colnames(counts) <- c("id", bam[2])

  counts[order(counts$id),]

}

#https://support.bioconductor.org/p/110807/
```

## apply readcounts function (creates list of dataframes as counts results)
```{r}

setwd("/workdir/users/acv46/EC_PROSeq/proseq2.0/out3/bams/sort")

counts <- apply(X = bam_list, MARGIN = 1, readcounts, gtf = "genes.gtf")
names(counts) <- bam_list$filenames

```

## merge and subset data, and load coldata
```{r}

allCounts <- counts %>% purrr::reduce(left_join, by = "id") %>% na.omit()

coldata <- read.table(file = "/local/workdir/users/acv46/EC_PROSeq/proseq2.0/out3/coldata",
                      header = T,
                      sep = "\t")

#order of rownames must match order of countData columns
coldata$sample <- c(bam_list$filenames)


```

## subset for rRNA data
```{r}
rRNA_counts <- allCounts[which(allCounts$id %in% rRNA$id),]
rRNA_counts$name <- rRNA$name[match(rRNA_counts$id, rRNA$id)]
rRNA_counts$type <- rRNA$product_name[match(rRNA_counts$id, rRNA$id)]
rRNA_counts <- rRNA_counts[,-1]

rRNA_counts$PC1 <- rRNA_counts$PC1 / sum(allCounts$PC1) * 10^2 #+0.001
rRNA_counts$PC2 <- rRNA_counts$PC2 / sum(allCounts$PC2) * 10^2 #+0.001
rRNA_counts$PC3 <- rRNA_counts$PC3 / sum(allCounts$PC3) * 10^2 #+0.001
rRNA_counts$PH1 <- rRNA_counts$PH1 / sum(allCounts$PH1) * 10^2 #+0.001
rRNA_counts$PH2 <- rRNA_counts$PH2 / sum(allCounts$PH2) * 10^2 #+0.001
rRNA_counts$PH3 <- rRNA_counts$PH3 / sum(allCounts$PH3) * 10^2 #+0.001
rRNA_counts$RCD1 <- rRNA_counts$RCD1 / sum(allCounts$RCD1) * 10^2 #+0.001
rRNA_counts$RCD2 <- rRNA_counts$RCD2 / sum(allCounts$RCD2) * 10^2 #+0.001
rRNA_counts$RHD1 <- rRNA_counts$RHD1 / sum(allCounts$RHD1) * 10^2 #+0.001
rRNA_counts$RHD2 <- rRNA_counts$RHD2 / sum(allCounts$RHD2) * 10^2 #+0.001
rRNA_counts$RCU1 <- rRNA_counts$RCU1 / sum(allCounts$RCU1) * 10^2 #+0.001
rRNA_counts$RCU2 <- rRNA_counts$RCU2 / sum(allCounts$RCU2) * 10^2 #+0.001
rRNA_counts$RHU1 <- rRNA_counts$RHU1 / sum(allCounts$RHU1) * 10^2 #+0.001
rRNA_counts$RHU2 <- rRNA_counts$RHU2 / sum(allCounts$RHU2) * 10^2 #+0.001

rRNA_counts <- pivot_longer(rRNA_counts, !c(name,type), names_to = "sample", values_to = "count")

get_condition <- function(x) {
  
  # x is a row in the rRNA_counts dataframe
  
  coldata$condition[which(coldata$sample == x[3])]
  
}

rRNA_counts$condition <- apply(X = rRNA_counts, MARGIN = 1, FUN = get_condition) %>% purrr::as_vector()
rRNA_counts_simp <- rRNA_counts[,c(2,3,4,5)] %>% dplyr::group_by(type,condition,sample) %>% summarise(sum = sum(count))

rRNA_counts_simp$condition <- factor(rRNA_counts_simp$condition, levels = c("PC","PH","RCD","RHD","RCU","RHU"))

#part1 <- rRNA_counts_simp[grep("^P", rRNA_counts_simp$condition),]
#part2 <- rRNA_counts_simp[grep("R*D$", rRNA_counts_simp$condition),]
#part3 <- rRNA_counts_simp[grep("R*U$", rRNA_counts_simp$condition),]

#rRNA_counts_simp <- rbind(part1, part2, part3)

```

### summary numbers for text
```{r}
# segregate by treatment
rRNA_counts %>%
  group_by(sample) %>%
  mutate(grpsum = sum(count)) %>%
  ungroup() %>%
  select(sample,grpsum,condition) %>%
  unique() %>%
  group_by(condition) %>%
  mutate(mean = mean(grpsum)) %>%
  mutate(sd = stats::sd(grpsum)) %>%
  select(condition, mean, sd) %>%
  unique()

# combine treatments
rRNA_counts %>%
  group_by(sample) %>%
  mutate(grpsum = sum(count)) %>%
  ungroup() %>%
  mutate(type = ifelse(grepl("P",condition), "PRO-seq",
                       ifelse(grepl("D", sample), "RNAseqD", "RNAseqU"))) %>%
  select(type, grpsum) %>%
  group_by(type) %>%
  mutate(mean = mean(grpsum)) %>%
  mutate(sd = stats::sd(grpsum)) %>%
  ungroup() %>%
  select(type, mean, sd) %>%
  unique()
```

## plot composite
```{r}
#library(ggplot2)
#library(scales)

pal <- c("#E69F00FF","#D55E00FF","#56B4E9FF","#0072B2FF","#9A969C","#48454A")

plain <- function(x,...) {
  format(x, ..., scientific = FALSE, drop0trailing = TRUE)
}

rc <- ggplot(data = rRNA_counts_simp,
             mapping = aes(x = type,
                           fill = condition,
                           y = sum)) +
  geom_dotplot(binaxis = "y",
               stackdir = "center",
               position = "dodge",
               dotsize = 0.75) +
  # scale_y_continuous(breaks = seq(0,100,10),
  #                    labels = seq(0,100,10)) +
  scale_y_log10(labels = plain,
                breaks = c(1 %o% 10^(-3:2))) +
  theme_classic() +
  theme(axis.text.x = element_text(size = 12),
        axis.text.y = element_text(size = 12)) +
  scale_x_discrete(labels = c("16S rRNA","23S rRNA","5S rRNA")) +
  scale_fill_manual(values = pal, name = "Condition") +
  #scale_color_manual(values = pal, name = "Condition") +
  ylab("Library Percent") +
  xlab("") +
  geom_vline(xintercept = 1.5) +
  geom_vline(xintercept = 2.5) +
  geom_vline(xintercept = 3.5)

rc <- rc + annotation_logticks(sides = "l") 

rc
```

### ggsave
```{r}
#library(svglite)
setwd("/workdir/users/acv46/EC_PROSeq/figures/rRNA")
ggsave(filename = "rRNA_percent_v4_blackOutline.svg",
       plot = rc,
       device = "svg",
       dpi = 600,
       width = 5,
       height = 3.5)
ggsave(filename = "rRNA_percent_v4_blackOutline.pdf",
       plot = rc,
       device = "pdf",
       dpi = 600,
       width = 5,
       height = 3.5,
       useDingbats = F)

```

# tRNA abundance, enricment, and processing
## read in coverage data (from "Pause Sites, take 2")
```{r}
coverage <- read_csv("/workdir/users/acv46/EC_PROSeq/pileup/iter_correct/all_coverage_formatted.txt")
# flip orintation of plus and minus, just for fun
# 3' and 5' ends must also be flipped for correct orientation
# get normalized values by grouping lib types
## normalize based on full coverage values
coverage <- coverage %>% mutate(strand1 = ifelse(strand == "plus", "minus", "plus")) %>%
  select(-strand) %>% dplyr::rename(strand = strand1) %>%
  mutate(end1 = ifelse(end == "3", "5", ifelse(end == "5", "3", "full"))) %>%
  select(-end) %>% dplyr::rename(end = end1)
  # group_by(type, treatment, end) %>%
  # mutate(norm = (value / sum(value)) * 10^6) %>%
  # ungroup()

cp_sum <- coverage %>% filter(end == "full" & treatment == "control" & type == "PRO-seq") %>% select(value) %>% sum()
hp_sum <- coverage %>% filter(end == "full" & treatment == "heat shock" & type == "PRO-seq") %>% select(value) %>% sum()
cr_sum <- coverage %>% filter(end == "full" & treatment == "control" & type == "RNA-seq") %>% select(value) %>% sum()
hr_sum <- coverage %>% filter(end == "full" & treatment == "heat shock" & type == "RNA-seq") %>% select(value) %>% sum()

coverage <- coverage %>% mutate(norm = ifelse(treatment == "control" & type == "PRO-seq", (value / cp_sum) * 10^6,
                                              ifelse(treatment == "heat shock" & type == "PRO-seq", (value / hp_sum) * 10^6,
                                                     ifelse(treatment == "control" & type == "RNA-seq", (value / cr_sum) * 10^6,
                                                            ifelse(treatment == "heat shock" & type == "RNA-seq", (value / hr_sum) * 10^6, NA)
                                                            )
                                                     )
                                              )
                                )

covdat <- coverage %>%
  mutate(value = ifelse(strand == "minus", -value, value)) %>%
  mutate(norm = ifelse(strand == "minus", -norm, norm)) %>%
  mutate(type = ifelse(type == "RNA-seq", "RNAseq", type)) %>%
  mutate(lab = ifelse(end == "full",
                      paste0(type," ",end),
                      paste0(type," ",end,"' end")))
```

## read in RegulonDB annotation and subset for tRNAs
```{r}
require(regutools)
require(dplyr)
## Build a regulondb object
## stores database at /home/acv46/.cache/AnnotationHub
e_coli_regulondb_10.9 <- regulondb(database_conn = connect_database(),
                              organism = "E.coli",
                              database_version = "10.9",
                              genome_version = "NC_000913.3")

#list_datasets(e_coli_regulondb)
#list_attributes(e_coli_regulondb, dataset = "PROMOTER")

ec_tRNAs <- get_dataset(e_coli_regulondb_10.9, dataset = "DNA_OBJECTS") %>%
  as.tibble() %>%
  filter(grepl("tRNA-.*\\(", description))
```

## plot coverage
```{r}
require(ggplot2)
require(staplr)

setwd("/workdir/users/acv46/EC_PROSeq/figures/tRNA")
oldfiles <- dir(path = ".", pattern = "*_partial.pdf")
file.remove(file.path(".", oldfiles))

apply(X = ec_tRNAs, MARGIN = 1, function(tRNA) {
  
  tL <- as.numeric(tRNA[4])
  tR <- as.numeric(tRNA[5])
  buffer <- 30
  xmin <- ifelse(tL - buffer > 0, tL - buffer, 1)
  xmax <- ifelse(tR + buffer <= max(covdat$position), tR + buffer, max(covdat$position))
  cov <- covdat %>% filter(position >= xmin & position <= xmax) %>%
    select(-c(type,end,norm))
  ymax <- max(abs(cov$value))
  str <- ifelse(tRNA[6] == "forward", -1, 1)
  
  b1 <- round(xmin,nchar(xmin - 4))
  b2 <- round(xmax,nchar(xmin - 4))
  breaks <- seq(from = b1, to = b2, by = (b2 - b1) / 4)
  breaks <- breaks[which(breaks >= xmin & breaks <= xmax)]
  
  # https://livebook.manning.com/book/exploring-data-with-r/chapter-10/v-5/38
  
  pt <- ggplot(data = cov) +
    geom_area(mapping  = aes(x = position, y = value, linetype = strand),
              fill = "red") +
    geom_text(mapping = aes(x = xmin,
                            y = str * 0.75 * ymax,
                            label = lab),
             size = 3,
             check_overlap = TRUE,
             hjust = 0) +
    scale_linetype_manual(values = c(1,1)) +
    facet_grid(lab ~ treatment) + 
    scale_x_continuous(breaks = breaks,
                       labels = sprintf("%.2f", (breaks / 1000))) +
    coord_cartesian(ylim = c(-ymax - (0.05 * ymax), ymax + (0.05 * ymax))) +
    theme_classic() + 
    theme(legend.position = "none",
          strip.background.y = element_blank(),
          strip.text.y = element_blank()) +
    geom_hline(yintercept = 0,
               color = "black") +
    xlab("position (kb)") +
    ylab("depth") +
    annotate("segment",
             x = ifelse(tRNA[6] == "forward", tL, tR),
             xend = ifelse(tRNA[6] == "forward", tR, tL),
             y = str * ymax * 0.3,
             yend = str * ymax * 0.3,
             size = 1,
             arrow = arrow(type = "closed", length = unit(0.05, "npc")),
             color = "black",
             alpha = 0.5) +
    ggtitle(paste0(tRNA[3],", ",tRNA[7]))
  
  print(pt)
  
  ggsave(filename = paste(tRNA[1], "partial.pdf", sep = "_"),
         plot = pt,
         device = cairo_pdf,
         dpi = 400,
         width = 6,
         height = 4)
  
})


pdflist <- list.files(path = ".", pattern = "partial.pdf")
staple_pdf(input_files = pdflist,
           output_filepath = file.path(".", "ec_tRNA_merged_v2.pdf"))
do.call(file.remove, list(pdflist))
```

# Plot DNA objects

## get fresh regulondb object with appropriate organism name
```{r}
e_coli_regulondb_chr <- regulondb(database_conn = connect_database(),
                              organism = "chr",
                              database_version = "10.9",
                              genome_version = "NC_000913.3")
plot_dna_objects(e_coli_regulondb_chr,
                 grange = GRanges("chr",
                                                        IRanges(457000,462000)),
                 elements = c("gene", "promoter"))
```


# Pearson + Spearman correlation

## load libraries
```{r}
# BRGenomics functions seems to be broken in R 4.0.0
# fresh Biocnductor install in 4.1.2

if (!requireNamespace("BiocManager", quietly=TRUE))
    install.packages("BiocManager")
BiocManager::install("BRGenomics")
BiocManager::install("regutools")
install.packages("tidyverse")
library(BRGenomics)
library(regutools)
library(tidyverse)
library(parallel)
library(data.table)
```

## function to create basepair-resolution (BR) objects from bam alignments
```{r}
# For PRO-seq data -- 3p position of alignments, reverse complement
makeBRobj_3p <- function(path){
  
  import_bam(file = path, 
             mapq = 30, 
             revcomp = F, 
             shift = -1L, 
             trim.to = "3p", 
             paired_end = T,
             ignore.strand = F)

}

# For RNA-seq data -- no trimming
makeBRobj <- function(path){
  
  import_bam(file = path, 
             mapq = 30, 
             revcomp = T, 
             shift = 0, 
             #trim.to = "3p",
             paired_end = T,
             ignore.strand = F)

}
```

## apply BR object function
```{r}
setwd(dir = "/workdir/users/acv46/EC_PROSeq/proseq2.0/out3/bams/sort/")

PC1 <- makeBRobj_3p("PC1_dedup_QC_end.sort.bam")
PC2 <- makeBRobj_3p("PC2_dedup_QC_end.sort.bam")
PC3 <- makeBRobj_3p("PC3_dedup_QC_end.sort.bam")
PH1 <- makeBRobj_3p("PH1_dedup_QC_end.sort.bam")
PH2 <- makeBRobj_3p("PH2_dedup_QC_end.sort.bam")
PH3 <- makeBRobj_3p("PH3_dedup_QC_end.sort.bam")

RCD1 <- makeBRobj("RCD1_QC_end.sort.bam")
RCD2 <- makeBRobj("RCD2_QC_end.sort.bam")
RHD1 <- makeBRobj("RHD1_QC_end.sort.bam")
RHD2 <- makeBRobj("RHD2_QC_end.sort.bam")

RCU1 <- makeBRobj("RCU1_QC_end.sort.bam")
RCU2 <- makeBRobj("RCU2_QC_end.sort.bam")
RHU1 <- makeBRobj("RHU1_QC_end.sort.bam")
RHU2 <- makeBRobj("RHU2_QC_end.sort.bam")

```

## Combine BR objects into a named list
```{r}

PS.list <- list(PC1,PC2,PC3,PH1,PH2,PH3,
                RCD1,RCD2,RHD1,RHD2,
                RCU1,RCU2,RHU1,RHU2)

names(PS.list) <- as.character(expression(PC1,PC2,PC3,PH1,PH2,PH3,
                                          RCD1,RCD2,RHD1,RHD2,
                                          RCU1,RCU2,RHU1,RHU2))
```

## Merge replicates -- must follow ID_1, ID_2, etc. scheme
```{r}
mergedReps <- mergeReplicates(PS.list, 
                              makeBRG = T, 
                              ncores = round(detectCores()/10))
```

## Function to generate region counts
```{r}
#For All Genes
counts_region <- function(dataset_gr,
                     features_list,
                     start,
                     end){
  
  getCountsByRegions(dataset.gr = dataset_gr, 
                     regions.gr = genebodies(genelist = features_list,
                                             start = start,
                                             end = end),
                     field = "score",
                     region_names = features_list$name,
                     ncores = round(detectCores()/10))

}

```

## Full Gene Bodies, sense and antisense
```{r}
require(regutools)
require(dplyr)

setwd(dir = "/workdir/users/acv46/EC_PROSeq/compare/BRgenomics/")

## Old, from gff
# featurelist_sense <- import.gff3(con = "Escherichia_coli_str_k_12_substr_mg1655.ASM584v2.46.gff3",
#                                 colnames = c("Name","gene_id"),
#                                 feature.type = "gene")
# 
# featurelist_antisense <- import.gff3(con = "ASM584v2_full_antisense.gff3",
#                                 colnames = c("Name","gene_id"),
#                                 feature.type = "gene")

# Strange note -- having a sequence named "Chromosome" in the gff3 breaks this script
# sed -i 's/Chromosome/NC_000913.3/g' ASM584v2_genes_edit.gff3

## New, granges object from regulondb
featurelist_sense <- get_dataset(regulondb(database_conn = connect_database(),
                                           organism = "NC_000913.3",
                                           database_version = "10.9",
                                           genome_version = "NC_000913.3"),
                      dataset = "GENE",
                      attributes = c("name", "posleft", "posright", "strand", "product_type")) %>%
  as_tibble() %>%
  mutate(product_type = ifelse(is.na(product_type), "gene", product_type)) %>%
  mutate(strand = ifelse(strand == "forward", "+", "-")) %>%
  drop_na() %>%
  mutate(seqnames = "NC_000913.3") %>%
  GenomicRanges::makeGRangesFromDataFrame(keep.extra.columns = TRUE,
                                          ignore.strand = FALSE,
                                          seqinfo = NULL,
                                          seqnames.field = "seqnames",
                                          start.field = "posleft",
                                          end.field = "posright",
                                          strand.field = "strand",
                                          starts.in.df.are.0based = FALSE)

counts_sense <- counts_region(dataset_gr = mergedReps,
                        features_list = featurelist_sense,
                        start = 0,
                        end = 0)

# Append gene name and length to each row
# Normalize to region length and experiment total counts
# Add 1 to every field to avoid Inf and NAN errors

### Normalization - Sense PRO-seq v. Sense RNA-seq ###

counts_sense$gene <- featurelist_sense$name
counts_sense$kb <- width(featurelist_sense) / 1000
counts_sense$norm_p <- (((counts_sense$HP) / sum(counts_sense$HP)) / ((counts_sense$CP)/ sum(counts_sense$CP))) / counts_sense$kb
counts_sense$norm_r <- (((counts_sense$HR) / sum(counts_sense$HR)) / ((counts_sense$CR)/ sum(counts_sense$CR))) / counts_sense$kb

# counts_antisense$gene <- featurelist_antisense$Name
# counts_antisense$kb <- width(featurelist_antisense) / 1000
# counts_antisense$norm_p <- (((counts_antisense$HP) / sum(counts_antisense$HP)) / ((counts_antisense$CP)/ sum(counts_antisense$CP))) / counts_antisense$kb
# counts_antisense$norm_r <- (((counts_antisense$HR) / sum(counts_antisense$HR)) / ((counts_antisense$CR)/ sum(counts_antisense$CR))) / counts_antisense$kb

# Reorder to plot heat shock genes last

HSindex <- as.data.frame(read.table("genes_4140_ordered.txt"))

sense_HS <- counts_sense[match(HSindex$V1, counts_sense$gene),]
# antisense_HS <- counts_antisense[match(HSindex$V1, counts_antisense$gene),]

merged_HS <- sense_HS
merged_HS$CP_a <- antisense_HS$CP
merged_HS$HP_a <- antisense_HS$HP
merged_HS$CR_a <- antisense_HS$CR
merged_HS$HR_a <- antisense_HS$HR
merged_HS$norm_p_a <- antisense_HS$norm_p
merged_HS$norm_r_a <- antisense_HS$norm_r

# rpkm calcs

merged_HS$CP_RPKM <- (merged_HS$CP / merged_HS$kb) / (length(mergedReps$CP) / 10^6)
merged_HS$HP_RPKM <- (merged_HS$HP / merged_HS$kb) / (length(mergedReps$HP) / 10^6)
merged_HS$CR_RPKM <- (merged_HS$CR / merged_HS$kb) / (length(mergedReps$CR) / 10^6)
merged_HS$HR_RPKM <- (merged_HS$HR / merged_HS$kb) / (length(mergedReps$HR) / 10^6)

merged_HS$CP_RPKM_a <- (merged_HS$CP_a / merged_HS$kb) / (length(mergedReps$CP) / 10^6)
merged_HS$HP_RPKM_a <- (merged_HS$HP_a / merged_HS$kb) / (length(mergedReps$HP) / 10^6)
merged_HS$CR_RPKM_a <- (merged_HS$CR_a / merged_HS$kb) / (length(mergedReps$CR) / 10^6)
merged_HS$HR_RPKM_a <- (merged_HS$HR_a / merged_HS$kb) / (length(mergedReps$HR) / 10^6)

HSlabs.dat <- as.data.frame(read.table("HSgenes_63good.txt"))
HSlabs <- HSlabs.dat[[1]]

key.col <- rep('other gene', nrow(merged_HS))
key.col[which(merged_HS$gene %in% HSlabs)] <- 'heat shock gene'

merged_HS$lab <- key.col

merged_HSonly <- merged_HS[which(merged_HS$lab == 'heat shock gene'),]
merged_noHS <- merged_HS[which(merged_HS$lab == 'other gene'),]

# https://stackoverflow.com/questions/26218002/r-manually-set-shape-by-factor

# Remove inf and NaN rows for spearman rank correlation analysis

sense_finite <- merged_HS[is.finite(merged_HS$norm_p) & is.finite(merged_HS$norm_r), ]
antisense_finite <- merged_HS[is.finite(merged_HS$norm_p_a) & is.finite(merged_HS$norm_r_a), ]
merged_finite <- merged_HS[is.finite(merged_HS$norm_p) & is.finite(merged_HS$norm_r) 
                           & is.finite(merged_HS$norm_p_a) & is.finite(merged_HS$norm_r_a), ]
```

### move cache, or regulondb won't work
```{r}
# https://bioconductor.org/packages/devel/bioc/vignettes/AnnotationHub/inst/doc/TroubleshootingTheCache.html#default-caching-location-update
# https://www.bioconductor.org/packages/devel/bioc/vignettes/BiocFileCache/inst/doc/BiocFileCache.html#default-caching-location-update
moveFiles<-function(package){
        olddir <- path.expand(rappdirs::user_cache_dir(appname=package))
        newdir <- tools::R_user_dir(package, which="cache")
        dir.create(path=newdir, recursive=TRUE)
        files <- list.files(olddir, full.names =TRUE)
        moveres <- vapply(files,
        FUN=function(fl){
          filename = basename(fl)
          newname = file.path(newdir, filename)
          file.rename(fl, newname)
        },
        FUN.VALUE = logical(1))
        if(all(moveres)) unlink(olddir, recursive=TRUE)
    }


    package="AnnotationHub"
    moveFiles(package)
    package="BiocFileCache"
    moveFiles(package)
```

## import regulon DB features as gff
```{r}
genes <- regulondb(database_conn = connect_database(),
                              organism = "NC_000913.3",
                              database_version = "10.9",
                              genome_version = "NC_000913.3") %>%
  get_dataset(., dataset = "GENE", attributes = c("id","posleft","posright","strand","name","go_index_bp","bnumber","product_type")) %>%
  convert_to_granges()
```

## function to turn list of granges into counts data
```{r}
# copied from above
featurelist_sense <- get_dataset(regulondb(database_conn = connect_database(),
                                           organism = "NC_000913.3",
                                           database_version = "10.9",
                                           genome_version = "NC_000913.3"),
                      dataset = "GENE",
                      attributes = c("name", "posleft", "posright", "strand", "product_type")) %>%
  as_tibble() %>%
  mutate(product_type = ifelse(is.na(product_type), "gene", product_type)) %>%
  mutate(strand = ifelse(strand == "forward", "+", "-")) %>%
  drop_na() %>%
  mutate(seqnames = "NC_000913.3") %>%
  GenomicRanges::makeGRangesFromDataFrame(keep.extra.columns = TRUE,
                                          ignore.strand = FALSE,
                                          seqinfo = NULL,
                                          seqnames.field = "seqnames",
                                          start.field = "posleft",
                                          end.field = "posright",
                                          strand.field = "strand",
                                          starts.in.df.are.0based = FALSE)

# get counts
counts_dat <- data.frame()
FLAG <- 0

for (i in seq_along(PS.list)){
  
  if (FLAG == 0){
    
    FLAG <- 1
    newrep <- counts_region(dataset_gr = PS.list[i],
                            features_list = featurelist_sense,
                            start = 0,
                            end = 0)
    
    counts_dat <<- data.frame(newrep)

  } 
  
  else{
    
    newrep <- counts_region(dataset_gr = PS.list[i],
                            features_list = featurelist_sense,
                            start = 0,
                            end = 0)
    
    counts_dat <<- cbind(counts_dat, newrep) 
    
  }
}




```

## convert counts to matrix and plot correlation -- heat map output
```{r}
require(stats)
#require(ggcorrplot)

# remove all rows where any replicate count equals zero
nozero <- apply(counts_dat, 1, function(row) all(row !=0 ))

width <- width(featurelist_sense)

zeros <- T
#if (zeros)
counts_mat_nozero <- as.matrix(counts_dat[nozero,])
counts_mat_withzero <- as.matrix(counts_dat)
counts_mat_zeros_width <- cbind(counts_mat_withzero, width)

```

### old stuff
```{r}
# calculate correlation matrix
cormat_nozero <- cor(counts_mat_withzero, method = "pearson")
#p.nozero <- cor_pmat(counts_mat_withzero)

reorder <- as.character(expression(PC1,PC2,PC3,RCD1,RCD2,PH1,PH2,PH3,RHD1,RHD2))
cormat_nozero <- cormat_nozero[reorder,reorder]

cordt <- as.data.table(cormat_nozero, keep.rownames = 'col_name')
cordt <- melt(cordt, id.vars = 'col_name', variable.name = 'row_name')

# convert to factor so that rows and columns have the same order as the data
cordt[, row_name := factor(row_name, levels = rev(rownames(cormat_nozero)))]
cordt[, col_name := factor(col_name, levels = rownames(cormat_nozero))]

# set diagonal and the top-right half of the matrix to 0 so that those cells appears white
cordt[ncol(cormat_nozero) - as.integer(row_name) < as.integer(col_name), value := 0]
# remove the last column and the bottom row (where left cells are self correlations only)
cordt <- cordt[as.integer(row_name) < ncol(cormat_nozero) &
        as.integer(col_name) < ncol(cormat_nozero)]

# reorder columns and remove undepleted RNA-seq libraries
# c("PC1","PC2","PC3","PH1","PH2","PH3","RCD1","RCD2","RHD1","RHD2","RCU1","RCU2","RHU1","RHU2")
#reorder <- c("RHD2","RHD1","PH3","PH2","PH1","RCD2","RCD1","PC3","PC2","PC1")
#cormat_nozero <- cormat_nozero[reorder,reorder]

#cormat_withzero <- cor(counts_mat_withzero, method = "pearson")
#p.withzero <- cor_pmat(counts_mat_withzero)

legend.lab <- expression(paste("Pearson's ", italic("r")))

# plot  
# ggcorrplot(cormat_nozero,
#            method = "square",
#            type = "lower",
#            show.diag = T,
#            lab = T,
#            lab_size = 3,
#            hc.order = F,
#            ggtheme = ggplot2::theme_classic(),
#            title = "Correlations of libraries, all genes, raw counts, zero-depleted") +
#   scale_fill_gradient2(low = "white", high = "red", breaks=c(0, 1), limit=c(0, 1)) +
#   labs(fill = legend.lab)

pc <- ggplot(subset(cordt, value != 0), aes(x = col_name, y = row_name, fill = value)) +
  geom_tile(color = "black") +
  coord_equal() +
  geom_text(aes(label = round(value, 2))) +
  scale_fill_gradient2(low = 'white', high = 'red') +
  labs(x = NULL, y = NULL, fill = legend.lab) +
  theme_classic()
pc
```

### ggsave
```{r}
#library(svglite)
setwd("/workdir/users/acv46/EC_PROSeq/figures/correlation")
ggsave(filename = "pearson_corr_red_noU.svg",
       plot = pc,
       device = "svg",
       dpi = 600,
       width = 5,
       height = 4.5)
ggsave(filename = "pearson_corr_red_noU.pdf",
       plot = pc,
       device = cairo_pdf,
       dpi = 600,
       width = 5,
       height = 4.5)
```

## RNA stability
```{r}
# analysis based on https://www.biorxiv.org/content/10.1101/690644v2.full
# counts_sense generated from section "Full Gene Bodies, sense and antisense"

# remove rows containing zero counts for any merged dataset
csn <- counts_sense
csn[csn == 0] <- NA
csn <- na.omit(csn)

#
csn$PRO_c_TPM <- (csn$CP / sum(csn$CP)) * 10^6
csn$RNA_c_TPM <- (csn$CR / sum(csn$CR)) * 10^6
csn$PRO_h_TPM <- (csn$HP/ sum(csn$HP)) * 10^6
csn$RNA_h_TPM <- (csn$HR / sum(csn$HR)) * 10^6

# calculate half life for gene transcripts 
csn$HL_c <- (csn$CR / sum(csn$CR)) / (csn$CP / sum(csn$CP))
csn$HL_h <- (csn$HR / sum(csn$HR)) / (csn$HP / sum(csn$HP))

csn$delta_RNA <- abs(csn$HR - csn$CR) / sum(csn$HR + csn$CR)
csn$delta_PRO <- abs(csn$HP - csn$CP) / sum(csn$HP + csn$CP)

csn$HL_delta <- csn$HL_h / csn$HL_c
csn$delta_proportion <- (csn$CP + csn$HP) / sum(csn$CP + csn$HP) 
#csn$Zpro <- (abs(csn$CP - csn$HP) - mean(abs(csn$CP - csn$HP))) / sd(abs(csn$CP - csn$HP))

HSlabs.dat <- as.data.frame(read.table("HSgenes_63good.txt"))
HSlabs <- HSlabs.dat[[1]]

key.col <- rep('other gene', nrow(csn))
key.col[which(csn$gene %in% HSlabs)] <- 'heat shock gene'

csn$lab <- key.col

#merged_HSonly <- merged_HS[which(merged_HS$lab == 'heat shock gene'),]
#merged_noHS <- merged_HS[which(merged_HS$lab == 'other gene'),]
```

```{r}
p1.spearman <- cor.test(x = csn$PRO_h_TPM,
                        y = csn$RNA_h_TPM,
                        method = "spearman",
                        conf.level = 0.95)

p1 <- ggplot(csn, aes(x = log10(PRO_h_TPM), y = log10(RNA_h_TPM))) +
        geom_point() + 
        #geom_hline(yintercept = 0.001, color = "goldenrod") +
        #geom_vline(xintercept = 1, color = "goldenrod") +
        theme_classic() +
        ggtitle("All nonzero genes, Heat Shock") +
        annotate("text",
                 label = paste(" =", round(p1.spearman$estimate, digits = 4), "\n", paste(nrow(csn)), "genes"), 
                  x = 0.5,
                  y = 3.5) +
        geom_smooth(method=lm, 
                    se=TRUE, 
                    fullrange=TRUE) +
        theme(plot.margin = margin(1,3,1,3, "cm"))
  
p1
```

## HS signal over control
```{r}
# PLOT

pal <- wes_palette(name = "Zissou1",
                   type = "continuous")

p1 <- ggplot(data = merged_noHS) + 
  #Plot non-HS points first
  geom_point(mapping = aes(x = log10(norm_p_a),
                           y = log10(norm_r_a),
                           colour = abs(log10(norm_p_a/norm_r_a))),
             size = 2) +
  labs(color='log10 enrichment') +
  #Plot HS points next
  geom_point(data = merged_HSonly,
             mapping = aes(x = log10(norm_r_a),
                           y = log10(norm_p_a)),
             size = 2,
             colour = "black") +
  geom_abline(slope = 1, intercept = 0, color = "black", alpha = 0.75) +
  #Plot smoothed relationship for finite data (no NaN or Inf)
  #geom_smooth(data = merged_finite,
  #            mapping = aes(x = log10(norm_r),
  #                         y = log10(norm_p)),
  #            method=lm, 
  #            se=TRUE, 
  #            fullrange=TRUE) +
  geom_label_repel(data = merged_HS,
                   aes(label = ifelse(abs(log10(norm_p_a/norm_r_a))>1.5 & abs(log10(norm_p_a/norm_r_a))<3,
                                      as.character(gene),
                                      ''),
                       x = log10(norm_r_a),
                       y = log10(norm_p_a)),
                   box.padding   = 0.5, 
                   point.padding = 0.25,
                   segment.color = 'grey50',
                   size = 2.5) +
  scale_colour_gradientn(colours = pal) +
  #geom_vline(xintercept = 0, color = "royalblue") +
  #geom_hline(yintercept = 0, color = "royalblue") +
  #geom_abline(slope = log10(2), intercept = log10(1), color = "red") +
  #geom_abline(slope = log10(2), intercept = -log10(1), color = "red") +
  theme_classic() +
  xlim(-2.5,3.5) +
  ylim(-2.5,3.5) +
  labs(title = "", 
       y = "PRO-seq, norm. log10(Heat Shock / Control)", 
       x = "RNA-seq, norm. log10(Heat Shock / Control)") +
  ggtitle("PRO-seq vs. RNAseq, gene bodies, sense strand") +
  annotate("text",
           label = "Spearman  = 0.7770451 \n p < 2.2e-16", 
            x = -1.4,
            y = 3)
  
p1

p1.spearman <- cor.test(x = merged_finite$norm_r,
                        y = merged_finite$norm_p,
                        method = "spearman",
                        conf.level = 0.95)

p1.pearson <- cor.test(x = merged_finite$norm_r,
                        y = merged_finite$norm_p,
                        method = "pearson",
                        conf.level = 0.95)
```

## log-log replicate plots
```{r}
require(ggplot2)
require(tidyr)
require(dplyr)
require(stats)
require(ggpubr)

# uses counts_mat_withzero object from correlation plot above

plotdat <- counts_mat_zeros_width %>%
  as_tibble() %>% 
  mutate(index = row.names(.)) %>% 
  #mutate_at(vars(-c(index, width)), funs(10^6 * ((. + 1) / sum(.))))
  mutate_at(vars(-c(index, width)), funs(10^6 * (((.) / (width / 10^3)) / sum(.))))
  #pivot_longer(!index, names_to = "lib", values_to = "value")
  
loglog <- function(lib1, lib2, color, spearman, pearson) {

  pc <- ggplot(data = plotdat,
               mapping = aes(x = log10(lib1), y = log10(lib2))) +
    geom_point(size = 1.5,
               alpha = 0.5,
               color = color) +
    geom_label(x = 0.25, y = 4.5, size = 3, label.size = NA, 
               label = paste0(" = ", round(spearman,3),
                              "\n", "r = ", round(pearson,3)),
               hjust = 0) +
    theme_classic() +
    theme(axis.title = element_blank(),
          axis.text = element_text(size = 14)) +
    xlim(0,5) +
    ylim(0,5) +
    geom_abline(slope = 1, color = "black", intercept = 0)
  
  print(pc)

}

#'#e41a1c','#377eb8','#4daf4a','#984ea3','#ff7f00','#ffff33'

#"#E69F00" - PC
#"#D55E00" - PH
#"#7acfff" - RC
#"#0072B2"- RH

spearman <- cor(counts_mat_zeros_width, method = "spearman")
pearson <- cor(counts_mat_zeros_width, method = "pearson")

a <- loglog(plotdat$PC1, plotdat$PC2, "#E69F00", spearman["PC1","PC2"], pearson["PC1","PC2"])
b <- loglog(plotdat$PC1, plotdat$PC3, "#E69F00", spearman["PC1","PC3"], pearson["PC1","PC3"])
c <- loglog(plotdat$PC2, plotdat$PC3, "#E69F00", spearman["PC2","PC3"], pearson["PC2","PC3"])
d <- loglog(plotdat$PH1, plotdat$PH2, "#D55E00", spearman["PH1","PH2"], pearson["PH1","PH2"])
e <- loglog(plotdat$PH1, plotdat$PH3, "#D55E00", spearman["PH1","PH3"], pearson["PH1","PH3"])
f <- loglog(plotdat$PH2, plotdat$PH3, "#D55E00", spearman["PH2","PH3"], pearson["PH2","PH3"])
g <- loglog(plotdat$RCD1, plotdat$RCD2, "#7acfff", spearman["RCD1","RCD2"], pearson["RCD1","RCD2"])
h <- loglog(plotdat$RHD1, plotdat$RHD2, "#0072B2", spearman["RHD1","RHD2"], pearson["RHD1","RHD2"])

```

## log log RNAseq vs PRO-seq
```{r}
require(tidyverse)
require(stats)
require(regutools)

plotdat2 <- counts_mat_zeros_width %>%
  as_tibble() %>%
  mutate(PC = PC1 + PC2 + PC3) %>%
  mutate(PH = PH1 + PH2 + PH3) %>%
  mutate(RC = RCD1 + RCD2) %>%
  mutate(RH = RHD1 + RHD2) %>%
  mutate(index = row.names(.)) %>% 
  mutate(name = featurelist_sense$name) %>%
  mutate(type = featurelist_sense$product_type) %>%
  select(PC,PH,RC,RH,width,index,name,type) %>%
  mutate_at(vars(-c(index, width, name, type)),
            funs(10^6 * (((.) / (width / 10^3)) / sum(.)))) %>%
  arrange(type) # makes all ncRNA plotted last

toCorr <- counts_mat_zeros_width %>%
  as_tibble() %>%
  mutate(PC = PC1 + PC2 + PC3) %>%
  mutate(PH = PH1 + PH2 + PH3) %>%
  mutate(RC = RCD1 + RCD2) %>%
  mutate(RH = RHD1 + RHD2) %>%
  select(PC,PH,RC,RH) %>%
  as.matrix()

loglog2 <- function(lib1, lib2, color, spearman, pearson) {

  pc <- ggplot(data = plotdat2,
               mapping = aes(x = log10(lib1),
                             y = log10(lib2))) +
    geom_point(mapping = aes(color = type),
               size = 1.5,
               alpha = 1) +
    scale_color_manual(values = c("#cccccc","#faa80f","#ff0022","#6622cc")) +
    geom_label(x = 0.25, y = 4.5, size = 3, label.size = NA, 
               label = paste0(" = ", round(spearman,3),
                              "\n", "r = ", round(pearson,3)),
               hjust = 0) +
    theme_classic() +
    xlab("PRO-seq log10(RPKM)") +
    ylab("RNAseq log10(RPKM)") +
    theme(axis.title = element_text(size = 14),
          axis.text = element_text(size = 14),
          legend.position = "none") +
    xlim(0,5) +
    ylim(0,5) +
    geom_abline(slope = 1, color = "black", intercept = 0)
  
  print(pc)

}

# palettes
# "808080","000000","ff0022","6622cc"
# #808080","#eca400","#ff4a1c","#5f0a87"
# "cccccc","faa80f","ff0022","6622cc"

spearman <- cor(toCorr, method = "spearman")
pearson <- cor(toCorr, method = "pearson")

pcrc <- loglog2(plotdat2$PC, plotdat2$RC, "#E69F00", spearman["PC","RC"], pearson["PC","RC"])
phrh <- loglog2(plotdat2$PH, plotdat2$RH, "#E69F00", spearman["PH","RH"], pearson["PH","RH"])
```

## barplot with plotdat2 data
```{r}
require(tidyverse)
require(ggpubr)
require(scales)

plotdat3 <- plotdat2 %>%
         pivot_longer(cols = c("PC","PH","RC","RH"),
                      names_to = "treatment") %>%
         filter(type != "gene" & type != "rRNA") %>%
  mutate(treatment = factor(treatment, levels = c("PC","RC","PH","RH")))

plain <- function(x,...) {
  format(x, ..., scientific = FALSE, drop0trailing = TRUE)
}

rbar <- ggplot(data = plotdat3,
       mapping = aes(x = treatment, y = value + 1)) +
  geom_boxplot(outlier.shape = NA) +
  geom_jitter(mapping = aes(color = type),
              width = 0.1,
              alpha = 0.5) +
  scale_color_manual(values = c("#ff0022","#6622cc")) +
  scale_y_log10(labels = function(x) format(x, scientific = TRUE),
                breaks = c(1 %o% 10^(0:6))) +
  facet_wrap(. ~ type) +
  theme_classic() +
  ylab("RPKM + 1") +
  xlab("") +
  theme(strip.background = element_blank(),
        strip.text.x = element_blank(),
        legend.position = "none") +
  stat_compare_means(comparisons = list(c("PC", "RC")), 
                     label = "p.format", method = "wilcox.test", paired = T, tip.length = 0) +
  stat_compare_means(comparisons = list(c("PH", "RH")), 
                     label = "p.format", method = "wilcox.test", paired = T, tip.length = 0)

rbar <- rbar + annotation_logticks(sides = "l") 


setwd("/workdir/users/acv46/EC_PROSeq/figures/correlation/")
ggsave(plot = rbar,
       filename = "barplot_log10_rpkm_RNAtype_v3.pdf",
       width = 3, height = 3, useDingbats = F)

```

### ggsave
```{r}
setwd("/workdir/users/acv46/EC_PROSeq/figures/correlation/")

ggsave_pngpdf <- function(plot,sample1,sample2) {

  # ggsave(filename = paste0(sample1, "v", sample2, "_loglogRPKM_v5.png"),
  #        plot = plot, width = 3, height = 3)
  ggsave(filename = paste0(sample1, "v", sample2, "_loglogRPKM_v1_nolegend.pdf"),
         plot = plot, width = 3, height = 3, useDingbats = F)

}

# ggsave_pngpdf(a, "PC1", "PC2")
# ggsave_pngpdf(b, "PC1", "PC3")
# ggsave_pngpdf(c, "PC2", "PC3")
# ggsave_pngpdf(d, "PH1", "PH2")
# ggsave_pngpdf(e, "PH1", "PH3")
# ggsave_pngpdf(f, "PH2", "PH3")
# ggsave_pngpdf(g, "RCD1", "RCD2")
# ggsave_pngpdf(h, "RHD1", "RHD2")

ggsave_pngpdf(pcrc, "PC", "RC")
ggsave_pngpdf(phrh, "PH", "RH")

```



# Pause sites, take 2
## read in coverage data, bedtools corrected
```{r}
library(tidyverse)
setwd("/workdir/users/acv46/EC_PROSeq")

# PRO-seq and RNA-seq coverage data (as read in above)
# use interation 2, see readme in file directory
coverage <- read_delim(file = "pileup/iter_correct/all_coverage.txt",
                       delim = "\t")

colnames(coverage) <- colnames(coverage) %>% gsub("merge_","",.) %>% gsub("q30_","",.)
coverage <- pivot_longer(coverage, -c(contig, position)) %>%
  select(-contig) %>% mutate(type = ifelse(grepl("P", name), "PRO-seq", "RNA-seq")) %>%
  mutate(end = ifelse(grepl("3p", name), "3", ifelse(grepl("5p", name), "5", "full"))) %>%
  mutate(treatment = ifelse(grepl("H", name), "heat shock", "control")) %>%
  mutate(strand = ifelse(grepl("plus", name), "plus", "minus")) %>% select(-name)

write_csv(coverage, "pileup/iter_correct/all_coverage_formatted.txt")
```

### read in coverage if already written
```{r}
coverage <- read_csv("/workdir/users/acv46/EC_PROSeq/pileup/iter_correct/all_coverage_formatted.txt")
# flip orintation of plus and minus, just for fun
# 3' and 5' ends must also be flipped for correct orientation
# orientation and end flippinf supported by tRNA mapping
# get normalized values by grouping lib types
## normalize based on full coverage values
coverage <- coverage %>% mutate(strand1 = ifelse(strand == "plus", "minus", "plus")) %>%
  select(-strand) %>% dplyr::rename(strand = strand1) %>%
  mutate(end1 = ifelse(end == "3", "5", ifelse(end == "5", "3", "full"))) %>%
  select(-end) %>% dplyr::rename(end = end1)
  # group_by(type, treatment, end) %>%
  # mutate(norm = (value / sum(value)) * 10^6) %>%
  # ungroup()

cp_sum <- coverage %>% filter(end == "3" & treatment == "control" & type == "PRO-seq") %>% select(value) %>% sum()
hp_sum <- coverage %>% filter(end == "3" & treatment == "heat shock" & type == "PRO-seq") %>% select(value) %>% sum()
cr_sum <- coverage %>% filter(end == "full" & treatment == "control" & type == "RNA-seq") %>% select(value) %>% sum()
hr_sum <- coverage %>% filter(end == "full" & treatment == "heat shock" & type == "RNA-seq") %>% select(value) %>% sum()

coverage <- coverage %>% mutate(norm = ifelse(treatment == "control" & type == "PRO-seq", (value / cp_sum) * 10^6,
                                              ifelse(treatment == "heat shock" & type == "PRO-seq", (value / hp_sum) * 10^6,
                                                     ifelse(treatment == "control" & type == "RNA-seq", (value / cr_sum) * 10^6,
                                                            ifelse(treatment == "heat shock" & type == "RNA-seq", (value / hr_sum) * 10^6, NA)
                                                            )
                                                     )
                                              )
                                )

pro_covdat <- coverage %>% filter(type == "PRO-seq") %>% filter(end %in% c("3","5"))
rm(coverage)
```

## read in fasta
```{r}
get_fasta <- function(file) {
  
  require(Biostrings)
  fasta <- readDNAStringSet(filepath = file,
                            format = "fasta")
  
  fasta
  
}

ec_fasta <- get_fasta("/workdir/users/acv46/EC_PROSeq/index/U00096.3/GCF_000005845.2_ASM584v2_genomic.fna")
```

## identify pause sites, filter by score, pull sequences
```{r}
# from Sun 2021 -- "ends of all uniquely mapped RNA reads (bottom lane) were determined and the read count for each 3 end position was calculated and plotted (top lane). The genomic positions where 3 end/3 end median (51-bp window) read counts ratio (pause score) was  20 and read counts/10^6 reads was  10 satisfied our stringent definition for a pause site."

# main function to process each contig in the chosen bin set
get_motifs <- function(covdat, seqdat, end, range, mincov, minpause, context) {
  
  # INPUTS
  ## covdat is coverage data
  ## bindat is all metadata
  ## seqdat is genomic ranges object containing all sequence data
  ## gtf is a gtf annotation file
  ## end is either 3 or 5
  ## range is the context around a position to use in pause score calculation
  ## mincov is the minimum raw coverage value at a position to determine whether a pause score should be calculated
  ## minpause is the the minimum Z score for a position to call it as significantly paused
  ## context is the number of bases surrounding a significant peak
  
  require(tidyverse)
  require(stats)
  require(Biostrings)
  require(pbapply)
  
  # helper function to get pause site z score
  pause_score <- function(row, full, range, con_len){
    
    pos <- row[1] %>% as.numeric()
  
    # this code works with both circular and linear sequences
    fullrange <- sort(c(
      c(((pos - 1) - c(1:range)) %% con_len + 1),
      c(((pos - 1) + c(1:range)) %% con_len + 1)
      ))
    
    mean <- full %>%
      filter(position %in% fullrange) %>%
      select(norm) %>% abs() %>% 
      unlist() %>% mean()
  
    std <- full %>%
      filter(position %in% fullrange) %>%
      select(norm) %>% abs() %>% 
      unlist() %>% sd()
  
    # calculate z score for pause sites passing raw cov threshold
    zscore <- (abs(as.numeric(row[7])) - mean) / std
  
    list(zscore, as.numeric(row[1]))
  
  }
  
  con_cov <- covdat %>%
    filter(end == end)
  
  con_len <- max(con_cov$position) 
  index <- c((range + 1):(con_len - range - 1))
  
  # create separate datasets for plus and minus positions
  # filter for minimum absolute 
  plus_set <- con_cov %>%
    filter(strand == "plus" & abs(value) >= mincov & position %in% index)
  
  message(paste0("\n","> plus strand has ", nrow(plus_set), " hits over coverage threshold"))
  
  minus_set <- con_cov %>%
    filter(strand == "minus" & abs(value) >= mincov & position %in% index)
  
  message(paste0("\n","> minus strand has ", nrow(minus_set), " hits over coverage threshold"))
  
  cseq <- seqdat["NC_000913.3"][[1]]
  
  # get strand-wise z scores for peaks passing raw coverage threshold
  # eliminate peaks with overlapping ranges by only keeping larger peak
  ## this is needed to prevent the same sequence from being pulled more than once

  # plus strand
  if (nrow(plus_set) > 0) {

    plus_z <- tibble(z = rep(NA, nrow(plus_set)),
                     position = rep(NA, nrow(plus_set)))
    hold <- pbapply(X = plus_set,
                    MARGIN = 1,
                    FUN = pause_score,
                    full = con_cov %>% filter(strand == "plus"),
                    range = range,
                    con_len = con_len)

    plus_z$z <- do.call(rbind, hold)[,1] %>% unlist()
    plus_z$position <- do.call(rbind, hold)[,2] %>% unlist()
    plus_z <- plus_z %>%
      mutate(startrng = position - context) %>%
      mutate(endrng = position + context) %>%
      arrange(startrng) %>%
      filter(z >= minpause)

    message(paste0("\n","--> plus strand has ", nrow(plus_z), " hits over Z-score threshold"))

    plus_z$grp <- 1
    if (nrow(plus_z) > 1) {
      for (k in 2:nrow(plus_z)) {

        if (plus_z$endrng[k - 1] >= plus_z$startrng[k]) {

          plus_z$grp[k] <- plus_z$grp[k - 1]

        } else {

          plus_z$grp[k] <- plus_z$grp[k - 1] + 1

        }
      }
    }

    message(paste0("\n","----> plus strand has ", nrow(plus_z), " hits remaining after overlap removal"))

    if (nrow(plus_z) > 0) {
      plus_z <- plus_z %>%
        group_by(grp) %>%
        top_n(1, z) %>%
        ungroup() %>%
        mutate(strand = "plus")
        plus_z$sequence <- apply(X = plus_z, MARGIN = 1,
                                 FUN = function(x) {
                                   cseq[x[3]:x[4]] %>%
                                     as.character()
                                   }
                                 )

    }

  }
  
  if (nrow(minus_set) > 0) {

    minus_z <- tibble(z = rep(NA, nrow(minus_set)),
                      position = rep(NA, nrow(minus_set)))
    hold <- pbapply(X = minus_set,
                    MARGIN = 1,
                    FUN = pause_score,
                    full = con_cov %>% filter(strand == "minus"),
                    range = range,
                    con_len = con_len)

    minus_z$z <- do.call(rbind, hold)[,1] %>% unlist()
    minus_z$position <- do.call(rbind, hold)[,2] %>% unlist()
    minus_z <- minus_z %>%
      mutate(startrng = position - context) %>%
      mutate(endrng = position + context) %>%
      arrange(startrng) %>%
      filter(z >= minpause)

    message(paste0("\n","--> minus strand has ", nrow(minus_z), " hits over Z-score threshold"))

    minus_z$grp <- 1
    if (nrow(minus_z) > 1) {
      for (k in 2:nrow(minus_z)) {

        if (minus_z$endrng[k - 1] >= minus_z$startrng[k]) {

          minus_z$grp[k] <- minus_z$grp[k - 1]

        } else {

          minus_z$grp[k] <- minus_z$grp[k - 1] + 1

        }
      }
    }

    message(paste0("\n","----> minus strand has ", nrow(minus_z), " hits remaining after overlap removal"))

    if (nrow(minus_z) > 0) {
      minus_z <- minus_z %>%
        group_by(grp) %>%
        top_n(1, z) %>%
        ungroup() %>%
        mutate(strand = "minus")
        minus_z$sequence <- apply(X = minus_z, MARGIN = 1,
                                 FUN = function(x) {
                                   cseq[x[3]:x[4]] %>%
                                     reverseComplement() %>%
                                     as.character()
                                   }
                                 )

    }

  }
                    
  bind_rows(plus_z, minus_z)
  
}

```

## run get_motifs
```{r}
setwd("/workdir/users/acv46/EC_PROSeq/figures/motifs")

# control, 3', 25 range, 20 min norm cov, 5 min pause, output 20 nt context
ec_motifs <- get_motifs(covdat = pro_covdat %>% filter(treatment == "control"),
                        seqdat = ec_fasta,
                        end = 3,
                        range = 25,
                        mincov = 20,
                        minpause = 5,
                        context = 20)

write_csv(ec_motifs, "PRO-seq_motifs_control_3p_25_20_5_20_flipped_redo2.csv", col_names = T)

# heat shock, 3', 25 range, 20 min norm cov, 5 min pause, output 20 nt context
ec_motifs <- get_motifs(covdat = pro_covdat %>% filter(treatment == "heat shock"),
                        seqdat = ec_fasta,
                        end = 3,
                        range = 25,
                        mincov = 20,
                        minpause = 5,
                        context = 20)

write_csv(ec_motifs, "PRO-seq_motifs_heat-shock_3p_25_20_5_20_flipped_redo2.csv", col_names = T)
```


## group motifs by locus
### read in regulondb
```{r}
require(regutools)
require(tidyverse)
## Build a regulondb object
## stores database at /home/acv46/.cache/AnnotationHub
e_coli_regulondb_10.9 <- regulondb(database_conn = connect_database(),
                              organism = "E.coli",
                              database_version = "10.9",
                              genome_version = "NC_000913.3")

#list_datasets(e_coli_regulondb)
#list_attributes(e_coli_regulondb, dataset = "PROMOTER")

## datasets

promoters <- get_dataset(e_coli_regulondb_10.9, 
            dataset = "PROMOTER",
            attributes = c("id","name","strand","tss","sigma_factor","regulated_operon")) %>%
  as_tibble()

# promoters_sub <- promoters[-grep(",",promoters$sigma_factor),] # remove promoters controlled by multiple sigma factors
# promoters_sub$sigma_factor[is.na(promoters_sub$sigma_factor)] <- "unknown"

ops <- get_dataset(e_coli_regulondb_10.9, 
            dataset = "OPERON") %>%
            #attributes = c("id","name","total_sigma","sigma_name")) %>%
  as_tibble()

dna_objects <- get_dataset(e_coli_regulondb_10.9, dataset = "DNA_OBJECTS") %>%
  as_tibble()

# genes
genes <- get_dataset(e_coli_regulondb_10.9, "GENE") %>% as_tibble() %>%
  select(name, posleft, posright, strand, operon_name, sigma_factor, gene_tf, product_name, go_desc_bp, tu_promoter)

# get object with tss and firstgeneposleft for all operons
tss2op <- promoters %>% separate(col = regulated_operon, into = c("op_id","op_name"), sep = "\t") %>%
  base::merge(., ops %>% select(id, firstgeneposleft, lastgeneposright, tf_name) %>% dplyr::rename("op_id" = "id"),
        by = "op_id") %>% drop_na(-tf_name) %>% as_tibble()

# reduce tss2op object to single regulatory range encompassing all promoters
reg_ranges <-
rbind(
  tss2op %>% filter(strand == "forward") %>%
    group_by(op_id) %>% arrange(tss) %>%
    dplyr::slice(1) %>% select(-lastgeneposright) %>%
    dplyr::rename("op_start" = "firstgeneposleft"),
  tss2op %>% filter(strand == "reverse") %>%
    group_by(op_id) %>% arrange(desc(tss)) %>%
    dplyr::slice(1) %>% select(-firstgeneposleft) %>%
    dplyr::rename("op_start" = "lastgeneposright")
)

reg_ranges <- reg_ranges %>% mutate(op_start = as.numeric(op_start)) %>% ungroup
reg_ranges_100 <- reg_ranges %>%
  mutate(op_start = ifelse(strand == "forward", as.numeric(op_start) + 100, as.numeric(op_start) - 100)) %>%
  ungroup

```

### find peaks that overlap tss
```{r}
# known sigma 
tss_peak <- function(peakdat, tssdat) {
  
  pdat <- read_csv(file = peakdat, col_names = T)
  merge(pdat, tssdat %>% rename(., "tss" = "position"), by = "position") %>%
    filter(sigma_factor != "unknown")
  
}

setwd("/workdir/users/acv46/EC_PROSeq/figures/motifs")
ec_control_tss_nounk <- tss_peak("PRO-seq_motifs_control_3p_25_20_5_20_flipped_redo2.csv", promoters_sub)
ec_hs_tss_nounk <- tss_peak("PRO-seq_motifs_heat-shock_3p_25_20_5_20_flipped_redo2.csv", promoters_sub)

# unknown sigma factor
tss_peak <- function(peakdat, tssdat) {
  
  pdat <- read_csv(file = peakdat, col_names = T)
  merge(pdat, tssdat %>% rename(., "tss" = "position"), by = "position") %>%
    filter(sigma_factor == "unknown")
  
}

setwd("/workdir/users/acv46/EC_PROSeq/figures/motifs")
ec_control_tss_unk <- tss_peak("PRO-seq_motifs_control_3p_25_20_5_20_flipped_redo2.csv", promoters_sub)
ec_hs_tss_unk <- tss_peak("PRO-seq_motifs_heat-shock_3p_25_20_5_20_flipped_redo2.csv", promoters_sub)
```

### find peaks that overlap any DNA object
```{r}
require(tidyverse)

map_peaks <- function(peakdat, objdat) {
  
  pdat <- read_csv(file = peakdat, col_names = T)
  numo <- nrow(objdat) 
  nump <- nrow(pdat)
  
  pdat$type <- NA
  pdat$obj_name <- NA
  pdat$obj_posleft <- NA
  pdat$obj_posright <- NA
  pdat$obj_strand <- NA
  
  # loop through peaks
  for (i in 1:nump) {
    
    message(paste0("processing peak ", i, " of ", nump))
    
    # loops through regulon db dna objects 
    for (j in 1:numo) {
      
      # if peak position falls within object bounds, write object to peak data
      if (isTRUE(between(x = pdat$position[i],
                         left = objdat$posleft[j],
                         right = objdat$posright[j])) &
          is.na(pdat$type[i])) {
        
        pdat$type[i] <- objdat$type[j]
        pdat$obj_name[i] <- objdat$name[j]
        pdat$obj_posright[i] <- objdat$posright[j]
        pdat$obj_posleft[i] <- objdat$posleft[j]
        pdat$obj_strand[i] <- objdat$strand[j]
        
      # if peak position already has an associated object, append another to list  
      } else if (isTRUE(between(x = pdat$position[i],
                         left = objdat$posleft[j],
                         right = objdat$posright[j])) &
                 !is.na(pdat$type[i])) {

        pdat$type[i] <- paste0(pdat$type[i], ", ", objdat$type[j])
        pdat$obj_name[i] <- paste0(pdat$obj_name[i], ", ", objdat$name[j])
        pdat$obj_posright[i] <- paste0(pdat$obj_posright[i], ", ", objdat$posright[j])
        pdat$obj_posleft[i] <- paste0(pdat$obj_posleft[i], ", ", objdat$posleft[j])
        pdat$obj_strand[i] <- paste0(pdat$obj_strand[i], ", ", objdat$strand[j])
        
      }
    }
  }
  
  pdat
  
}
  
setwd("/workdir/users/acv46/EC_PROSeq/figures/motifs")
ec_control_peak_all <- map_peaks("PRO-seq_motifs_control_3p_25_20_5_20_flipped_redo2.csv", dna_objects)
ec_hs_peak_all <- map_peaks("PRO-seq_motifs_heat-shock_3p_25_20_5_20_flipped_redo2.csv", dna_objects)

setwd("/workdir/users/acv46/EC_PROSeq/figures/motifs")
write_tsv(ec_control_peak_all, "PRO-seq_motifs_control_3p_25_20_5_20_flipped_redo2_DNA_objects.tsv")
write_tsv(ec_hs_peak_all, "PRO-seq_motifs_hs_3p_25_20_5_20_flipped_redo2_DNA_objects.tsv")
```

### find peaks that fall within regulatory regions
```{r}
# from Sun 2020 -- "Many E. coli genes appear to contain clusters of strong backtracked pauses at 10-20-bp distance from the transcription start site caused by retention of 70 subunit in RNA polymerase"

reg_peak <- function(peakdat, tssdat) {
  
  require(dplyr)
  
  tdat <- tssdat %>% mutate(peakcount = 0)
  tlen <- nrow(tssdat)
  pdat <- read_csv(file = peakdat, col_names = T) %>%
    mutate(strand = ifelse(strand == "plus", "forward", "reverse"))
  for (i in 1:nrow(tdat)) {
    
    message(paste0("processing range ", i, "/", tlen))
    
    for(j in 1:nrow(pdat)) {
     
      if (as.numeric(pdat$position[j]) %in% as.numeric(tdat$tss[i]):as.numeric(tdat$op_start[i]) &
          pdat$strand[j] == tdat$strand[i]) {
        
        tdat$peakcount[i] <- tdat$peakcount[i] + 1
        
      } 
      
    }
  }
  
  tdat
  
}

setwd("/workdir/users/acv46/EC_PROSeq/figures/motifs")
ec_c_peak_reg <- reg_peak("PRO-seq_motifs_control_3p_25_20_5_20_flipped_redo2.csv", reg_ranges_100) %>% ungroup()
#write_tsv(ec_c_peak_genes, "PRO-seq_motifs_control_3p_25_20_5_20_flipped_redo2_regranges.tsv")
ec_h_peak_reg <- reg_peak("PRO-seq_motifs_heat-shock_3p_25_20_5_20_flipped_redo2.csv", reg_ranges_100) %>% ungroup()
#write_tsv(ec_h_peak_genes, "PRO-seq_motifs_hs_3p_25_20_5_20_flipped_redo2_regranges.tsv")
```

### get sequence logos of peaks overlapping regulatory regions
```{r}
reg_peak <- function(peakdat, tssdat) {
  
  require(dplyr)
  require(ggseqlogo)
  
  seqdat <- tibble()
  tdat <- tssdat #%>% filter(sigma_factor == sigma)
  tlen <- nrow(tdat)
  pdat <- read_csv(file = peakdat, col_names = T) %>%
    mutate(strand = ifelse(strand == "plus", "forward", "reverse"))
  for (i in 1:nrow(tdat)) {
    
    message(paste0("processing range ", i, "/", tlen))
    
    for(j in 1:nrow(pdat)) {
     
      if (as.numeric(pdat$position[j]) %in% as.numeric(tdat$tss[i]):as.numeric(tdat$op_start[i]) &
          pdat$strand[j] == tdat$strand[i]) {
        
        seqdat <- rbind(seqdat, pdat$sequence[j])
        
      } 
      
    }
  }
  
  # message(paste0(nrow(seqdat)))
  trimseqs <- seqdat %>% #filter(bin == xbin) %>%
    as_vector() %>%
    str_sub(start = 10, end = 25)
    
    
  trimseqs
  
}

setwd("/workdir/users/acv46/EC_PROSeq/figures/motifs")
peakc <- reg_peak("PRO-seq_motifs_control_3p_25_20_5_20_flipped_redo2.csv", reg_ranges_100)
peakh <- reg_peak("PRO-seq_motifs_heat-shock_3p_25_20_5_20_flipped_redo2.csv", reg_ranges_100)
```
```{r}
library(patchwork)

p1 <- ggseqlogo(peakc,
                    #col_scheme = cs1,
                    method = "bits") +
      theme(plot.margin = unit(c(0.1,0.1,0.1,0.1),"cm"),
            #plot.title = element_text(size = 10),
            aspect.ratio = 1/5,
            axis.text.x = element_blank()) +
  annotate('text', label = paste0("Control","\n","410 peaks"),
            x = 1, y = 0.35, hjust = 0)
      # ggtitle(paste0(sample, ", bin = ", xbin, "\n", 
      #                numcontigs, " contigs, ", numpeaks, " pause sites passing cutoff\n",
      #                "phylum = ", phy, "\n",
      #                "kraken species annotation = ", k_species, "\n",
      #                "gtdbtk species annotation = ", g_species, "\n",
      #                complete, "% complete, ", contam, "% contaminated"))
    
    p2 <- ggseqlogo(peakh,
                    #col_scheme = cs1,
                    method = "bits") +
      theme(plot.margin = unit(c(0.1,0.1,0.1,0.1),"cm"),
            #plot.title = element_text(size = 10),
            aspect.ratio = 1/5) +
  annotate('text', label = paste0("Heat Shock","\n","271 peaks"),
            x = 1, y = 0.15, hjust = 0)
    
    p2$scales$scales[[1]] <- scale_x_continuous(breaks = c(1:16),
                                                labels = c(seq(from = -11, to = -1), c(1:5)))
    
    
    mergep <- p1 / p2
    
    mergep
    
    ggsave(filename = "/workdir/users/acv46/EC_PROSeq/figures/motifs/PRO-seq_motifs_reg100_3p_25_20_5_20_flipped_redo2_v2.pdf", plot = mergep, device = "pdf", useDingbats = F, dpi = 400, width = 6, height = 3, units = "in")

```

### get barplots of sigma factors distributions corresponding to regulatory region sequence logos
```{r}
require(tidyverse)
require(ggtext)
#require(glue)

control_sigdat <- ec_c_peak_reg %>% filter(peakcount > 0) %>%
  select(sigma_factor) %>% mutate(sigma = ifelse(grepl(",",sigma_factor), "mixed", sigma_factor)) %>%
  select(sigma) %>% table %>% as_data_frame() %>% dplyr::rename("sigma" = ".", "count" = "n")

hs_sigdat <- ec_h_peak_reg %>% filter(peakcount > 0) %>%
  select(sigma_factor) %>% mutate(sigma = ifelse(grepl(",",sigma_factor), "mixed", sigma_factor)) %>%
  select(sigma) %>% table %>% as_data_frame() %>% dplyr::rename("sigma" = ".", "count" = "n") %>%
  rbind(c("Sigma28",0))

all_sigdat <- rbind(control_sigdat %>% mutate(sample = "control"),
                    hs_sigdat %>% mutate(sample = "heat_shock"))

siglist <- c("Sigma70", "Sigma32", "Sigma24", "Sigma38", "Sigma54", "Sigma28", "mixed")

control_sigdat <- control_sigdat %>% mutate(sigma = factor(sigma, levels = rev(siglist))) %>% mutate(count = as.numeric(count))
hs_sigdat <- hs_sigdat %>% mutate(sigma = factor(sigma, levels = rev(siglist))) %>% mutate(count = as.numeric(count))
all_sigdat <- all_sigdat %>% mutate(sigma = factor(sigma, levels = rev(siglist))) %>% mutate(count = as.numeric(count))

# plot it
get_bars <- function(sigdat) {

  # highlight = function(x, pat, color = "black", family = "") {
  #   ifelse(grepl(pat, x),
  #          glue("<b style='font-family:{family}; color:{color}'>{x}</b>"),
  #          x)
  #   }
  
  barpal <- c("#56a3a6","#ffc857","#e9724c","#c5283d","#4e4187","#d30c7b","gray50")
  ggplot(sigdat, mapping = aes(x = sigma, fill = sigma, y = count)) +
        geom_bar(stat = "identity") +
        geom_text(mapping = aes(label = count, position = sigma), hjust = -0.2) +
        theme_classic() +
        xlab("") +
        theme(legend.position = "none",
              #aspect.ratio = 2,
              axis.text.y = element_markdown(size = 12),
              #axis.text.y = element_text(size = 12),
              axis.text.x = element_text(size = 10)) +
        scale_y_continuous(breaks = seq(0,175,25), limits = c(0,175),
                           name = "count") +
        #scale_x_discrete(labels = function(x) highlight(x, sigma, color = "red")) +
        scale_fill_manual(values = rev(barpal)) +
        coord_flip()

}
get_bars2 <- function(sigdat) {

  # highlight = function(x, pat, color = "black", family = "") {
  #   ifelse(grepl(pat, x),
  #          glue("<b style='font-family:{family}; color:{color}'>{x}</b>"),
  #          x)
  #   }
  
  barpal <- c("#56a3a6","#ffc857","#e9724c","#c5283d","#4e4187","#d30c7b","gray50")
  sampal <- c("#E69F00FF","#D55E00FF")
  ggplot(sigdat, mapping = aes(x = sigma, fill = sample, y = count)) +
        geom_bar(stat = "identity",
                 position = position_dodge2(reverse = TRUE, width = 1),
                 color = "black") +
        geom_text(mapping = aes(label = count, position = sigma, group = sample),
                  hjust = -0.2,
                  position = position_dodge2(reverse = TRUE, width = 1)) +
        theme_classic() +
        xlab("") +
        theme(legend.position = "none",
              #aspect.ratio = 2,
              axis.text.y = element_markdown(size = 12),
              #axis.text.y = element_text(size = 12),
              axis.text.x = element_text(size = 10)) +
        scale_y_continuous(breaks = seq(0,175,25), limits = c(0,175),
                           name = "count") +
        #scale_x_discrete(labels = function(x) highlight(x, sigma, color = "red")) +
        scale_fill_manual(values = sampal) +
        coord_flip(clip = "off")

}

cnp <- get_bars(sigdat = control_sigdat)
hnp <- get_bars(sigdat = hs_sigdat)
anp <- get_bars2(sigdat = all_sigdat)

cnp
hnp
anp
```
```{r}
setwd("/workdir/users/acv46/EC_PROSeq/figures/promoters")
ggsave(plot = anp, filename = "PRO-seq_sigma_bargraph_regregions_v2.pdf", device = "pdf",
       width = 4, height = 2.5, units = "in", dpi = 300, useDingbats = FALSE)
```

### operon intersection between reg peak datasets
```{r}
require(dplyr)
require(ggvenn)
require(ggplot2)
library(eulerr)

op_int <- list(
  control = ec_c_peak_reg %>% filter(peakcount > 0) %>% select(op_name) %>% as_vector(),
  heat_shock = ec_h_peak_reg %>% filter(peakcount > 0) %>% select(op_name) %>% as_vector()
  )

ggvenn(op_int,
       fill_color = c("#7acfff","#0072B2FF"),
       fill_alpha = 0.3,
       text_size = 7,
       show_percentage = F)

setwd("/workdir/users/acv46/EC_PROSeq/figures/promoters")
ggsave(plot = plot(euler(op_int, shape = "circle"),
                   fills = c("#E69F00FF","#D55E00FF"),
                   edges = T,
                   fontsize = 20,
                   quantities = list(fontsize = 30),
                   fill_alpha = 0.2,
                   lwd = 5),
       filename = "promoter_reg100_venn_v2.pdf",
       device = "pdf", dpi = 300,
       useDingbats = F,
       height = 2,
       width = 3,
       units = "in")
```

### get GO description and TFs for operons with peak-containing reg regions
```{r}
require(dplyr)

# see "find peaks that fall within regulatory regions" section for ec_c_peak_reg object
# generate object with reg_ranges_100 object

op_int_id <- list(
  control = ec_c_peak_reg %>% filter(peakcount > 0) %>% select(op_id) %>% as_vector(),
  heat_shock = ec_h_peak_reg %>% filter(peakcount > 0) %>% select(op_id) %>% as_vector()
  )

# get GO terms for genes in operons

go_table <- function(op = op_int_id,
                     regdb = get_dataset(e_coli_regulondb_10.9, list_datasets(e_coli_regulondb_10.9)[2])) {
  
  getset <- function(set) {
    
    mf <- regdb %>% as_tibble %>%
      filter(operon_id %in% set) %>% select(operon_id, go_desc_mf)
    bp <- regdb %>% as_tibble %>%
      filter(operon_id %in% set) %>% select(operon_id, go_desc_bp)
    cc <- regdb %>% as_tibble %>%
      filter(operon_id %in% set) %>% select(operon_id, go_desc_cc)
    
    left_join(mf, bp) %>% left_join(., cc, by = "operon_id") %>% 
      select(operon_id, go_desc_bp) %>% unique() %>%
      select(go_desc_bp) %>% mutate(bplist = strsplit(go_desc_bp, "\t")) %>%
      unnest(bplist) %>% arrange(bplist) %>% select(bplist) %>%
      table %>% sort(decreasing = T) %>% head(n = 10)
    
  }
  
  list(
    both = getset(intersect(op_int_id$control, op_int_id$heat_shock)),
    cont = getset(setdiff(op_int_id$control, op_int_id$heat_shock)),
    heat = getset(setdiff(op_int_id$heat_shock, op_int_id$control))
  )
  
}

op_go <- go_table()

write_csv(x = tibble(heat_shock = paste0(names(op_go$heat), " (",op_go$heat,")"),
                     control = paste0(names(op_go$cont), " (",op_go$cont,")"),
                     both = paste0(names(op_go$both), " (",op_go$both,")")),
          file = "/workdir/users/acv46/EC_PROSeq/figures/promoters/table_reg100_GO_molFunc_top10_v1.csv",
          col_names = T)

# op_go$both %>% select(operon_id, go_desc_bp) %>% unique() %>% select(go_desc_bp) %>% mutate(bplist = strsplit(go_desc_bp, "\t")) %>% unnest(bplist) %>% arrange(bplist) %>% select(bplist) %>% table %>% sort

# get TF controlling expression of operons

op_int_id <- list(
  control = ec_c_peak_reg %>% filter(peakcount > 0) %>% select(op_id) %>% as_vector(),
  heat_shock = ec_h_peak_reg %>% filter(peakcount > 0) %>% select(op_id) %>% as_vector()
  )

# get GO terms for genes in operons

tf_table <- function(op = op_int_id,
                     regdb = get_dataset(e_coli_regulondb_10.9, list_datasets(e_coli_regulondb_10.9)[4])) {
  
  getset <- function(set) {
    
    tf <- regdb %>% as_tibble %>%
      filter(id %in% set) %>% select(id, tf_name) %>%
      unique() %>% select(tf_name) %>% mutate(tflist = strsplit(tf_name, ",")) %>%
      unnest(tflist) %>% arrange(tflist) %>% select(tflist) %>%
      table %>% sort(decreasing = T) %>% head(n = 10)
    
  }
  
  list(
    both = getset(intersect(op_int_id$control, op_int_id$heat_shock)),
    cont = getset(setdiff(op_int_id$control, op_int_id$heat_shock)),
    heat = getset(setdiff(op_int_id$heat_shock, op_int_id$control))
  )
  
}

op_tf <- tf_table()

```

### get transcription regulator identities of peak-containing regulatory regions
```{r}
reg_peak <- function(peakdat, tssdat) {
  
  require(dplyr)
  
  tdat <- tssdat %>% mutate(peakcount = 0)
  tlen <- nrow(tssdat)
  pdat <- read_csv(file = peakdat, col_names = T) %>%
    mutate(strand = ifelse(strand == "plus", "forward", "reverse"))
  for (i in 1:nrow(tdat)) {
    
    message(paste0("processing range ", i, "/", tlen))
    
    for(j in 1:nrow(pdat)) {
     
      if (as.numeric(pdat$position[j]) %in% as.numeric(tdat$tss[i]):as.numeric(tdat$op_start[i]) &
          pdat$strand[j] == tdat$strand[i]) {
        
        tdat$peakcount[i] <- tdat$peakcount[i] + 1
        
      } 
      
    }
  }
  
  tdat %>% ungroup %>% filter(peakcount > 0) %>%
    select(tf_name) %>% mutate(tflist = strsplit(tf_name, ",")) %>%
    unnest(tflist) %>% arrange(tflist) %>%
    select(tflist) %>% table %>% sort
  
}

setwd("/workdir/users/acv46/EC_PROSeq/figures/motifs")
ec_c_peak_reg_tf <- reg_peak("PRO-seq_motifs_control_3p_25_20_5_20_flipped_redo2.csv", reg_ranges)
#write_tsv(ec_c_peak_genes, "PRO-seq_motifs_control_3p_25_20_5_20_flipped_redo2_regranges.tsv")
ec_h_peak_reg_tf <- reg_peak("PRO-seq_motifs_heat-shock_3p_25_20_5_20_flipped_redo2.csv", reg_ranges)
#write_tsv(ec_h_peak_genes, "PRO-seq_motifs_hs_3p_25_20_5_20_flipped_redo2_regranges.tsv")

```

### barplot tallying peaks overlapping 5' UTR
```{r}
ec_c_peak_reg %>% mutate(sigma_factor = ifelse(grepl(",",sigma_factor), "mixed", sigma_factor)) %>%
  filter(peakcount > 0) %>% select(sigma_factor, peakcount) %>%
  arrange(factor(sigma_factor, levels = c("Sigma70","Sigma32","Sigma24","Sigma28","Sigma38","Sigma54","mixed"))) %>%
  ggplot() +
  geom_bar(mapping = aes(x = sigma_factor, y = peakcount),
           stat = "identity") +
  theme_classic() +
  coord_flip(ylim = c(0,170))

ec_h_peak_reg %>% mutate(sigma_factor = ifelse(grepl(",",sigma_factor), "mixed", sigma_factor)) %>%
  filter(peakcount > 0) %>% select(sigma_factor, peakcount) %>%
  ggplot() +
  geom_bar(mapping = aes(x = sigma_factor, y = peakcount),
           stat = "identity") +
  theme_classic() +
  coord_flip(ylim = c(0,170))
```

### get PRO-seq 3' end coverage +/- 500 bp around TSS, subset by sigma
```{r}
# input: pro_covdat and tss2op objects
# run as a job: 

tss_prox <- tibble()
context <- 500

for (i in 1:nrow(reg_ranges)) {
  
  tot <- nrow(reg_ranges)
  tssdat <- reg_ranges[i,]
  
  if (tssdat$strand == "forward") {
    
    upstrm <- as.numeric(tssdat$tss - context)
    dnstrm <- as.numeric(tssdat$tss + context)
    res <- pro_covdat %>% filter(type == "PRO-seq" &
                            strand == "plus" &
                            end == "3" &
                            position >= upstrm &
                            position <= dnstrm) %>%
      mutate(index = rep(-context:context, each = 2)) %>%
      mutate(sigma = tssdat$sigma_factor) %>%
      mutate(op_name = tssdat$op_name)
    
    tss_prox <- bind_rows(tss_prox, res)
    
  }
  
  if (tssdat$strand == "reverse") {
    
    upstrm <- as.numeric(tssdat$tss + context)
    dnstrm <- as.numeric(tssdat$tss - context)
    res <- pro_covdat %>% filter(type == "PRO-seq" &
                            strand == "minus" &
                            end == "3" &
                            position <= upstrm &
                            position >= dnstrm) %>%
      mutate(index = rep(context:-context, each = 2)) %>%
      mutate(sigma = tssdat$sigma_factor) %>%
      mutate(op_name = tssdat$op_name)
    
    tss_prox <- bind_rows(tss_prox, res)
    
  }
  
  message(paste0(i," / ", tot))
  
}
```

### plot above
```{r}
require(tidyverse)
#tss_prox <- read_csv("/workdir/users/acv46/EC_PROSeq/figures/motifs/PRO-seq_pausing_500bp_centertss.csv", col_names = T)
#trans_prox <- read_csv("/workdir/users/acv46/EC_PROSeq/figures/motifs/PRO-seq_pausing_500bp_centertrans.csv", col_names = T)

plotsigma <- function(plotdat, title, ypos) {

  counts <- plotdat %>% filter(!grepl(",", sigma)) %>%
    filter(index == 0, treatment == "control", strand == "plus", end == "3") %>%
    select(sigma) %>% table %>% as_tibble() %>% rename("sigma" = ".")
  
  plotdat2 <- left_join(plotdat, counts, by = "sigma")
  
  ggplot(data = plotdat2 %>%
           filter(!grepl(",", sigma)) %>%
           filter(index %in% c(-500:500)) %>%
           filter(strand == "plus")) + 
    geom_smooth(mapping = aes(x = index, y = value, color = treatment, fill = treatment)) +
    geom_text(mapping = aes(label = paste0(sigma,"\n","n = ",n)),
              x = -500,
              y = ypos,
              hjust = 0,
              vjust = 1,
              check_overlap = T) + 
    scale_color_manual(values = c("blue", "red")) + 
    scale_fill_manual(values = c("blue", "red")) + 
    geom_hline(yintercept = 0, color = "black") +
    geom_vline(xintercept = 0, color = "black", linetype = "dotted") +
    xlab("position") +
    ylab("Per-base read depth") +
    facet_wrap(~ sigma, nrow = 2) + 
    #theme_classic() + 
    ggtitle(title) +
    theme(strip.background = element_blank(),
          strip.text = element_blank(),
          panel.spacing = unit(0.2, "lines"),
          panel.background = element_rect(fill = "white"),
          panel.border = element_rect(colour = "black", size = 1, fill = NA),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank())
  
}

p1 <- plotsigma(tss_prox, "PRO-seq operon coverage profiles centered at right-most transcription start site", 3.8)
p2 <- plotsigma(trans_prox, "PRO-seq operon coverage profiles centered at first start codon", 4.2)

p1
p2

setwd("/workdir/users/acv46/EC_PROSeq/figures/promoters")
ggsave(filename = "proseq_perOperon_bySigma_centerTSS_500_v4.pdf",
       plot = p1, device = "pdf", width = 8, height = 6, units = "in",
       useDingbats = FALSE)
ggsave(filename = "proseq_perOperon_bySigma_centerStartCodon_500_v4.pdf",
       plot = p2, device = "pdf", width = 8, height = 6, units = "in",
       useDingbats = FALSE)

```

## motif sequence logos
### read in peak sequence data (or use tss-overlapping peaks from above)
```{r}
require(tidyverse)

pull_seqs <- function(plus) {
  
  dat <- read_csv(file = plus, col_names = T)
  dat
  
}

setwd("/workdir/users/acv46/EC_PROSeq/figures/motifs")
control_peaks <- pull_seqs("PRO-seq_motifs_control_3p_25_50_5_20.csv")
hs_peaks <- pull_seqs("PRO-seq_motifs_heat-shock_3p_25_50_5_20.csv")
```

### function to plot ggseqlogos, all peaks
```{r}
get_logos <- function(peaks){
  
  require(ggseqlogo)
  require(patchwork)
  require(tidyverse)
  require(staplr)
  
  # input is _seqs dataframe, CRISPR nameand strand
  
  # binnames <- peaks %>% select(bin) %>%
  #   unique() %>% as_vector()
  # 
  # sapply(binnames, function(xbin) {
    
    # pull data for plot title
    
    # numcontigs <- bindat %>% filter(bin == xbin) %>%
    #   select(contig) %>% nrow()
    # 
    # phy <- bindat %>% filter(bin == xbin) %>%
    #   select(k_name_P) %>% unique()
    # 
    # k_species <- bindat %>% filter(bin == xbin) %>%
    #   select(k_name_S) %>% unique()
    # 
    # g_species <- bindat %>% filter(bin == xbin) %>%
    #   select(g_species) %>% unique()
    # 
    # complete <- bindat %>% filter(bin == xbin) %>%
    #   select(completeness) %>% unique()
    # 
    # contam <- bindat %>% filter(bin == xbin) %>%
    #   select(contamination) %>% unique()
    # 
    # sample <- bindat %>% filter(bin == xbin) %>%
    #   select(sample) %>% unique()
    # 
    # numpeaks <- peaks %>% filter(bin == xbin) %>% nrow()
    
    # # pull full seqs to plot
    # 
    # fullseqs <- peaks %>% filter(bin == xbin) %>%
    #   select(sequence) %>% as_vector()
    
    # pull seqs and trim to -11 to +5 range
    
    trimseqs <- peaks %>% #filter(bin == xbin) %>%
      select(sequence) %>% as_vector() %>%
      str_sub(start = 10, end = 25)
    
    p1 <- ggseqlogo(trimseqs,
                    #col_scheme = cs1,
                    method = "bits") +
      theme(plot.margin = unit(c(0.1,0.1,0.1,0.1),"cm"),
            #plot.title = element_text(size = 10),
            aspect.ratio = 1/5,
            axis.text.x = element_blank())
      # ggtitle(paste0(sample, ", bin = ", xbin, "\n", 
      #                numcontigs, " contigs, ", numpeaks, " pause sites passing cutoff\n",
      #                "phylum = ", phy, "\n",
      #                "kraken species annotation = ", k_species, "\n",
      #                "gtdbtk species annotation = ", g_species, "\n",
      #                complete, "% complete, ", contam, "% contaminated"))
    
    p2 <- ggseqlogo(trimseqs,
                    #col_scheme = cs1,
                    method = "prob") +
      theme(plot.margin = unit(c(0.1,0.1,0.1,0.1),"cm"),
            #plot.title = element_text(size = 10),
            aspect.ratio = 1/5)
    
    p2$scales$scales[[1]] <- scale_x_continuous(breaks = c(1:16),
                                                labels = c(seq(from = -11, to = -1), c(1:5)))
    
    
    mergep <- p1 / p2
    
    mergep
  
}

setwd("/workdir/users/acv46/EC_PROSeq/figures/motifs")
get_logos(control_peaks)
get_logos(hs_peaks)

# pdf(name, useDingbats = FALSE,
#         height = 4,
#         width = 6)
#              
#     print(mergep)
#              
#     dev.off()
```

### function to plot ggseqlogos, tss peaks, promoters with known sigma factors
```{r}
get_logos2 <- function(peaks, sigdat, sigma, covdat) {
  
  # peaks is the subset peak file
  # sigdat is generated below
  # sigma is the chosen sigma factor to plot logo and coverage
  # covdat is the subset coverage data
  
  require(ggseqlogo)
  require(patchwork)
  require(tidyverse)
  require(staplr)
  require(glue)
  require(ggtext)
  
  highlight = function(x, pat, color = "black", family = "") {
    ifelse(grepl(pat, x),
           glue("<b style='font-family:{family}; color:{color}'>{x}</b>"),
           x)
    }
    
  barpal <- c("#56a3a6","#ffc857","#e9724c","#c5283d","#4e4187","#d30c7b")
  cs1 <- make_col_scheme(chars = c('A', 'T', 'C', 'G'),
                         cols = c('#009603', '#bd0010', '#0000bd', 'black'))
    
    # pull seqs and trim to -11 to +5 range
    
    trimseqs <- peaks %>% filter(sigma_factor == sigma) %>% 
      select(sequence) %>% as_vector() %>%
      substr(start = 10, stop = 25)
    
    p1 <- ggseqlogo(trimseqs,
                    col_scheme = cs1,
                    method = "bits") +
      #facet_grid(sigma ~ .) +
      theme(axis.text.x = element_text(size = 8, angle = 0)
            #plot.margin = unit(c(0.1,0.1,0.1,0.1),"cm"),
            #plot.title = element_text(size = 10),
            #aspect.ratio = 1/3,
            ) +
      theme_classic() +
      annotate('rect', xmin = 10.5, xmax = 12.5,
               ymin = -0.05, ymax = Inf,
               alpha = .1, col = 'black', fill = 'yellow')
    
    plotpeaks <- peaks %>% filter(sigma_factor == sigma) %>%
      select(position, strand.x) %>%
      mutate(start = ifelse(strand.x == "plus", as.numeric(position) - 10, as.numeric(position) - 5)) %>%
      mutate(end = ifelse(strand.x == "plus", as.numeric(position) + 5, as.numeric(position) + 10))
    
    peakcov <- apply(plotpeaks, MARGIN = 1, function(pk) {
      
      if (pk[2] == "plus") {
        
        covdat %>% filter(strand == "plus") %>%
          filter(end == "3") %>%
          filter(position %in% c((as.numeric(pk[1]) - 10):(as.numeric(pk[1]) + 5))) %>%
          select(norm) %>% mutate(index = c(1:16))
        
      } else if (pk[2] == "minus") {
        
        covdat %>% filter(strand == "minus") %>%
          filter(end == "3") %>%
          filter(position %in% c((as.numeric(pk[1]) - 5):(as.numeric(pk[1]) + 10))) %>%
          select(norm) %>% mutate(index = c(16:1)) %>% arrange(.,index)
        
      }
      
    }) %>% bind_rows() %>% group_by(index) %>%
      mutate(mean = mean(norm)) %>% mutate(se = (sd(norm))/sqrt(length(norm))) %>%
      select(index, mean, se) %>% distinct()
    
    p2 <- ggplot(data = peakcov,
                 mapping = aes(x = index, y = mean)) +
      geom_bar(stat = "identity", color = "red",
               size = 0.5, fill = "red") +
      geom_errorbar(mapping = aes(ymin = mean - se, ymax = mean + se),
                    width = 0.2) +
      scale_y_continuous(breaks = c(0, 1.2 * max(peakcov$norm), 10),
                         limits = c(0, 1.2 * max(peakcov$norm))) +
      theme_classic() + 
      ggtitle(paste0(sigma, " promoter pausing")) +
      ylab("Per-base RPM") +
      xlab("")
    
    p1$scales$scales[[1]] <- scale_x_continuous(breaks = c(1:16),
                                                labels = c(seq(from = -11, to = -1), c(1:5)))
    p2$scales$scales[[1]] <- scale_x_continuous(breaks = c(1:16),
                                                labels = c(seq(from = -11, to = -1), c(1:5)))
    
    p3 <- ggplot(sigdat, mapping = aes(x = sigma, fill = sigma, y = as.numeric(count))) +
      geom_bar(stat = "identity") +
      geom_text(mapping = aes(label = count, position = sigma), hjust = -0.2) +
      theme_classic() +
      xlab("") +
      theme(legend.position = "none",
            #aspect.ratio = 2,
            axis.text.y = element_markdown(size = 12),
            #axis.text.y = element_text(size = 12),
            axis.text.x = element_text(size = 10)) +
      scale_y_continuous(breaks = seq(0,50,10), limits = c(0,50),
                         name = "count") +
      scale_x_discrete(labels = function(x) highlight(x, sigma, color = "red")) +
      scale_fill_manual(values = barpal) +
      coord_flip()
    
    p3 - (p2 / p1) +
      plot_layout(widths = c(1, 2))
    
    

  
}

cnames <- c("sigma","count")
control_sigdat <- table(ec_control_tss_nounk$sigma_factor) %>% as.data.frame(stringsAsFactors = FALSE)
#control_sigdat <- rbind(control_sigdat, c("Sigma24", "0"))
control_sigdat <- rbind(control_sigdat, c("Sigma54", "0"))
colnames(control_sigdat) <- cnames
control_sigdat$sigma <- as.character(control_sigdat$sigma)
control_sigdat$sigma <- factor(control_sigdat$sigma, levels = rev(c("Sigma70", "Sigma32", "Sigma24", "Sigma38", "Sigma54", "unknown")))


hs_sigdat <- table(ec_hs_tss_nounk$sigma_factor) %>% as.data.frame(stringsAsFactors = FALSE)
colnames(hs_sigdat) <- cnames
hs_sigdat$sigma <- as.character(hs_sigdat$sigma)
hs_sigdat$sigma <- factor(hs_sigdat$sigma, levels = rev(c("Sigma70", "Sigma32", "Sigma24", "Sigma38", "Sigma54", "unknown")))

# plot it

setwd("/workdir/users/acv46/EC_PROSeq/figures/motifs")
cnp <- get_logos2(peaks = ec_control_tss_nounk,
                  sigdat = control_sigdat,
                  sigma = "Sigma70",
                  covdat = pro_covdat %>% filter(treatment == "control"))
hsp <- get_logos2(peaks = ec_hs_tss_nounk,
                  sigdat = hs_sigdat,
                  sigma = "Sigma32",
                  covdat = pro_covdat %>% filter(treatment == "heat shock"))

cnp
hsp

# pdf("control_promoter_peaks_noUnk_v2.pdf", useDingbats = FALSE,
#     height = 3,
#     width = 6)
# 
#     print(cnp)
# 
# dev.off()
# 
# pdf("hs_promoter_peaks_noUnk_v2.pdf", useDingbats = FALSE,
#     height = 3,
#     width = 6)
# 
#     print(hsp)
# 
# dev.off()

```
### function to plot ggseqlogos, tss peaks, all promoters
```{r}
get_logos2 <- function(peaks){
  
  require(ggseqlogo)
  require(patchwork)
  require(tidyverse)
  require(staplr)
    
  #barpal <- c("#56a3a6","#ffc857","#e9724c","#c5283d","#4e4187","#d30c7b")
    
    # pull seqs and trim to -11 to +5 range
    
    trimseqs <- peaks %>% 
      select(sequence) %>% as_vector() %>%
      str_sub(start = 10, end = 25)
    
    p1 <- ggseqlogo(trimseqs,
                    #col_scheme = cs1,
                    method = "bits") +
      theme(plot.margin = unit(c(0.1,0.1,0.1,0.1),"cm"),
            #plot.title = element_text(size = 10),
            aspect.ratio = 1/3,
            axis.text.x = element_blank())
    
    p2 <- ggseqlogo(trimseqs,
                    #col_scheme = cs1,
                    method = "prob") +
      theme(plot.margin = unit(c(0.1,0.1,0.1,0.1),"cm"),
            #plot.title = element_text(size = 10),
            aspect.ratio = 1/3)
    
    p2$scales$scales[[1]] <- scale_x_continuous(breaks = c(1:16),
                                                labels = c(seq(from = -11, to = -1), c(1:5)))
    
    # p3 <- ggplot(sigdat, mapping = aes(x = sigma, fill = sigma, y = as.numeric(count))) +
    #   geom_bar(stat = "identity") +
    #   theme_classic() +
    #   xlab("") +
    #   theme(legend.position = "none",
    #         aspect.ratio = 2,
    #         axis.text.y = element_text(size = 12),
    #         axis.text.x = element_text(size = 10)) +
    #   scale_y_continuous(breaks = seq(0, 20, 5), limits = c(0, 20),
    #                      name = "count") +
    #   scale_fill_manual(values = barpal) +
    #   coord_flip()
    
    mergep <- p1 / p2
    mergep
    
}

# cnames <- c("sigma","count")
# control_sigdat <- table(ec_control_tss$sigma_factor) %>% as.data.frame(stringsAsFactors = FALSE)
# control_sigdat <- rbind(control_sigdat, c("Sigma24", "0"))
# control_sigdat <- rbind(control_sigdat, c("Sigma54", "0"))
# colnames(control_sigdat) <- cnames
# control_sigdat$sigma <- as.character(control_sigdat$sigma)
# control_sigdat$sigma <- factor(control_sigdat$sigma, levels = rev(c("Sigma70", "Sigma32", "Sigma24", "Sigma38", "Sigma54", "unknown")))
# 
# 
# hs_sigdat <- table(ec_hs_tss$sigma_factor) %>% as.data.frame(stringsAsFactors = FALSE)
# colnames(hs_sigdat) <- cnames
# hs_sigdat$sigma <- as.character(hs_sigdat$sigma)
# hs_sigdat$sigma <- factor(hs_sigdat$sigma, levels = rev(c("Sigma70", "Sigma32", "Sigma24", "Sigma38", "Sigma54", "unknown")))

setwd("/workdir/users/acv46/EC_PROSeq/figures/motifs")
cnp <- get_logos2(ec_control_tss_unk)
hsp <- get_logos2(ec_hs_tss_unk)

cnp
hsp

# pdf("control_promoter_peaks_Unkonly_v1.pdf", useDingbats = FALSE,
#     height = 4,
#     width = 6)
# 
#     print(cnp)
# 
# dev.off()
# 
# pdf("hs_promoter_peaks_Unkonly_v1.pdf", useDingbats = FALSE,
#     height = 4,
#     width = 6)
# 
#     print(hsp)
# 
# dev.off()

```
## for peaks overlapping terminators, get terminator sequences for Vienna RNAheat analysis
```{r}
# seqdat from "read in fasta" section above

get_term_seqs <- function(peakdat, seqdat, range) {
  
  peaks <- peakdat %>%
    filter(type == "terminator") %>%
    arrange(as.numeric(obj_posleft)) %>%
    na.omit()
  
  apply(X = peaks, MARGIN = 1,
        FUN = function(pk) {
          
          start <- as.numeric(pk[10]) 
          end   <- as.numeric(pk[11])
          startex <- as.numeric(pk[10]) - range
          endex   <- as.numeric(pk[11]) + range
          strand <- as.character(pk[12])
          peakpos <- as.numeric(pk[2])
          
          if (strand == "forward") {
            
            term <- seqdat["NC_000913.3"][[1]][start:end] %>%
              as.character() %>%
              gsub(pattern = "T", replacement = "U")
            
            termextra <- seqdat["NC_000913.3"][[1]][startex:endex] %>%
              as.character() %>%
              gsub(pattern = "T", replacement = "U")
            
            conpos <- (peakpos - start) + 1
            
            tvec <- c(terminator = term,
                      context = termextra,
                      start = start,
                      end = end, 
                      peak_position = peakpos,
                      relative_position = conpos,
                      strand = strand)
            tvec
            
          } else if (strand == "reverse") {
            
            term <- seqdat["NC_000913.3"][[1]][start:end] %>%
              reverseComplement() %>%
              as.character() %>%
              gsub(pattern = "T", replacement = "U")
            
            termextra <- seqdat["NC_000913.3"][[1]][startex:endex] %>%
              reverseComplement() %>%
              as.character() %>%
              gsub(pattern = "T", replacement = "U")
            
            conpos <- (end - peakpos) + 1
            
            tvec <- c(terminator = term,
                      context = termextra,
                      start = start,
                      end = end, 
                      peak_position = peakpos,
                      relative_position = conpos,
                      strand = strand)
            tvec
            
          }
          
        }) %>% as.matrix() %>% t() %>% as.tibble()
  
}

c_terms <- get_term_seqs(ec_control_peak_all, ec_fasta, 10)
h_terms <- get_term_seqs(ec_hs_peak_all, ec_fasta, 10)
```

## for peaks overlapping genes, get sequences flanking peak (subset)
```{r}
# seqdat from "read in fasta" section above

get_term_seqs <- function(peakdat, seqdat, range) {
  
  require(tidyverse)
  require(Biostrings)
  
  peaks <- peakdat %>%
    filter(type == "gene") %>%
    arrange(as.numeric(obj_posleft)) %>%
    na.omit()
  
  apply(X = peaks, MARGIN = 1,
        FUN = function(pk) {
          
          start <- as.numeric(pk[10]) 
          end   <- as.numeric(pk[11])
          startex <- as.numeric(pk[10]) - range
          endex   <- as.numeric(pk[11]) + range
          strand <- as.character(pk[12])
          peakpos <- as.numeric(pk[2])
          name <- pk[9]
          
          if (strand == "forward") {
            
            term <- seqdat["NC_000913.3"][[1]][start:end] %>%
              as.character() %>%
              gsub(pattern = "T", replacement = "U")
            
            termextra <- seqdat["NC_000913.3"][[1]][startex:endex] %>%
              as.character() %>%
              gsub(pattern = "T", replacement = "U")
            
            conpos <- (peakpos - start) + 1
            
            tvec <- c(terminator = term,
                      context = termextra,
                      start = start,
                      end = end, 
                      peak_position = peakpos,
                      relative_position = conpos,
                      strand = strand,
                      name = name)
            tvec
            
          } else if (strand == "reverse") {
            
            term <- seqdat["NC_000913.3"][[1]][start:end] %>%
              reverseComplement() %>%
              as.character() %>%
              gsub(pattern = "T", replacement = "U")
            
            termextra <- seqdat["NC_000913.3"][[1]][startex:endex] %>%
              reverseComplement() %>%
              as.character() %>%
              gsub(pattern = "T", replacement = "U")
            
            conpos <- (end - peakpos) + 1
            
            tvec <- c(terminator = term,
                      context = termextra,
                      start = start,
                      end = end, 
                      peak_position = peakpos,
                      relative_position = conpos,
                      strand = strand,
                      name = name)
            tvec
            
          }
          
        }) %>% as.matrix() %>% t() %>% as_tibble()
  
}

c_peak_genes <- get_term_seqs(ec_control_peak_all, ec_fasta, 10)
h_peak_genes <- get_term_seqs(ec_hs_peak_all, ec_fasta, 10)
```

## function to plot coverage over input range
```{r}
plot_range <- function(cov, peakdat, range) {
  
  name <- peakdat[8]
  
  xmin <- as.numeric(peakdat[5]) - range
  xmax <- as.numeric(peakdat[5]) + range
  
  plotcov <- cov %>% filter(position %in% c(xmin:xmax))
  ymax <- max(abs(plotcov$norm))
  
  # tbox <- data.frame(x1 = as.numeric(peakdat[5]),
  #                    x2 = as.numeric(peakdat[5]),
  #                    y1 = -ymax * 0.2,
  #                    y2 = ymax * 0.2,
  #                    stringsAsFactors = F)
  
  if (peakdat[7] == "forward") {
    
    tpeak <- data.frame(xend = as.numeric(peakdat[5]),
                        x = as.numeric(peakdat[5]),
                        yend = -1 * ymax * 0.1,
                        y = -1 * ymax * 0.3,
                        index = "PRO-seq_3",
                        stringsAsFactors = F)
    
  } else if (peakdat[7] == "reverse") {
    
    tpeak <- data.frame(xend = as.numeric(peakdat[5]),
                        x = as.numeric(peakdat[5]),
                        yend = ymax * 0.1,
                        y = ymax * 0.3,
                        index = "PRO-seq_3",
                        stringsAsFactors = F)
    
  }
  
  pc <- ggplot() +
             geom_area(data = plotcov,
                       mapping = aes(x = position, y = norm, fill = strand)) +
    facet_grid(index ~ treatment) +
    scale_fill_manual(values = c("blue","red")) +
    # coord_cartesian(xlim = c(xmin, xmax),
    #                 ylim = c(-ymax - (0.02 * ymax), ymax + (0.02 * ymax))) +
    # geom_rect(data = tbox,
    #           mapping = aes(xmin = x1, xmax = x2,
    #                         ymin = y1, ymax = y2),
    #           fill = "yellow",
    #           alpha = 0.2) +
    geom_segment(data = tpeak,
                 mapping = aes(x = x, y = y, xend = xend, yend = yend),
                 size = 1,
                 arrow = arrow(length = unit(0.05, "npc")),
                 lineend = "butt", linejoin = "mitre", color = "black") +
    theme_classic() +
    ggtitle(paste0(name, ", terminator ", peakdat[3],
                   " - ", peakdat[4], ", ", peakdat[7])) +
    geom_hline(yintercept = 0, color = "black")
           
  print(pc)
  
}

```

### constrain data to plot
```{r}
# read in coverage object from "read in coverage data, bedtools corrected" chunk above

subcov <- coverage %>% mutate(norm = ifelse(strand == "plus", norm, -1 * norm)) %>%
  mutate(index = paste0(type,"_",end)) %>%
  filter(index %in% c("PRO-seq_3", "PRO-seq_full", "RNA-seq_full"))

# setwd("/workdir/users/acv46/EC_PROSeq/pileup/iter_correct")
# write_csv(subcov, "sub_coverage_formatted.txt")
#rm(coverage)
```

### run plot function
```{r}

apply(c_peak_genes[200:220,], MARGIN = 1, FUN = plot_range, cov = ungroup(subcov), range = 100)
apply(h_peak_genes[200:220,], MARGIN = 1, FUN = plot_range, cov = ungroup(subcov), range = 100)

#plot_range(ungroup(subcov), c_terms, 100)

# DNAK test
# plot_range(subcov, peakdat = c("AAA","GGG",12163,15298,12887,1,"forward"), 100)
# plot_range(subcov, peakdat = c("AAA","GGG",12850,12950,12887,1,"forward"), 100)
# plot_range(subcov, peakdat = c("AAA","GGG",274,310,284,1,"forward"), 100)
# plot_range(subcov, peakdat = c("AAA","GGG",274,310,307,1,"forward"), 100)
```



# small RNA trancripts

## get small RNA coords from regulonDB
```{r}
require(tidyverse)
e_coli_regulondb_10.9 <- regulondb(database_conn = connect_database(),
                              organism = "E.coli",
                              database_version = "10.9",
                              genome_version = "NC_000913.3")

svec <- get_dataset(e_coli_regulondb_10.9, list_datasets(e_coli_regulondb_10.9)[1]) %>%
                         as_tibble %>% filter(type == "sRNA interaction") %>% select(name) %>%
                         as_vector() %>% str_remove(pattern = " sRNA.*") %>% unique()

ec_sRNAs <- get_dataset(e_coli_regulondb_10.9, list_datasets(e_coli_regulondb_10.9)[1]) %>%
  as_tibble %>% filter(name %in% svec)
```

## read in coverage data (from "Pause Sites, take 2")
```{r}
coverage <- read_csv("/workdir/users/acv46/EC_PROSeq/pileup/iter_correct/all_coverage_formatted.txt")
# flip orintation of plus and minus, just for fun
# 3' and 5' ends must also be flipped for correct orientation
# get normalized values by grouping lib types
## normalize based on full coverage values
coverage <- coverage %>% mutate(strand1 = ifelse(strand == "plus", "minus", "plus")) %>%
  select(-strand) %>% dplyr::rename(strand = strand1) %>%
  mutate(end1 = ifelse(end == "3", "5", ifelse(end == "5", "3", "full"))) %>%
  select(-end) %>% dplyr::rename(end = end1)
  # group_by(type, treatment, end) %>%
  # mutate(norm = (value / sum(value)) * 10^6) %>%
  # ungroup()

cp_sum <- coverage %>% filter(end == "full" & treatment == "control" & type == "PRO-seq") %>% select(value) %>% sum()
hp_sum <- coverage %>% filter(end == "full" & treatment == "heat shock" & type == "PRO-seq") %>% select(value) %>% sum()
cr_sum <- coverage %>% filter(end == "full" & treatment == "control" & type == "RNA-seq") %>% select(value) %>% sum()
hr_sum <- coverage %>% filter(end == "full" & treatment == "heat shock" & type == "RNA-seq") %>% select(value) %>% sum()

coverage <- coverage %>% mutate(norm = ifelse(treatment == "control" & type == "PRO-seq", (value / cp_sum) * 10^9,
                                              ifelse(treatment == "heat shock" & type == "PRO-seq", (value / hp_sum) * 10^9,
                                                     ifelse(treatment == "control" & type == "RNA-seq", (value / cr_sum) * 10^9,
                                                            ifelse(treatment == "heat shock" & type == "RNA-seq", (value / hr_sum) * 10^9, NA)
                                                            )
                                                     )
                                              )
                                )

covdat <- coverage %>%
  mutate(value = ifelse(strand == "minus", -value, value)) %>%
  mutate(norm = ifelse(strand == "minus", -norm, norm)) %>%
  mutate(type = ifelse(type == "RNA-seq", "RNAseq", type)) %>%
  mutate(lab = ifelse(end == "full",
                      paste0(type," ",end),
                      paste0(type," ",end,"' end")))
```

## plot coverage
```{r}
require(patchwork)
require(staplr)
require(tidyverse)
require(regutools)
require(ggrepel)

setwd("/workdir/users/acv46/EC_PROSeq/figures/sRNA")
oldfiles <- dir(path = ".", pattern = "*_partial.pdf")
file.remove(file.path(".", oldfiles))

apply(X = ec_sRNAs[1,], MARGIN = 1, function(sRNA) {
  
  tL <- as.numeric(sRNA[4])
  tR <- as.numeric(sRNA[5])
  
  # just sRNA and buffer
  buffer <- 30
  xmin <- ifelse(tL - buffer > 0, tL - buffer, 1)
  xmax <- ifelse(tR + buffer <= max(covdat$position), tR + buffer, max(covdat$position))
  cov <- covdat %>% filter(position >= xmin & position <= xmax) %>%
    select(-c(type,end))
  ymax <- max(abs(cov$norm))
  str <- ifelse(sRNA[6] == "forward", -1, 1)
  
  b1 <- round(xmin,nchar(xmin - 4))
  b2 <- round(xmax,nchar(xmin - 4))
  breaks <- seq(from = b1, to = b2, by = (b2 - b1) / 3)
  breaks <- breaks[which(breaks >= xmin & breaks <= xmax)]
  
  # https://livebook.manning.com/book/exploring-data-with-r/chapter-10/v-5/38
  
  pt <- ggplot(data = cov) +
    geom_area(mapping  = aes(x = position, y = norm, linetype = strand),
              fill = "red") +
    geom_text(mapping = aes(x = xmin,
                            y = str * 0.75 * ymax,
                            label = lab),
             size = 3,
             check_overlap = TRUE,
             hjust = 0) +
    scale_linetype_manual(values = c(1,1)) +
    facet_grid(lab ~ treatment) + 
    scale_x_continuous(breaks = breaks,
                       labels = sprintf("%.2f", (breaks / 1000))) +
    coord_cartesian(ylim = c(-ymax - (0.05 * ymax), ymax + (0.05 * ymax))) +
    theme_classic() + 
    theme(legend.position = "none",
          strip.background.y = element_blank(),
          strip.text.y = element_blank()) +
    geom_hline(yintercept = 0,
               color = "black") +
    xlab("position (kb)") +
    ylab("coverage per nt per 10^9 nt sequenced") +
    annotate("segment",
             x = ifelse(sRNA[6] == "forward", tL, tR),
             xend = ifelse(sRNA[6] == "forward", tR, tL),
             y = str * ymax * 0.3,
             yend = str * ymax * 0.3,
             size = 0.7,
             arrow = arrow(type = "closed", length = unit(0.075, "npc")),
             color = "black",
             alpha = 1) +
    ggtitle(paste0(sRNA[3]))
  
  # sRNA and more context
  buffer2 <- 2000
  xmin2 <- ifelse(tL - buffer2 > 0, tL - buffer2, 1)
  xmax2 <- ifelse(tR + buffer2 <= max(covdat$position), tR + buffer2, max(covdat$position))
  cov2 <- covdat %>% filter(position >= xmin2 & position <= xmax2) %>%
    select(-c(type)) %>% filter(end == "full") %>%
    mutate(lab2 = paste0(lab," ", treatment))
  ymax2 <- max(abs(cov2$norm))
  
  b1_ <- round(xmin2,nchar(xmin2 - 4))
  b2_ <- round(xmax2,nchar(xmin2 - 4))
  breaks2 <- seq(from = b1_, to = b2_, by = (b2_ - b1_) / 2)
  breaks2 <- breaks2[which(breaks2 >= xmin2 & breaks <= xmax2)]
  
  # https://livebook.manning.com/book/exploring-data-with-r/chapter-10/v-5/38
  
  pt2 <- ggplot(data = cov2) +
    geom_area(mapping  = aes(x = position, y = norm, linetype = strand),
              fill = "red") +
    geom_text(mapping = aes(x = xmin2,
                            y = str * 0.75 * ymax2,
                            label = lab2),
             size = 3,
             check_overlap = TRUE,
             hjust = 0) +
    scale_linetype_manual(values = c(1,1)) +
    facet_grid(lab2 ~ .) + 
    scale_x_continuous(breaks = breaks2,
                       labels = sprintf("%.2f", (breaks2 / 1000))) +
    coord_cartesian(ylim = c(-ymax2 - (0.05 * ymax2), ymax2 + (0.05 * ymax2))) +
    theme_classic() + 
    theme(legend.position = "none",
          strip.background.y = element_blank(),
          strip.text.y = element_blank(),
          axis.text.x = element_blank()) +
    geom_hline(yintercept = 0,
               color = "black") +
    xlab("") +
    ylab("") +
    annotate("segment",
             x = abs(tL + tR) / 2,
             xend = abs(tL + tR) / 2,
             y = str * ymax2 * 0.6,
             yend = str * ymax2 * 0.2,
             size = 0.7,
             arrow = arrow(type = "closed", length = unit(0.075, "npc")),
             color = "black",
             alpha = 1)
  
  pg <- get_dataset(e_coli_regulondb_10.9, list_datasets(e_coli_regulondb_10.9)[1]) %>%
    as_tibble %>% filter(posleft >= xmin2 & posright <= xmax2 & type == "gene") %>%
    mutate(molecule = "NC_000913.3") %>%
    mutate(orientation = ifelse(strand == "forward", 1, -1)) %>%
    mutate(start = posleft) %>% mutate(end = posright) %>% select(-c(id,type,description,posleft,posright)) %>%
    mutate(middle = as.numeric(start + end) / 2) %>%
             ggplot(data = .,
                        mapping = aes(xmin = start,
                         xmax = end,
                         x = middle,
                         y = molecule,
                         fill = name,
                         label = name,
                         forward = orientation)) +
             geom_gene_arrow(arrowhead_width = grid::unit(2, "mm"),
                    arrowhead_height = grid::unit(4, "mm"),
                    arrow_body_height = grid::unit(4, "mm")) +
              geom_label_repel(mapping = aes(x = middle, label = name),
                        angle = 90, size = 2.5, vjust = 0, hjust = -0.5) +
    scale_y_discrete(expand = expand_scale(mult = c(2,4))) +
              #scale_fill_manual(values = pal) +
    coord_cartesian(xlim = c(xmin2, xmax2),
                    clip = "off") +
    scale_x_continuous(breaks = breaks2,
                       labels = sprintf("%.2f", (breaks2 / 1000))) +
              theme_genes() +
              theme(legend.position = "none",
                    axis.text.y = element_blank(),
                    axis.ticks.y = element_blank(),
                    #axis.text.x = element_blank(),
                    #axis.ticks.x = element_blank(),
                    axis.title.y = element_blank()) +
    xlab("position (kb)") +
    ylab("")
  
  merge1 <- pt2 / pg +
    plot_layout(ncol = 1, nrow = 2,
                heights = c(5,1))
  
  merge2 <- pt + merge1 + 
    plot_layout(ncol = 2, nrow = 1,
                heights = c(5,5))
  
  merge2
  
  # ggsave(filename = paste(sRNA[1], "partial.pdf", sep = "_"),
  #        plot = merge2,
  #        device = cairo_pdf,
  #        dpi = 400,
  #        width = 6,
  #        height = 4)
  
})


# pdflist <- list.files(path = ".", pattern = "partial.pdf")
# staple_pdf(input_files = pdflist,
#            output_filepath = file.path(".", "ec_sRNA_merged_v7.pdf"))
# do.call(file.remove, list(pdflist))
```
