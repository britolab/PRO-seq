---
title: "EC_peaks"
author: "Albert Vill"
date: "1/25/2022"
output: html_document
---

# Homer autocorrelation plots
```{r}

autocorr <- function(autocorr_dat){

  #library(tidyverse)

  tags <- read.table(autocorr_dat, sep = "\t", header = T)
  colnames(tags) <- c("distance","same","opposite")

  tags <- tags %>%
    select(distance, same, opposite) %>%
    gather(key = "variable", value = "value", -distance)

  ggplot(tags, aes(x = distance, y = value)) + 
    geom_line(aes(color = variable)) + 
    scale_color_manual(values = c("darkred", "steelblue")) +
    theme_classic()

}
```
```{r}
setwd("/workdir/users/acv46/EC_PROSeq/homer")

autocorr("RCD2/tagdir/tagAutocorrelation.txt")

```

# Promoter proximal coverage

## (defunct, use code below) retrieve regulonDB and create GRanges objects 
```{r}
require(regutools)
## Build a regulondb object
## stores database at /home/acv46/.cache/AnnotationHub
e_coli_regulondb_10.9 <- regulondb(database_conn = connect_database(),
                              organism = "E.coli",
                              database_version = "10.9",
                              genome_version = "NC_000913.3")

#list_datasets(e_coli_regulondb)
#list_attributes(e_coli_regulondb, dataset = "PROMOTER")

## datasets

promoters <- get_dataset(e_coli_regulondb_10.9, 
            dataset = "PROMOTER",
            attributes = c("id","name","strand","tss","sigma_factor","regulated_operon")) %>%
  as_tibble(.)

promoters_sub <- promoters[-grep(",",promoters$sigma_factor),]
promoters_sub$sigma_factor[is.na(promoters_sub$sigma_factor)] <- "unknown"

ops <- get_dataset(e_coli_regulondb_10.9, 
            dataset = "OPERON",
            attributes = c("id","name","total_sigma","sigma_name")) %>%
  as_tibble(.)

ops_sub <- ops[ops$total_sigma == 1,]

```

## (defunct, use code below) subset promoter regulondb dataset to get promoter closes to beginning of operon
```{r}
library(purrr)

closest <- function(op_name, pro_list){
  
  set <- pro_list[which(pro_list$regulated_operon == op_name),]
  str <- set$strand %>% unique()
  
  if (str == "forward") {
    
    yeet <- set[which(set$tss == max(set$tss)),]
    
  } else if (str == "reverse") {
    
    yeet <- set[which(set$tss == min(set$tss)),]
    
  }
  
  yeet
  
}

unique_ops <- unique(promoters_sub$regulated_operon) %>% na.omit()
closest_promoters <- lapply(unique_ops, closest, pro_list = promoters_sub) %>% purrr::reduce(full_join)
```

## (use this) get set of operons controlled by single promoters of a single type
```{r}
require(regutools)
## Build a regulondb object
## stores database at /home/acv46/.cache/AnnotationHub
e_coli_regulondb_10.9 <- regulondb(database_conn = connect_database(),
                              organism = "E.coli",
                              database_version = "10.9",
                              genome_version = "NC_000913.3")

# get vector of promoters
promset <- get_dataset(e_coli_regulondb_10.9, 
            dataset = "OPERON") %>% as_tibble() %>%
  filter(total_promoter == 1 & total_sigma == 1) %>%
  select(promoter_name) %>% as_vector()

promoters <- get_dataset(e_coli_regulondb_10.9, 
                         dataset = "PROMOTER",
                         attributes = c("id","name","strand","tss","sigma_factor","regulated_operon")) %>%
  as_tibble() %>% filter(name %in% promset) %>%
  na.omit() %>% mutate(count = c(1:n()))
```

## manually curated promoter data -- superseded by regulonDB object
```{r}
setwd("/workdir/users/acv46/EC_PROSeq/")

# # regulonDB promoter data
# # promoters subset to include only the closest promoter to each unique operon
promoters_old <- read_delim(file = "index/U00096.3/regulonDB/closest_promoters.txt",
                        delim = "\t",
                        col_names = c("EC_ID","tss","strand","position","sigma","operon_ID"))

## relabel "NA" as "unknown" for sigma
promoters_old$sigma <- replace_na(promoters_old$sigma, "unknown")

## remove rows where strand or position are NA
promoters_old <- promoters_old %>% drop_na()
```

## read in and clean up counts data (iter2)
```{r}
#library(tidyverse)

setwd("/workdir/users/acv46/EC_PROSeq/")

# PRO-seq and RNA-seq coverage data
# use interation 2, see readme in file directory
coverage <- read_delim(file = "pileup/iter2/all_coverage.txt",
                       delim = "\t")

## normalize to rpm and subset for manageability
# size of window over which coverage is calculated
window <- 250

coverage$PCm_norm <- coverage$PC_minus / (sum(coverage$PC_minus + coverage$PC_plus) / 10^6)
coverage$PCp_norm <- coverage$PC_plus / sum(coverage$PC_minus + coverage$PC_plus) * 10^6
coverage$PHm_norm <- coverage$PH_minus / sum(coverage$PH_minus + coverage$PH_plus) * 10^6
coverage$PHp_norm <- coverage$PH_plus / sum(coverage$PH_minus + coverage$PH_plus) * 10^6
coverage$RCm_norm <- coverage$RC_minus / sum(coverage$RC_minus + coverage$RC_plus) * 10^6
coverage$RCp_norm <- coverage$RC_plus / sum(coverage$RC_minus + coverage$RC_plus) * 10^6
coverage$RHm_norm <- coverage$RH_minus / sum(coverage$RH_minus + coverage$RH_plus) * 10^6
coverage$RHp_norm <- coverage$RH_plus / sum(coverage$RH_minus + coverage$RH_plus) * 10^6

## normalization values from samtools flagstat
## multiply PRO-seq reads by 2x average read length since only 3' position is used

# coverage$PCm_norm <- (coverage$PC_minus / 3480968) * 10^6
# coverage$PCp_norm <- (coverage$PC_plus / 3480968) * 10^6
# coverage$PHm_norm <- (coverage$PH_minus / 3265929) * 10^6
# coverage$PHp_norm <- (coverage$PH_plus / 3265929) * 10^6
# coverage$RCm_norm <- (coverage$RC_minus / 6391339) * 10^6
# coverage$RCp_norm <- (coverage$RC_plus / 6391339) * 10^6
# coverage$RHm_norm <- (coverage$RH_minus / 5023896) * 10^6
# coverage$RHp_norm <- (coverage$RH_plus / 5023896) * 10^6

cov_norm <- coverage[,-c(3:10)]
treatments <- colnames(cov_norm)[3:10]
#rm(coverage)
```

## read in and clean up counts data (iter_correct)
```{r}
require(dplyr)

setwd("/workdir/users/acv46/EC_PROSeq/")

# PRO-seq and RNA-seq coverage data
# use interation 2, see readme in file directory
coverage <- read_csv(file = "pileup/iter_correct/all_coverage_formatted.txt", col_names = T)

## normalize to rpm and subset for manageability
# size of window over which coverage is calculated

# pc_sum <- coverage %>% filter(type == "PRO-seq" & treatment == "control" & end == "full") %>% select(value) %>% sum()
# rc_sum <- coverage %>% filter(type == "RNA-seq" & treatment == "control" & end == "full") %>% select(value) %>% sum()
# ph_sum <- coverage %>% filter(type == "PRO-seq" & treatment == "heat shock" & end == "full") %>% select(value) %>% sum()
# rh_sum <- coverage %>% filter(type == "RNA-seq" & treatment == "heat shock" & end == "full") %>% select(value) %>% sum()
#   
# coverage <- coverage %>% mutate(norm = 10^9 * value / sum(
#   
#   if (type == "PRO-seq" & treatment == "control") {
#     pc_sum
#   } else if (type == "RNA-seq" & treatment == "control") {
#     rc_sum
#   } else if (type == "PRO-seq" & treatment == "heat shock") {
#     ph_sum
#   } else if (type == "RNA-seq" & treatment == "heat shock") {
#     rh_sum
#   }
#   
#   ))

coverage <- coverage %>% group_by(type,end,treatment) %>%
  mutate(norm = 10^6 * value / sum(value)) %>% ungroup()

```

## get coverage at TSS and range around each promoter, old coverage file
```{r}
getcoverage <- function(x, coverage, range) {
  
  # lapply does not preserve colnames, so must use column indices
  
  # caveats -- eliminates cases where tss is positioned within range of genome end
  
  # x is a row from the promoters file
  # cov is the coverage file
  ## assumes coverage file is sorted by position (decreasing)
  # treatments is a vector of treatment names corresponding to columns in the coverage file
  # range is a vector c(x,y), where x is the upstream context and y is the downstream context
  
  edge <- as.numeric(dplyr::count(coverage))
  
  if (x[3] == "forward") {
    
    min <- as.numeric(x[4]) - range[1]
    max <- as.numeric(x[4]) + range[2]
    
    # do not compute coverage if range goes over edge of genome
    if (min < 1 || max < 1 || min > edge || max > edge ) {
      
      print(paste("Skipping ", x[2], ", range exceeds edge of genome", sep = ""))
      
    } else {
    
      # hard-coded column names
    
      ## same strand as promoter
      PRO_control_plus <- coverage[min:max,]$PCp_norm
      PRO_heat_plus    <- coverage[min:max,]$PHp_norm
      RNA_control_plus <- coverage[min:max,]$RCm_norm #flipped
      RNA_heat_plus    <- coverage[min:max,]$RHm_norm #flipped
      ## opposite strand of promoter
      PRO_control_minus <- -coverage[min:max,]$PCm_norm
      PRO_heat_minus    <- -coverage[min:max,]$PHm_norm
      RNA_control_minus <- -coverage[min:max,]$RCp_norm #flipped
      RNA_heat_minus    <- -coverage[min:max,]$RHp_norm #flipped
      
      # hard-coded treatments
      
      index        <- c(-range[1]:range[2])
      pos <- c(min:max)
      promoter     <- c(rep(x[2], length(index)))
      sigma_factor <- c(rep(x[5], length(index)))
      EC_id        <- c(rep(x[1], length(index)))
  
      tibble(EC_id, promoter, sigma_factor, index, pos,
                 PRO_control_plus, PRO_heat_plus, RNA_control_plus, RNA_heat_plus,
                 PRO_control_minus, PRO_heat_minus, RNA_control_minus, RNA_heat_minus)
    
    }
    
  } else if (x[3] == "reverse") {
    
    min <- as.numeric(x[4]) + range[1]
    max <- as.numeric(x[4]) - range[2]
    
    # do not compute coverage if range goes over edge of genome
    if (min < 1 || max < 1 || min > edge || max > edge ) {
      
      print(paste("Skipping ", x[2], ", range exceeds edge of genome", sep = ""))
      
    } else {
    
      # hard-coded column names
    
      ## same strand as promoter
      PRO_control_plus <- coverage[min:max,]$PCm_norm
      PRO_heat_plus    <- coverage[min:max,]$PHm_norm
      RNA_control_plus <- coverage[min:max,]$RCp_norm #flipped
      RNA_heat_plus    <- coverage[min:max,]$RHp_norm #flipped
      ## opposite strand of promoter
      PRO_control_minus <- -coverage[min:max,]$PCp_norm
      PRO_heat_minus    <- -coverage[min:max,]$PHp_norm
      RNA_control_minus <- -coverage[min:max,]$RCm_norm #flipped
      RNA_heat_minus    <- -coverage[min:max,]$RHm_norm #flipped
      
      # hard-coded treatments
      
      index        <- c(-range[1]:range[2])
      pos <- c(min:max)
      promoter     <- c(rep(x[2], length(index)))
      sigma_factor <- c(rep(x[5], length(index)))
      EC_id        <- c(rep(x[1], length(index)))
  
      # dplyr::data_frame() is deprecated, update to use dplyr::tibble()
      
      tibble(EC_id, promoter, sigma_factor, index, pos,
                 PRO_control_plus, PRO_heat_plus, RNA_control_plus, RNA_heat_plus,
                 PRO_control_minus, PRO_heat_minus, RNA_control_minus, RNA_heat_minus)
    
    }
      
  }
  
}
```

## get coverage at TSS and range around each promoter, new coverage file
```{r}
getcoverage <- function(x, cov, range) {
  
  # lapply does not preserve colnames, so must use column indices
  
  # caveats -- eliminates cases where tss is positioned within range of genome end
  
  # x is a row from the promoters file
  # cov is the coverage file
  ## assumes coverage file is sorted by position (decreasing)
  # treatments is a vector of treatment names corresponding to columns in the coverage file
  # range is a vector c(x,y), where x is the upstream context and y is the downstream context
  
  subcov <- function(cov_, type_, end_, treat_, strand_, min_, max_) {
        subout <- cov_ %>% filter(type == type_ & end == end_ & treatment == treat_ &
                         strand == strand_ & position >= min_ & position <= max_) %>%
          select(norm) %>% as_vector()
        }
  
  edge <- as.numeric(max(cov$position))
  
  if (x[3] == "forward") {
    
    min <- as.numeric(x[4]) - range[1]
    max <- as.numeric(x[4]) + range[2]
    
    # do not compute coverage if range goes over edge of genome
    if (min < 1 || max < 1 || min > edge || max > edge ) {
      
      print(paste("Skipping ", x[2], ", range exceeds edge of genome", sep = ""))
      
    } else {
    
      # hard-coded column names
      
      ## same strand as promoter
      PRO_control_plus <- subcov(cov, "PRO-seq", "3", "control", "plus", min, max)
      PRO_heat_plus    <- subcov(cov, "PRO-seq", "3", "heat shock", "plus", min, max)
      RNA_control_plus <- subcov(cov, "RNA-seq", "full", "control", "minus", min, max) #flipped
      RNA_heat_plus    <- subcov(cov, "RNA-seq", "full", "heat shock", "minus", min, max) #flipped
      ## opposite strand of promoter
      PRO_control_minus <- subcov(cov, "PRO-seq", "3", "control", "minus", min, max) * -1
      PRO_heat_minus    <- subcov(cov, "PRO-seq", "3", "heat shock", "minus", min, max) * -1
      RNA_control_minus <- subcov(cov, "RNA-seq", "full", "control", "plus", min, max) * -1 #flipped
      RNA_heat_minus    <- subcov(cov, "RNA-seq", "full", "heat shock", "plus", min, max) * -1 #flipped
      
      # hard-coded treatments
      
      index        <- c(-range[1]:range[2])
      pos <- c(min:max)
      promoter     <- c(rep(x[2], length(index)))
      sigma_factor <- c(rep(x[5], length(index)))
      EC_id        <- c(rep(x[1], length(index)))
      direction <- c(rep(x[3], length(index)))
  
      # dplyr::data_frame() is deprecated, update to use dplyr::tibble()
      
      tibble(EC_id, promoter, sigma_factor, index, pos, direction,
                 PRO_control_plus, PRO_heat_plus, RNA_control_plus, RNA_heat_plus,
                 PRO_control_minus, PRO_heat_minus, RNA_control_minus, RNA_heat_minus)
    
    }
    
  } else if (x[3] == "reverse") {
    
    min <- as.numeric(x[4]) - range[2]
    max <- as.numeric(x[4]) + range[1]
    
    # do not compute coverage if range goes over edge of genome
    if (min < 1 || max < 1 || min > edge || max > edge ) {
      
      print(paste("Skipping ", x[2], ", range exceeds edge of genome", sep = ""))
      
    } else {
    
      # hard-coded column names
    
      ## same strand as promoter
      PRO_control_plus <- subcov(cov, "PRO-seq", "3", "control", "minus", min, max)
      PRO_heat_plus    <- subcov(cov, "PRO-seq", "3", "heat shock", "minus", min, max)
      RNA_control_plus <- subcov(cov, "RNA-seq", "full", "control", "plus", min, max) #flipped
      RNA_heat_plus    <- subcov(cov, "RNA-seq", "full", "heat shock", "plus", min, max) #flipped
      ## opposite strand of promoter
      PRO_control_minus <- subcov(cov, "PRO-seq", "3", "control", "plus", min, max) * -1
      PRO_heat_minus    <- subcov(cov, "PRO-seq", "3", "heat shock", "plus", min, max) * -1
      RNA_control_minus <- subcov(cov, "RNA-seq", "full", "control", "minus", min, max) * -1  #flipped
      RNA_heat_minus    <- subcov(cov, "RNA-seq", "full", "heat shock", "minus", min, max) * -1 #flipped
      
      # hard-coded treatments
      
      index        <- c(range[2]:-range[1])
      pos <- c(min:max)
      promoter     <- c(rep(x[2], length(index)))
      sigma_factor <- c(rep(x[5], length(index)))
      EC_id        <- c(rep(x[1], length(index)))
      direction <- c(rep(x[3], length(index)))
  
      # dplyr::data_frame() is deprecated, update to use dplyr::tibble()
      
      tibble(EC_id, promoter, sigma_factor, index, pos, direction,
                 PRO_control_plus, PRO_heat_plus, RNA_control_plus, RNA_heat_plus,
                 PRO_control_minus, PRO_heat_minus, RNA_control_minus, RNA_heat_minus)
    
    }
      
  }
  
  message(paste0(x[7], " / 622"))
  
}
```

## apply function and bind results to single dataframe
```{r}
library(dplyr)
library(pbapply)
library(reshape2)
# make sure to unload other packages before running, or calls of count get masked and fail

covdat <- pbapply(X = promoters, MARGIN = 1,
                  FUN = getcoverage, cov = coverage, range = c(50,200))

# bind_rows returns error for dataframes from promoters that exceeded genome range, drop first

#covdat[3749] <- NULL
covdat <- bind_rows(covdat)

#write_csv(covdat, file = "/workdir/users/acv46/EC_PROSeq/figures/promoters/covdat_promoterproximal_singlesigma_20Dec2021.csv", col_names = T)
covdat <- read_csv(file = "/workdir/users/acv46/EC_PROSeq/figures/promoters/covdat_promoterproximal_singlesigma_20Dec2021_2.csv", col_names = T)

# subset dataframe to promoters with a single sigmafactor
# melt so that all libraries are in a single column
covdat_melt <- melt(data = covdat,
                    id.vars = c("EC_id", "promoter", "sigma_factor", "index", "pos", "direction"),
                    measure.vars = c("PRO_control_plus", "PRO_heat_plus", "RNA_control_plus", "RNA_heat_plus",
                                     "PRO_control_minus", "PRO_heat_minus", "RNA_control_minus", "RNA_heat_minus"))

covdat_melt <- covdat_melt %>% filter(sigma_factor %in% c("Sigma70","Sigma38","Sigma24","unknown","Sigma28","Sigma32","Sigma54")) 
```

## plot coverage centered at TSS - geom_smooth, RNA-seq and PRO-seq
```{r}
# facet by sigma factor

pal <- c("#2c7bb6", 
         "#d7191c",
         "#4daf4a",
         "#984ea3",
         "#2c7bb6", 
         "#d7191c",
         "#4daf4a",
         "#984ea3")

ggplot(data = covdat_melt) +
  geom_smooth(aes(x = index,
                  y = value,
                  color = variable,
                  fill = variable)) +
  scale_fill_manual(values = pal) +
  scale_color_manual(values = pal) +
  facet_wrap(~ sigma_factor) +
  theme_classic() +
  geom_hline(yintercept = 0, color = "black", size = 0.5) +
  geom_vline(xintercept = 0, color = "black", size = 0.5, linetype = "dotted") +
  ylab("Normalized read count") + 
  xlab("Position relative to promoter start")

```

## plot coverage centered at TSS - geom_smooth, PRO-seq only
```{r}
# facet by sigma factor

pal <- c("#2c7bb6", 
         "#d7191c",
         "#2c7bb6", 
         "#d7191c")

ggplot(data = covdat_melt[grep("^PRO", covdat_melt$variable), ]) +
  geom_smooth(aes(x = index,
                  y = value,
                  color = variable,
                  fill = variable)) +
  scale_fill_manual(values = pal) +
  scale_color_manual(values = pal) +
  facet_wrap(~ sigma_factor) +
  theme_classic() +
  geom_hline(yintercept = 0, color = "black", size = 0.5) +
  geom_vline(xintercept = 0, color = "black", size = 0.5, linetype = "dotted") +
  ylab("Normalized read count") + 
  xlab("Position relative to promoter start")

```

## plot coverage centered at TSS - geom_smooth, RNA-seq only
```{r}
# facet by sigma factor

pal <- c("#4daf4a",
         "#984ea3",
         "#4daf4a",
         "#984ea3")

ggplot(data = covdat_melt[grep("^RNA", covdat_melt$variable), ]) +
  geom_smooth(aes(x = index,
                  y = value,
                  color = variable,
                  fill = variable)) +
  scale_fill_manual(values = pal) +
  scale_color_manual(values = pal) +
  facet_wrap(~ sigma_factor) +
  theme_classic() +
  geom_hline(yintercept = 0, color = "black", size = 0.5) +
  geom_vline(xintercept = 0, color = "black", size = 0.5, linetype = "dotted") +
  ylab("Normalized read count") + 
  xlab("Position relative to promoter start")

```

## plot coverage centered at TSS - geom_smooth, RNA-seq and PRO-seq, sigma 70, 32, 24
```{r}
# facet by sigma factor

covdat_melt_sub <- covdat_melt[which(covdat_melt$sigma_factor == "Sigma70" 
                                     | covdat_melt$sigma_factor == "Sigma32" 
                                     | covdat_melt$sigma_factor == "Sigma24"),]

covdat_melt_sub$sigma_factor_ordered = factor(covdat_melt_sub$sigma_factor, levels=c("Sigma70","Sigma32","Sigma24"))

# y value for line labels
laby <- 2

# labels for legend
lableg <- c("PRO-seq control", "PRO-seq heat shock", "RNA-seq control", "RNA-seq heat shock")

facet.labs <- c(paste("\u03C3","70",", n = ", 
                      nrow(covdat_melt_sub[which(covdat_melt_sub$index == 0  
                                                 & covdat_melt_sub$variable == "PRO_control_plus" 
                                                 & covdat_melt_sub$sigma_factor_ordered == "Sigma70"),]),
                      sep = ""),
                paste("\u03C3","32",", n = ", 
                      nrow(covdat_melt_sub[which(covdat_melt_sub$index == 0  
                                                 & covdat_melt_sub$variable == "PRO_control_plus" 
                                                 & covdat_melt_sub$sigma_factor_ordered == "Sigma32"),]),
                      sep = ""),
                paste("\u03C3","24",", n = ", 
                      nrow(covdat_melt_sub[which(covdat_melt_sub$index == 0  
                                                 & covdat_melt_sub$variable == "PRO_control_plus" 
                                                 & covdat_melt_sub$sigma_factor_ordered == "Sigma24"),]),
                      sep = ""))
names(facet.labs) <- c("Sigma70","Sigma32","Sigma24")

pal <- c("#E69F00FF","#D55E00FF","#7acfff","#0072B2FF",
         "#E69F00FF","#D55E00FF","#7acfff","#0072B2FF")

# geom_point overextends y axis and makes differences hard to see

p <- ggplot(data = covdat_melt_sub) +
  # geom_jitter(mapping = aes(x = index,
  #                          y = value,
  #                          color = variable),
  #            alpha = 0.1, 
  #            shape = 16) +
  # geom_linerange(aes(x = index,
  #                   ymin = quart(value)[1],
  #                   ymax = quart(value)[2],
  #                   color = variable),
  #                size = 1) +
  #                   #outlier.shape = NA) +
  geom_smooth(aes(x = index,
                  y = value,
                  color = variable,
                  fill = variable),
              se = T,
              level = 0.95) +
  scale_fill_manual(values = pal,
                    labels = lableg) +
  scale_color_manual(values = pal,
                     labels = lableg) +
  facet_grid(rows = vars(sigma_factor_ordered),
             labeller = labeller(sigma_factor_ordered = facet.labs)) +
  #coord_cartesian(ylim = c(-0.5, 2.5)) + 
  theme_bw(base_family = "sans") +
  geom_hline(yintercept = 0, color = "black", size = 0.5) +
  geom_vline(xintercept = 0, color = "black", size = 0.5, linetype = "dotted") +
  annotate(geom = "label",
           x = 0,
           y = laby,
           color = "black",
           angle = 0,
           label = "+1",
           size = 3) +
  # geom_vline(xintercept = -10, color = "black", size = 0.5, linetype = "dotted") +
  # annotate(geom = "label",
  #          x = -10,
  #          y = laby,
  #          color = "black",
  #          angle = 0,
  #          label = "-10",
  #          size = 3) +
  geom_vline(xintercept = -35, color = "black", size = 0.5, linetype = "dotted") +
  annotate(geom = "label",
           x = -35,
           y = laby,
           color = "black",
           angle = 0,
           label = "-35",
           size = 3) +
  geom_vline(xintercept = 75, color = "black", size = 0.5, linetype = "dotted") +
  annotate(geom = "label",
           x = 74,
           y = laby,
           color = "black",
           angle = 0,
           label = "+75",
           size = 3) +
  geom_vline(xintercept = 150, color = "black", size = 0.5, linetype = "dotted") +
  annotate(geom = "label",
           x = 149,
           y = laby,
           color = "black",
           angle = 0,
           label = "+150",
           size = 3) +
  ylab("Normalized depth") + 
  theme_classic() +
  theme(axis.title.x = element_blank(),
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        legend.title = element_blank(),
        strip.text.y = element_text(size = 12),
        axis.text.y = element_text(size = 10))
  

p
```
### ggsave
```{r}
#library(svglite)
setwd("/workdir/users/acv46/EC_PROSeq/figures/promoters")
ggsave(filename = "sigma70_32_24.minus50plus200_fixed_regdb10.9_redo.pdf",
       plot = p,
       device = "pdf",
       dpi = 600,
       width = 8,
       height = 6,
       useDingbats = F)
ggsave(filename = "sigma70_32_24.minus50plus200_fixed_regdb10.9_redo.svg",
       plot = p,
       device = "svg",
       dpi = 600,
       width = 8,
       height = 6)
```
### Cairo -- broken
```{r}
#library(Cairo)
setwd("/workdir/users/acv46/EC_PROSeq/figures/promoters")

CairoSVG(file = "sigma70_32_24.minus50plus200_2.svg",
         #type = "svg",
         dpi = 600,
         width = 8,
         height = 6)
print(p)
dev.off()

CairoPDF(file = "sigma70_32_24.minus50plus200_2.pdf",
         #type = "pdf",
         dpi = 600,
         width = 8,
         height = 6)
print(p)
dev.off()
```


## plot coverage centered at TSS - geom_smooth, RNA-seq and PRO-seq, sigma 38, 28, 54, unknown
```{r}
# facet by sigma factor

covdat_melt_sub <- covdat_melt[which(covdat_melt$sigma_factor == "Sigma38" 
                                     | covdat_melt$sigma_factor == "Sigma28" 
                                     | covdat_melt$sigma_factor == "Sigma54"
                                     | covdat_melt$sigma_factor == "unknown"),]

covdat_melt_sub$sigma_factor_ordered = factor(covdat_melt_sub$sigma_factor,
                                              levels=c("Sigma38","Sigma28","Sigma54","unknown"))

# y value for line labels
laby <- 2

# labels for legend
lableg <- c("PRO-seq control", "PRO-seq heat shock", "RNA-seq control", "RNA-seq heat shock")

facet.labs <- c(paste("\u03C3","38",", n = ", 
                      nrow(covdat_melt_sub[which(covdat_melt_sub$index == 0  
                                                 & covdat_melt_sub$variable == "PRO_control_plus" 
                                                 & covdat_melt_sub$sigma_factor_ordered == "Sigma38"),]),
                      sep = ""),
                paste("\u03C3","28",", n = ", 
                      nrow(covdat_melt_sub[which(covdat_melt_sub$index == 0  
                                                 & covdat_melt_sub$variable == "PRO_control_plus" 
                                                 & covdat_melt_sub$sigma_factor_ordered == "Sigma28"),]),
                      sep = ""),
                paste("\u03C3","54",", n = ", 
                      nrow(covdat_melt_sub[which(covdat_melt_sub$index == 0  
                                                 & covdat_melt_sub$variable == "PRO_control_plus" 
                                                 & covdat_melt_sub$sigma_factor_ordered == "Sigma54"),]),
                      sep = ""),
                paste("unknown",", n = ", 
                      nrow(covdat_melt_sub[which(covdat_melt_sub$index == 0  
                                                 & covdat_melt_sub$variable == "PRO_control_plus" 
                                                 & covdat_melt_sub$sigma_factor_ordered == "unknown"),]),
                      sep = ""))
names(facet.labs) <- c("Sigma38","Sigma28","Sigma54","unknown")

pal <- c("#E69F00FF","#D55E00FF","#56B4E9FF","#0072B2FF",
         "#E69F00FF","#D55E00FF","#56B4E9FF","#0072B2FF")

# geom_point overextends y axis and makes differences hard to see

p <- ggplot(data = covdat_melt_sub) +
  # geom_jitter(mapping = aes(x = index,
  #                          y = value,
  #                          color = variable),
  #            alpha = 0.1, 
  #            shape = 16) +
  # geom_linerange(aes(x = index,
  #                   ymin = quart(value)[1],
  #                   ymax = quart(value)[2],
  #                   color = variable),
  #                size = 1) +
  #                   #outlier.shape = NA) +
  geom_smooth(aes(x = index,
                  y = value,
                  color = variable,
                  fill = variable),
              se = T,
              level = 0.95) +
  scale_fill_manual(values = pal,
                    labels = lableg) +
  scale_color_manual(values = pal,
                     labels = lableg) +
  facet_grid(rows = vars(sigma_factor_ordered),
             labeller = labeller(sigma_factor_ordered = facet.labs)) +
  coord_cartesian(ylim = c(-0.5, 2.5)) + 
  theme_bw(base_family = "sans") +
  geom_hline(yintercept = 0, color = "black", size = 0.5) +
  geom_vline(xintercept = 0, color = "black", size = 0.5, linetype = "dotted") +
  annotate(geom = "label",
           x = 0,
           y = laby,
           color = "black",
           angle = 0,
           label = "+1",
           size = 3) +
  # geom_vline(xintercept = -10, color = "black", size = 0.5, linetype = "dotted") +
  # annotate(geom = "label",
  #          x = -10,
  #          y = laby,
  #          color = "black",
  #          angle = 0,
  #          label = "-10",
  #          size = 3) +
  geom_vline(xintercept = -35, color = "black", size = 0.5, linetype = "dotted") +
  annotate(geom = "label",
           x = -35,
           y = laby,
           color = "black",
           angle = 0,
           label = "-35",
           size = 3) +
  geom_vline(xintercept = 75, color = "black", size = 0.5, linetype = "dotted") +
  annotate(geom = "label",
           x = 74,
           y = laby,
           color = "black",
           angle = 0,
           label = "+75",
           size = 3) +
  geom_vline(xintercept = 150, color = "black", size = 0.5, linetype = "dotted") +
  annotate(geom = "label",
           x = 149,
           y = laby,
           color = "black",
           angle = 0,
           label = "+150",
           size = 3) +
  ylab("Normalized depth") + 
  theme_classic() +
  theme(axis.title.x = element_blank(),
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        legend.title = element_blank(),
        strip.text.y = element_text(size = 12),
        axis.text.y = element_text(size = 10))
  

p
```
### ggsave
```{r}
#library(svglite)
setwd("/workdir/users/acv46/EC_PROSeq/figures/promoters")
ggsave(filename = "sigma70_32_24.minus50plus200_fixed_regdb10.9.png",
       plot = p,
       device = "png",
       dpi = 600,
       width = 8,
       height = 6)
ggsave(filename = "sigma70_32_24.minus50plus200_fixed_regdb10.9.svg",
       plot = p,
       device = "svg",
       dpi = 600,
       width = 8,
       height = 6)
ggsave(filename = "sigma70_32_24.minus50plus200_fixed_regdb10.9.pdf",
       plot = p,
       device = cairo_pdf,
       dpi = 600,
       width = 8,
       height = 6)
```
### Cairo -- broken
```{r}
#library(Cairo)
setwd("/workdir/users/acv46/EC_PROSeq/figures/promoters")

CairoSVG(file = "sigma70_32_24.minus50plus200_2.svg",
         #type = "svg",
         dpi = 600,
         width = 8,
         height = 6)
print(p)
dev.off()

CairoPDF(file = "sigma70_32_24.minus50plus200_2.pdf",
         #type = "pdf",
         dpi = 600,
         width = 8,
         height = 6)
print(p)
dev.off()
```


## plot coverage centered at TSS and start codons, single promoter + single sigma operon subset
```{r}
# tss_prox object made with /workdir/users/acv46/EC_PROSeq/figures/motifs/tss_pausing.R
# trans_prox object made with /workdir/users/acv46/EC_PROSeq/figures/motifs/trans_pausing.R
```

### subset operon object by promoters and output operon regulatory ranges
```{r}
e_coli_regulondb_10.9 <- regulondb(database_conn = connect_database(),
                              organism = "E.coli",
                              database_version = "10.9",
                              genome_version = "NC_000913.3")

# get vector of promoters
promset <- get_dataset(e_coli_regulondb_10.9, 
            dataset = "OPERON") %>% as_tibble() %>%
  filter(total_sigma == 1) %>%
  select(promoter_name) %>% as_vector()

promoters <- get_dataset(e_coli_regulondb_10.9, 
                         dataset = "PROMOTER",
                         attributes = c("id","name","strand","tss","sigma_factor","regulated_operon")) %>%
  as_tibble() %>% filter(name %in% promset) %>%
  na.omit() %>% mutate(count = c(1:n()))

ops <- get_dataset(e_coli_regulondb_10.9, 
            dataset = "OPERON") %>%
            #attributes = c("id","name","total_sigma","sigma_name")) %>%
  as_tibble()

# get object with tss and firstgeneposleft for all operons
tss2op <- promoters %>% separate(col = regulated_operon, into = c("op_id","op_name"), sep = "\t") %>%
  merge(., ops %>% select(id, firstgeneposleft, lastgeneposright, tf_name) %>% rename("op_id" = "id"),
        by = "op_id") %>% drop_na(-tf_name) %>% as_tibble()

# reduce tss2op object to single regulatory range encompassing all promoters
reg_ranges <-
rbind(
  tss2op %>% filter(strand == "forward") %>%
    group_by(op_id) %>% arrange(tss) %>%
    dplyr::slice(1) %>% select(-lastgeneposright) %>%
    rename("op_start" = "firstgeneposleft"),
  tss2op %>% filter(strand == "reverse") %>%
    group_by(op_id) %>% arrange(desc(tss)) %>%
    dplyr::slice(1) %>% select(-firstgeneposleft) %>%
    rename("op_start" = "lastgeneposright")
)

reg_ranges <- reg_ranges %>% mutate(op_start = as.numeric(op_start))
```

### generate coverage object, PRO-seq and RNAseq
```{r}
coverage <- read_csv("/workdir/users/acv46/EC_PROSeq/pileup/iter_correct/all_coverage_formatted.txt")
# flip orintation of plus and minus, just for fun
# 3' and 5' ends must also be flipped for correct orientation
# orientation and end flippinf supported by tRNA mapping
# get normalized values by grouping lib types
## normalize based on full coverage values
coverage <- coverage %>% mutate(strand1 = ifelse(strand == "plus", "minus", "plus")) %>%
  select(-strand) %>% dplyr::rename(strand = strand1) %>%
  mutate(end1 = ifelse(end == "3", "5", ifelse(end == "5", "3", "full"))) %>%
  select(-end) %>% dplyr::rename(end = end1)
  # group_by(type, treatment, end) %>%
  # mutate(norm = (value / sum(value)) * 10^6) %>%
  # ungroup()

cp_sum <- coverage %>% filter(end == "3" & treatment == "control" & type == "PRO-seq") %>% select(value) %>% sum()
hp_sum <- coverage %>% filter(end == "3" & treatment == "heat shock" & type == "PRO-seq") %>% select(value) %>% sum()
cr_sum <- coverage %>% filter(end == "full" & treatment == "control" & type == "RNA-seq") %>% select(value) %>% sum()
hr_sum <- coverage %>% filter(end == "full" & treatment == "heat shock" & type == "RNA-seq") %>% select(value) %>% sum()

coverage <- coverage %>% mutate(norm = ifelse(treatment == "control" & type == "PRO-seq", (value / cp_sum) * 10^6,
                                              ifelse(treatment == "heat shock" & type == "PRO-seq", (value / hp_sum) * 10^6,
                                                     ifelse(treatment == "control" & type == "RNA-seq", (value / cr_sum) * 10^6,
                                                            ifelse(treatment == "heat shock" & type == "RNA-seq", (value / hr_sum) * 10^6, NA)
                                                            )
                                                     )
                                              )
                                )

pro_covdat <- coverage %>% filter(type == "PRO-seq") %>% filter(end %in% c("3","5"))
```

### run tss_pausing.R and trans_pausing.R, then read in
```{r}

trans_prox <- read_csv(file = "/workdir/users/acv46/EC_PROSeq/figures/motifs/PRO-seq_pausing_500bp_centertrans_v2.csv",
                       col_names = T)
tss_prox <- read_csv(file = "/workdir/users/acv46/EC_PROSeq/figures/motifs/PRO-seq_pausing_500bp_centertss_v2.csv",
                     col_names = T)

```

### plot 
```{r}
require(tidyverse)
#tss_prox <- read_csv("/workdir/users/acv46/EC_PROSeq/figures/motifs/PRO-seq_pausing_500bp_centertss.csv", col_names = T)
#trans_prox <- read_csv("/workdir/users/acv46/EC_PROSeq/figures/motifs/PRO-seq_pausing_500bp_centertrans.csv", col_names = T)

plotsigma <- function(plotdat, title, ypos) {

  counts <- plotdat %>% filter(!grepl(",", sigma)) %>%
    filter(index == 0, type == "PRO-seq", treatment == "control",
           strand == "plus", end == "3") %>%
    select(sigma) %>% table %>% as_tibble() %>% rename("sigma" = ".")
  
  plotdat2 <- left_join(plotdat, counts, by = "sigma") %>% 
    mutate(combo = paste0(type," ",treatment)) %>% filter(end != "5")
  
  ggplot(data = plotdat2 %>%
           filter(!grepl(",", sigma)) %>%
           filter(index %in% c(-100:200)) %>%
           filter(strand == "plus")) + 
    geom_smooth(mapping = aes(x = index, y = norm, color = combo, fill = combo)) +
    geom_text(mapping = aes(label = paste0(sigma,"\n","n = ",n)),
              x = -100,
              y = ypos,
              hjust = 0,
              vjust = 1,
              check_overlap = T) + 
    scale_color_manual(values = c("blue", "red", "green", "purple")) + 
    scale_fill_manual(values = c("blue", "red", "green", "purple")) + 
    geom_hline(yintercept = 0, color = "black") +
    geom_vline(xintercept = 0, color = "black", linetype = "dotted") +
    xlab("position") +
    ylab("Per-base read depth") +
    facet_wrap(~ sigma, nrow = 2) + 
    #theme_classic() + 
    ggtitle(title) +
    theme(strip.background = element_blank(),
          strip.text = element_blank(),
          panel.spacing = unit(0.2, "lines"),
          panel.background = element_rect(fill = "white"),
          panel.border = element_rect(colour = "black", size = 1, fill = NA),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank())
  
}

p1 <- plotsigma(tss_prox, "PRO-seq operon coverage profiles centered at right-most transcription start site", 2.8)
p2 <- plotsigma(trans_prox, "PRO-seq operon coverage profiles centered at first start codon", 3.2)

p1
p2

# setwd("/workdir/users/acv46/EC_PROSeq/figures/promoters")
# ggsave(filename = "proseq_perOperon_bySigma_centerTSS_500_v4.pdf",
#        plot = p1, device = "pdf", width = 8, height = 6, units = "in",
#        useDingbats = FALSE)
# ggsave(filename = "proseq_perOperon_bySigma_centerStartCodon_500_v4.pdf",
#        plot = p2, device = "pdf", width = 8, height = 6, units = "in",
#        useDingbats = FALSE)

```

# Operon paradigms

## read in data 
```{r}
library(tidyverse)
setwd("/workdir/users/acv46/EC_PROSeq")

# PRO-seq and RNA-seq coverage data
# use interation 2, see readme in file directory
coverage <- read_delim(file = "pileup/iter2/all_coverage.txt",
                       delim = "\t")

## normalize to rpm and subset for manageability

coverage$PCm_norm <- coverage$PC_minus / sum(coverage$PC_minus + coverage$PC_plus) * 10^6
coverage$PCp_norm <- coverage$PC_plus / sum(coverage$PC_minus + coverage$PC_plus) * 10^6
coverage$PHm_norm <- coverage$PH_minus / sum(coverage$PH_minus + coverage$PH_plus) * 10^6
coverage$PHp_norm <- coverage$PH_plus / sum(coverage$PH_minus + coverage$PH_plus) * 10^6
coverage$RCm_norm <- coverage$RC_minus / sum(coverage$RC_minus + coverage$RC_plus) * 10^6
coverage$RCp_norm <- coverage$RC_plus / sum(coverage$RC_minus + coverage$RC_plus) * 10^6
coverage$RHm_norm <- coverage$RH_minus / sum(coverage$RH_minus + coverage$RH_plus) * 10^6
coverage$RHp_norm <- coverage$RH_plus / sum(coverage$RH_minus + coverage$RH_plus) * 10^6

cov_norm <- coverage[,-c(3:10)]
treatments <- colnames(cov_norm)[3:10]
rm(coverage)
```

## retrieve regulonDB and create GRanges objects
```{r}
library(regutools)
library(Biostrings)
## Build a regulondb object
## stores database at /home/acv46/.cache/AnnotationHub
e_coli_regulondb <- regulondb(database_conn = connect_database(),
                              organism = "E.coli",
                              database_version = "10.6",
                              genome_version = "NC_000913.3")

#list_datasets(e_coli_regulondb)
#list_attributes(e_coli_regulondb, dataset = "PROMOTER")

## gene dataset
promoters <- get_dataset(regulondb = e_coli_regulondb,
                     dataset = "PROMOTER")
operons <- get_dataset(regulondb = e_coli_regulondb,
                     dataset = "OPERON")
# subset only for operons that have at least one promoter
operons <- operons[which(operons$total_promoter >= 1),]
operons <- as_tibble(operons)


## convert to GRanges object and change sequence name to match bam files

#genes_ranges <- convert_to_granges(genes)
#genes_ranges <- renameSeqlevels(genes_ranges, "NC_000913.3")
#promoters_ranges <- convert_to_granges(promoters)
#promoters_ranges <- renameSeqlevels(promoters_ranges, "NC_000913.3")
#ops_ranges <- convert_to_granges(operons)
#ops_ranges <- renameSeqlevels(ops_ranges, "NC_000913.3")

#dnaK_range <- genes_ranges[which(genes_ranges$operon_name == "dnaK-tpke11-dnaJ")]



```

## get ratio function (equal width of bins)
```{r}
get_ratios <- function(x, coverage, binwidth, opmin, regmin) {
  
  if (!require(tidyverse)) install.packages('tidyverse')
  library(tidyverse)
  
  # lapply does not preserve colnames, so must use column indices
  
  # x is a row from the operons file
  # cov is the coverage file
  ## assumes coverage file is sorted by position (decreasing)
  # binwidth is the width of bins into which regions are split
  # opmin is the smallest operon length allowed
  # regmin is the smallest regulatory region length allowed
  
  # for a given vector of values
  ## cuts vector into number of equal-length bins
  ## returns sum of each bin
  ## gets median of bin sums
  
  ## code if width of bins is constant
  sum_bin_ratio <- function(vector){
    
    split(vector, cut(seq_along(vector), length(vector) / binwidth, labels = F)) %>% 
      lapply(., sum) %>% 
      unlist() %>% 
      median() #%>%
      #log2()
    
  }
  
  
  ## code if number of bins is constant
  # sum_bin_ratio <- function(vector){
  #   
  #   split(vector, cut(seq_along(vector), bins, labels = F)) %>% 
  #     lapply(., sum) %>% 
  #     unlist() %>% 
  #     median()
  #   
  # }
  
  if (is.na(x[7])) {
  
    print(paste("Skipping ", x[2], ", strand not given", sep = ""))
    
  } else if (x[7] == "forward") {
    
    # range of regulatory sequence
    ## beginning of reg seq to beginning of first gene
    regrange <- c(as.numeric(x[5]),
                  as.numeric(x[3])-1)
    regsize <- regrange[2] - regrange[1]
    regset <- c(regrange[1]:regrange[2])
    
    # range of non-regulatory operon
    ## first gene to last gene
    oprange <- c(as.numeric(x[3]),
                 as.numeric(x[4]))
    opsize <- oprange[2] - oprange[1]
    opset <- c(oprange[1]:oprange[2])
    
    # do not compute coverage if range goes over edge of genome
    if (opsize < opmin) {
      
      print(paste("Skipping ", x[2], ", operon size is smaller than set minimum", sep = ""))
      
    } else if (regsize < regmin) {
      
      print(paste("Skipping ", x[2], ", regulatory region is smaller than set minimum", sep = ""))
      
    } else {
    
      # hard-coded column names
    
      # OPERON
      
      ## same strand as promoter
      PCp_Op <- coverage[opset,]$PCp_norm
      PHp_Op <- coverage[opset,]$PHp_norm
      RCp_Op <- coverage[opset,]$RCm_norm #flipped
      RHp_Op <- coverage[opset,]$RHm_norm #flipped
      ## opposite strand of promoter
      PCm_Op <- -coverage[opset,]$PCm_norm
      PHm_Op <- -coverage[opset,]$PHm_norm
      RCm_Op <- -coverage[opset,]$RCp_norm #flipped
      RHm_Op <- -coverage[opset,]$RHp_norm #flipped
      
      # REGULATOR
      
      ## same strand as promoter
      PCp_Re <- coverage[regset,]$PCp_norm
      PHp_Re <- coverage[regset,]$PHp_norm
      RCp_Re <- coverage[regset,]$RCm_norm #flipped
      RHp_Re <- coverage[regset,]$RHm_norm #flipped
      ## Reposite strand of promoter
      PCm_Re <- -coverage[regset,]$PCm_norm
      PHm_Re <- -coverage[regset,]$PHm_norm
      RCm_Re <- -coverage[regset,]$RCp_norm #flipped
      RHm_Re <- -coverage[regset,]$RHp_norm #flipped
      
      index  <- x[1] 
      name   <- x[2]
      strand <- x[7]
  
      ## get ratio of promoter median to operon median for plus strand sets
      PCRe_PCOp_ratio <- sum_bin_ratio(PCp_Re) / sum_bin_ratio(PCp_Op)
      PHRe_PHOp_ratio <- sum_bin_ratio(PHp_Re) / sum_bin_ratio(PHp_Op)
      RCRe_RCOp_ratio <- sum_bin_ratio(RCp_Re) / sum_bin_ratio(RCp_Op)
      RHRe_RHOp_ratio <- sum_bin_ratio(RHp_Re) / sum_bin_ratio(RHp_Op)
      PCRe_RCOp_ratio <- sum_bin_ratio(PCp_Re) / sum_bin_ratio(RCp_Op)
      PHRe_RHOp_ratio <- sum_bin_ratio(PHp_Re) / sum_bin_ratio(RHp_Op)
      
      tibble(index, name, strand, opsize, regsize,
             PCRe_PCOp_ratio, PHRe_PHOp_ratio,
             RCRe_RCOp_ratio, RHRe_RHOp_ratio,
             PCRe_RCOp_ratio, PHRe_RHOp_ratio)
    
    }
    
  } else if (x[7] == "reverse") {
    
    # range of regulatory sequence
    ## beginning of reg seq to beginning of first gene
    regrange <- c(as.numeric(x[6]),
                  as.numeric(x[4])+1)
    regsize <- regrange[1] - regrange[2]
    regset <- c(regrange[1]:regrange[2])
    
    # range of non-regulatory operon
    ## first gene to last gene
    oprange <- c(as.numeric(x[4]),
                 as.numeric(x[3]))
    opsize <- oprange[1] - oprange[2]
    opset <- c(oprange[1]:oprange[2])
    
    # do not compute coverage if range goes over edge of genome
    if (opsize < opmin) {
      
      print(paste("Skipping ", x[2], ", operon size is smaller than set minimum", sep = ""))
      
    } else if (regsize < regmin) {
      
      print(paste("Skipping ", x[2], ", regulatory region is smaller than set minimum", sep = ""))
      
    } else {
    
      # hard-coded column names
    
      # OPERON
      
      ## same strand as promoter
      PCp_Op <- coverage[opset,]$PCm_norm
      PHp_Op <- coverage[opset,]$PHm_norm
      RCp_Op <- coverage[opset,]$RCp_norm #flipped
      RHp_Op <- coverage[opset,]$RHp_norm #flipped
      ## opposite strand of promoter
      PCm_Op <- -coverage[opset,]$PCp_norm
      PHm_Op <- -coverage[opset,]$PHp_norm
      RCm_Op <- -coverage[opset,]$RCm_norm #flipped
      RHm_Op <- -coverage[opset,]$RHm_norm #flipped
      
      # REGULATOR
      
      ## same strand as promoter
      PCp_Re <- coverage[regset,]$PCm_norm
      PHp_Re <- coverage[regset,]$PHm_norm
      RCp_Re <- coverage[regset,]$RCp_norm #flipped
      RHp_Re <- coverage[regset,]$RHp_norm #flipped
      ## Reposite strand of promoter
      PCm_Re <- -coverage[regset,]$PCp_norm
      PHm_Re <- -coverage[regset,]$PHp_norm
      RCm_Re <- -coverage[regset,]$RCm_norm #flipped
      RHm_Re <- -coverage[regset,]$RHm_norm #flipped
      
      index  <- x[1] 
      name   <- x[2]
      strand <- x[7]
  
      ## get ratio of promoter median to operon median for plus strand sets
      
      PCRe_PCOp_ratio <- sum_bin_ratio(PCp_Re) - sum_bin_ratio(PCp_Op)
      PHRe_PHOp_ratio <- sum_bin_ratio(PHp_Re) - sum_bin_ratio(PHp_Op)
      RCRe_RCOp_ratio <- sum_bin_ratio(RCp_Re) - sum_bin_ratio(RCp_Op)
      RHRe_RHOp_ratio <- sum_bin_ratio(RHp_Re) - sum_bin_ratio(RHp_Op)
      PCRe_RCOp_ratio <- sum_bin_ratio(PCp_Re) - sum_bin_ratio(RCp_Op)
      PHRe_RHOp_ratio <- sum_bin_ratio(PHp_Re) - sum_bin_ratio(RHp_Op)
      
      tibble(index, name, strand, opsize, regsize,
             PCRe_PCOp_ratio, PHRe_PHOp_ratio,
             RCRe_RCOp_ratio, RHRe_RHOp_ratio,
             PCRe_RCOp_ratio, PHRe_RHOp_ratio)
    
    }
      
  }
  
}
```

## get bins function (equal number of bins)
```{r}
get_bins <- function(x, coverage, binwidth, opmin, regmin) {
  
  if (!require(tidyverse)) install.packages('tidyverse')
  library(tidyverse)
  
  # lapply does not preserve colnames, so must use column indices
  
  # x is a row from the operons file
  # cov is the coverage file
  ## assumes coverage file is sorted by position (decreasing)
  # binwidth is the width of bins into which regions are split
  # opmin is the smallest operon length allowed
  # regmin is the smallest regulatory region length allowed
  
  # for a given vector of values
  ## cuts vector into number of equal-length bins
  ## returns sum of each bin
  ## gets median of bin sums
  
  # ## code if width of bins is constant
  # sum_bin_ratio <- function(vector){
  #   
  #   split(vector, cut(seq_along(vector), length(vector) / binwidth, labels = F)) %>% 
  #     lapply(., sum) %>% 
  #     unlist() %>% 
  #     median() %>%
  #     log2()
  #   
  # }
  
  
  ## code if number of bins is constant
  sum_bin_ratio <- function(vector){

    split(vector, cut(seq_along(vector), bins, labels = F)) %>%
      lapply(., sum) %>%
      unlist() %>%
      median()

  }
  
  if (is.na(x[7])) {
  
    print(paste("Skipping ", x[2], ", strand not given", sep = ""))
    
  } else if (x[7] == "forward") {
    
    # range of regulatory sequence
    ## beginning of reg seq to beginning of first gene
    regrange <- c(as.numeric(x[5]),
                  as.numeric(x[3])-1)
    regsize <- regrange[2] - regrange[1]
    regset <- c(regrange[1]:regrange[2])
    
    # range of non-regulatory operon
    ## first gene to last gene
    oprange <- c(as.numeric(x[3]),
                 as.numeric(x[4]))
    opsize <- oprange[2] - oprange[1]
    opset <- c(oprange[1]:oprange[2])
    
    # do not compute coverage if range goes over edge of genome
    if (opsize < opmin) {
      
      print(paste("Skipping ", x[2], ", operon size is smaller than set minimum", sep = ""))
      
    } else if (regsize < regmin) {
      
      print(paste("Skipping ", x[2], ", regulatory region is smaller than set minimum", sep = ""))
      
    } else {
    
      # hard-coded column names
    
      # OPERON
      
      ## same strand as promoter
      PCp_Op <- coverage[opset,]$PCp_norm
      PHp_Op <- coverage[opset,]$PHp_norm
      RCp_Op <- coverage[opset,]$RCm_norm #flipped
      RHp_Op <- coverage[opset,]$RHm_norm #flipped
      ## opposite strand of promoter
      PCm_Op <- -coverage[opset,]$PCm_norm
      PHm_Op <- -coverage[opset,]$PHm_norm
      RCm_Op <- -coverage[opset,]$RCp_norm #flipped
      RHm_Op <- -coverage[opset,]$RHp_norm #flipped
      
      # REGULATOR
      
      ## same strand as promoter
      PCp_Re <- coverage[regset,]$PCp_norm
      PHp_Re <- coverage[regset,]$PHp_norm
      RCp_Re <- coverage[regset,]$RCm_norm #flipped
      RHp_Re <- coverage[regset,]$RHm_norm #flipped
      ## Reposite strand of promoter
      PCm_Re <- -coverage[regset,]$PCm_norm
      PHm_Re <- -coverage[regset,]$PHm_norm
      RCm_Re <- -coverage[regset,]$RCp_norm #flipped
      RHm_Re <- -coverage[regset,]$RHp_norm #flipped
      
      index  <- x[1] 
      name   <- x[2]
      strand <- x[7]
  
      ## get ratio of promoter median to operon median for plus strand sets
      PCRe_PCOp_ratio <- sum_bin_ratio(PCp_Re) / sum_bin_ratio(PCp_Op)
      PHRe_PHOp_ratio <- sum_bin_ratio(PHp_Re) / sum_bin_ratio(PHp_Op)
      RCRe_RCOp_ratio <- sum_bin_ratio(RCp_Re) / sum_bin_ratio(RCp_Op)
      RHRe_RHOp_ratio <- sum_bin_ratio(RHp_Re) / sum_bin_ratio(RHp_Op)
      PCRe_RCOp_ratio <- sum_bin_ratio(PCp_Re) / sum_bin_ratio(RCp_Op)
      PHRe_RHOp_ratio <- sum_bin_ratio(PHp_Re) / sum_bin_ratio(RHp_Op)
      
      tibble(index, name, strand, opsize, regsize,
             PCRe_PCOp_ratio, PHRe_PHOp_ratio,
             RCRe_RCOp_ratio, RHRe_RHOp_ratio,
             PCRe_RCOp_ratio, PHRe_RHOp_ratio)
    
    }
    
  } else if (x[7] == "reverse") {
    
    # range of regulatory sequence
    ## beginning of reg seq to beginning of first gene
    regrange <- c(as.numeric(x[6]),
                  as.numeric(x[4])+1)
    regsize <- regrange[1] - regrange[2]
    regset <- c(regrange[1]:regrange[2])
    
    # range of non-regulatory operon
    ## first gene to last gene
    oprange <- c(as.numeric(x[4]),
                 as.numeric(x[3]))
    opsize <- oprange[1] - oprange[2]
    opset <- c(oprange[1]:oprange[2])
    
    # do not compute coverage if range goes over edge of genome
    if (opsize < opmin) {
      
      print(paste("Skipping ", x[2], ", operon size is smaller than set minimum", sep = ""))
      
    } else if (regsize < regmin) {
      
      print(paste("Skipping ", x[2], ", regulatory region is smaller than set minimum", sep = ""))
      
    } else {
    
      # hard-coded column names
    
      # OPERON
      
      ## same strand as promoter
      PCp_Op <- coverage[opset,]$PCm_norm
      PHp_Op <- coverage[opset,]$PHm_norm
      RCp_Op <- coverage[opset,]$RCp_norm #flipped
      RHp_Op <- coverage[opset,]$RHp_norm #flipped
      ## opposite strand of promoter
      PCm_Op <- -coverage[opset,]$PCp_norm
      PHm_Op <- -coverage[opset,]$PHp_norm
      RCm_Op <- -coverage[opset,]$RCm_norm #flipped
      RHm_Op <- -coverage[opset,]$RHm_norm #flipped
      
      # REGULATOR
      
      ## same strand as promoter
      PCp_Re <- coverage[regset,]$PCm_norm
      PHp_Re <- coverage[regset,]$PHm_norm
      RCp_Re <- coverage[regset,]$RCp_norm #flipped
      RHp_Re <- coverage[regset,]$RHp_norm #flipped
      ## Reposite strand of promoter
      PCm_Re <- -coverage[regset,]$PCp_norm
      PHm_Re <- -coverage[regset,]$PHp_norm
      RCm_Re <- -coverage[regset,]$RCm_norm #flipped
      RHm_Re <- -coverage[regset,]$RHm_norm #flipped
      
      index  <- x[1] 
      name   <- x[2]
      strand <- x[7]
  
      ## get ratio of promoter median to operon median for plus strand sets
      
      PCRe_PCOp_ratio <- sum_bin_ratio(PCp_Re) - sum_bin_ratio(PCp_Op)
      PHRe_PHOp_ratio <- sum_bin_ratio(PHp_Re) - sum_bin_ratio(PHp_Op)
      RCRe_RCOp_ratio <- sum_bin_ratio(RCp_Re) - sum_bin_ratio(RCp_Op)
      RHRe_RHOp_ratio <- sum_bin_ratio(RHp_Re) - sum_bin_ratio(RHp_Op)
      PCRe_RCOp_ratio <- sum_bin_ratio(PCp_Re) - sum_bin_ratio(RCp_Op)
      PHRe_RHOp_ratio <- sum_bin_ratio(PHp_Re) - sum_bin_ratio(RHp_Op)
      
      tibble(index, name, strand, opsize, regsize,
             PCRe_PCOp_ratio, PHRe_PHOp_ratio,
             RCRe_RCOp_ratio, RHRe_RHOp_ratio,
             PCRe_RCOp_ratio, PHRe_RHOp_ratio)
    
    }
      
  }
  
}
```

## apply function
```{r}
library(data.table)

bw10 <- apply(operons,
                1,
                FUN = get_ratios,
                coverage = cov_norm, binwidth = 10, opmin = 300, regmin = 50)
bw10 <- bind_rows(bw10[!grepl("Skipping", bw10)])

bw5 <- apply(operons,
                1,
                FUN = get_ratios,
                coverage = cov_norm, binwidth = 5, opmin = 300, regmin = 50)
bw5 <- bind_rows(bw5[!grepl("Skipping", bw5)])

```
### histogram of ratios
```{r}
custhist <- function(vector, title){

  breaks <- max(vector[!is.infinite(vector) & !is.nan(vector)])
  
  hist(vector, breaks, main = title)
  
}


custhist(bw10$PCRe_RCOp_ratio, "bw10 Control")
custhist(bw10$PHRe_RHOp_ratio, "bw10 Heat")
custhist(bw5$PCRe_RCOp_ratio, "bw5 Control")
custhist(bw5$PHRe_RHOp_ratio, "bw5 Heat")

```

### which operons change states
```{r}
bw10$change <- bw10$PCRe_RCOp_ratio - bw10$PHRe_RHOp_ratio
bw10_sub <- bw10[,c(2,10,11,12)]
bw10_sub <- bw10_sub[order(bw10_sub$change),]

bw5$change <- bw5$PCRe_RCOp_ratio - bw5$PHRe_RHOp_ratio
bw5_sub <- bw5[,c(2,10,11,12)]
bw5_sub <- bw5_sub[order(bw5_sub$change),]

```

## visualize select operons
```{r}


plotrange <- function (pos) {
promoter <- covdat_melt[which(covdat_melt$pos == pos & covdat_melt$variable == "PRO_control_plus"),]$promoter
message(promoter)


picked <- covdat_melt[which(covdat_melt$promoter == promoter),]

trace <- ggplot(data = picked) +
  geom_line(mapping = aes(x = pos,
                          y = value,
                          color = variable)) +
  theme_classic() +
  ggtitle(label = promoter)

trace
}

#Control

plotrange(2286282)
plotrange(3946225)
plotrange(3982802)
plotrange(4175824)

# HS

plotrange(696964)
plotrange(1031625)
plotrange(1911659)
plotrange(3708617)
plotrange(4606268)
```



## compare operons function
```{r}
getcoverage <- function(x, coverage, range) {
  
  # lapply does not preserve colnames, so must use column indices
  
  # caveats -- eliminates cases where tss is positioned within range of genome end
  
  # x is a row from the operons file
  # cov is the coverage file
  ## assumes coverage file is sorted by position (decreasing)
  # treatments is a vector of treatment names corresponding to columns in the coverage file
  # range is a vector c(x,y), where x is the upstream context and y is the downstream context
  
  edge <- as.numeric(count(coverage))
  
  if (x[4] == "forward") {
    
    min <- as.numeric(x[5]) - range[1]
    max <- as.numeric(x[6]) + range[2]
    
    # do not compute coverage if range goes over edge of genome
    if (min < 1 || max < 1 || min > edge || max > edge ) {
      
      print(paste("Skipping ", x[2], ", range exceeds edge of genome", sep = ""))
      
    } else {
    
      # hard-coded column names
    
      ## same strand as promoter
      PRO_control_plus <- coverage[min:max,]$PCp_norm
      PRO_heat_plus    <- coverage[min:max,]$PHp_norm
      RNA_control_plus <- coverage[min:max,]$RCm_norm #flipped
      RNA_heat_plus    <- coverage[min:max,]$RHm_norm #flipped
      ## opposite strand of promoter
      PRO_control_minus <- -coverage[min:max,]$PCm_norm
      PRO_heat_minus    <- -coverage[min:max,]$PHm_norm
      RNA_control_minus <- -coverage[min:max,]$RCp_norm #flipped
      RNA_heat_minus    <- -coverage[min:max,]$RHp_norm #flipped
      
      # hard-coded treatments
      
      index   <- c(min:max)
      name    <- c(rep(x[2], length(index)))
      strand  <- c(rep(x[4], length(index)))
      op_ID   <- c(rep(x[1], length(index)))
      length  <- c(rep(x[7], length(index)))
  
      tibble(op_ID, name, strand, length, index,
                 PRO_control_plus, PRO_heat_plus, RNA_control_plus, RNA_heat_plus,
                 PRO_control_minus, PRO_heat_minus, RNA_control_minus, RNA_heat_minus)
    
    }
    
  } else if (x[4] == "reverse") {
    
    min <- as.numeric(x[6]) + range[1]
    max <- as.numeric(x[5]) - range[2]
    
    # do not compute coverage if range goes over edge of genome
    if (min < 1 || max < 1 || min > edge || max > edge ) {
      
      
      print(paste("Skipping ", x[2], ", range exceeds edge of genome", sep = ""))
      
    } else {
    
      # hard-coded column names
    
      ## same strand as promoter
      PRO_control_plus <- coverage[min:max,]$PCm_norm
      PRO_heat_plus    <- coverage[min:max,]$PHm_norm
      RNA_control_plus <- coverage[min:max,]$RCp_norm #flipped
      RNA_heat_plus    <- coverage[min:max,]$RHp_norm #flipped
      ## opposite strand of promoter
      PRO_control_minus <- -coverage[min:max,]$PCp_norm
      PRO_heat_minus    <- -coverage[min:max,]$PHp_norm
      RNA_control_minus <- -coverage[min:max,]$RCm_norm #flipped
      RNA_heat_minus    <- -coverage[min:max,]$RHm_norm #flipped
      
      # hard-coded treatments
      
      index   <- c(min:max)
      name    <- c(rep(x[2], length(index)))
      strand  <- c(rep(x[4], length(index)))
      op_ID   <- c(rep(x[1], length(index)))
      length  <- c(rep(x[6], length(index)))
  
      tibble(op_ID, name, strand, length, index,
                 PRO_control_plus, PRO_heat_plus, RNA_control_plus, RNA_heat_plus,
                 PRO_control_minus, PRO_heat_minus, RNA_control_minus, RNA_heat_minus)
    
    }
      
  }
  
}
```
# Transcription factors
## read in data

```{r}
library(tidyverse)
setwd("/workdir/users/acv46/EC_PROSeq")

# see script at /workdir/users/acv46/EC_PROSeq/index/U00096.3/regulonDB/get_activators_repressors.sh
tfdat <- read_delim(file = "index/U00096.3/regulonDB/tf2promoters.txt",
                    delim = "\t",
                    col_names = T)

# PRO-seq and RNA-seq coverage data
# use interation 2, see readme in file directory
coverage <- read_delim(file = "pileup/iter2/all_coverage.txt",
                       delim = "\t")

## normalize to rpm and subset for manageability

coverage$PCm_norm <- coverage$PC_minus / sum(coverage$PC_minus + coverage$PC_plus) * 10^6
coverage$PCp_norm <- coverage$PC_plus / sum(coverage$PC_minus + coverage$PC_plus) * 10^6
coverage$PHm_norm <- coverage$PH_minus / sum(coverage$PH_minus + coverage$PH_plus) * 10^6
coverage$PHp_norm <- coverage$PH_plus / sum(coverage$PH_minus + coverage$PH_plus) * 10^6
coverage$RCm_norm <- coverage$RC_minus / sum(coverage$RC_minus + coverage$RC_plus) * 10^6
coverage$RCp_norm <- coverage$RC_plus / sum(coverage$RC_minus + coverage$RC_plus) * 10^6
coverage$RHm_norm <- coverage$RH_minus / sum(coverage$RH_minus + coverage$RH_plus) * 10^6
coverage$RHp_norm <- coverage$RH_plus / sum(coverage$RH_minus + coverage$RH_plus) * 10^6

cov_norm <- coverage[,-c(3:10)]
treatments <- colnames(cov_norm)[3:10]
rm(coverage)

```


# Pause sites (defunct)
## read in data
```{r}
library(tidyverse)
setwd("/workdir/users/acv46/EC_PROSeq")

# PRO-seq and RNA-seq coverage data (as read in above)
# use interation 2, see readme in file directory
coverage <- read_delim(file = "pileup/iter2/all_coverage.txt",
                       delim = "\t")

## normalize to rpm and subset for manageability

coverage$PCm_norm <- coverage$PC_minus / sum(coverage$PC_minus + coverage$PC_plus) * 10^6
coverage$PCp_norm <- coverage$PC_plus / sum(coverage$PC_minus + coverage$PC_plus) * 10^6
coverage$PHm_norm <- coverage$PH_minus / sum(coverage$PH_minus + coverage$PH_plus) * 10^6
coverage$PHp_norm <- coverage$PH_plus / sum(coverage$PH_minus + coverage$PH_plus) * 10^6
coverage$RCm_norm <- coverage$RC_minus / sum(coverage$RC_minus + coverage$RC_plus) * 10^6
coverage$RCp_norm <- coverage$RC_plus / sum(coverage$RC_minus + coverage$RC_plus) * 10^6
coverage$RHm_norm <- coverage$RH_minus / sum(coverage$RH_minus + coverage$RH_plus) * 10^6
coverage$RHp_norm <- coverage$RH_plus / sum(coverage$RH_minus + coverage$RH_plus) * 10^6

cov_norm <- coverage[,-c(3:10)]
treatments <- colnames(cov_norm)[3:10]
```

## implement pause scoring from Sun 2021, median, point inclusive
```{r}
# "ends of all uniquely mapped RNA reads (bottom lane) were determined and the read count for each 3′ end position was calculated and plotted (top lane). The genomic positions where 3’ end/3’ end median (51-bp window) read counts ratio (pause score) was ≥ 20 and read counts/10^6 reads was ≥ 10 satisfied our stringent definition for a pause site."

# pseudocode for 1-based circular genome 

## (((position - 1) +/- range) modulo genome_length) + 1 

get_pause_score1 <- function(vector, range){
  
  pause_score1 <- function(i, vector, genome_length, range){
  
    # i is the index of a value in the vector
    # vector is an ordered numeric vector representing depth / read counts across a the genome
    # genome_length is the length of the circular genome
    # range is the context around a position to calculate median depth, as an integer
  
    ## generate vector of positions at (position +/- range)
    
    fullrange <- sort(c(
      c(((i - 1) - c(1:range)) %% genome_length + 1),
      i,
      c(((i - 1) + c(1:range)) %% genome_length + 1)
      ))
    
    # pause score is normalized depth at position divided by median across range
    
    vector[i] / median(vector[fullrange])

  }  
      
  unlist(lapply(X = seq_along(vector),
                FUN = pause_score1,
                vector = vector,
                genome_length = length(vector),
                range = range))
  
}

```
## implement pause scoring, mean, point excluded
```{r}
# "ends of all uniquely mapped RNA reads (bottom lane) were determined and the read count for each 3′ end position was calculated and plotted (top lane). The genomic positions where 3’ end/3’ end median (51-bp window) read counts ratio (pause score) was ≥ 20 and read counts/10^6 reads was ≥ 10 satisfied our stringent definition for a pause site."

# pseudocode for 1-based circular genome 

## (((position - 1) +/- range) modulo genome_length) + 1 

get_pause_score2 <- function(vector, range){
  
  pause_score2 <- function(i, vector, genome_length, range){
  
    # i is the index of a value in the vector
    # vector is an ordered numeric vector representing depth / read counts across a the genome
    # genome_length is the length of the circular genome
    # range is the context around a position to calculate median depth, as an integer
  
    ## generate vector of positions at (position +/- range)
    
    fullrange <- sort(c(
      c(((i - 1) - c(1:range)) %% genome_length + 1),
      #i,
      c(((i - 1) + c(1:range)) %% genome_length + 1)
      ))
    
    # pause score is normalized depth at position divided by median across range
    
    vector[i] / mean(vector[fullrange])

  }  
      
  unlist(lapply(X = seq_along(vector),
                FUN = pause_score2,
                vector = vector,
                genome_length = length(vector),
                range = range))
  
}

```
## calculate pause score on normalized data
```{r}
# reset cov_norm first if trying new range
range <- 15

cov_norm$PCm_pause <- get_pause_score1(cov_norm$PCm_norm, range)
cov_norm$PCp_pause <- get_pause_score1(cov_norm$PCp_norm, range)
cov_norm$PHm_pause <- get_pause_score1(cov_norm$PHm_norm, range)
cov_norm$PHp_pause <- get_pause_score1(cov_norm$PHp_norm, range)

cov_norm[sapply(cov_norm, is.nan)] <- NA

# write out to avoid running long code again
setwd("/workdir/users/acv46/EC_PROSeq/pileup")
write.table(x = cov_norm,
            file = paste("coverage_normalized_pausescores2_range", range, ".txt", sep = ""),
            quote = F,
            col.names = T,
            row.names = F,
            sep = "\t")

```

## histogram of pause scores
```{r}
setwd("/workdir/users/acv46/EC_PROSeq/pileup")
cov_inftransform <- read_delim(file = "coverage_normalized_pausescores2_range25.txt",
                     delim = "\t",
                     col_names = T)
```
```{r}
# transform 
cov_inftransform[sapply(cov_inftransform, is.infinite)] <- 100
cov_inftransform <- cov_inftransform[,-c(1,c(3:10))]
cov_inftransform <- data.table::melt(data = cov_inftransform,
                    id.vars = c("position"),
                    measure.vars = c("PCm_pause","PCp_pause","PHm_pause","PHp_pause"))

p <- ggplot(data = cov_inftransform) +
  geom_histogram(mapping = aes(x = value),
                 binwidth=0.1, position="dodge") +
  scale_y_log10()

p
```

## histogram of normalized depth
```{r}

cov_inftransform <- cov_norm

# transform 
cov_inftransform[sapply(cov_inftransform, is.infinite)] <- 100
cov_inftransform <- cov_inftransform[,c(2:6/)]
cov_inftransform <- data.table::melt(data = cov_inftransform,
                    id.vars = c("position"),
                    measure.vars = c("PCm_norm","PCp_norm","PHm_norm","PHp_norm"))

p <- ggplot(data = cov_inftransform) +
  geom_histogram(mapping = aes(x = value),
                 binwidth=1, position="dodge") +
  scale_y_log10()

p
```

## pause sites counting function
```{r}
# count pause sites with different parameters

pause_count <- function(data, min_depth, min_pause){
  
  # data is a subset of cov_norm where [,1] is position, [,2] is norm depth, [,3] is pause score
  # min_pause is minimum pause score (>=)
  # min_pause is minimum norm depth (>=)
  
  nrow(data[which(data[,2] >= min_depth & data[,3] >= min_pause),])
  
}

pause_site <- function(data, min_depth, min_pause){
  
  # data is a subset of cov_norm where [,1] is position, [,2] is norm depth, [,3] is pause score
  # min_pause is minimum pause score (>=)
  # min_pause is minimum norm depth (>=)
  
  data[which(data[,2] >= min_depth & data[,3] >= min_pause),]
  
}
```

### count pause sites with range = 25
```{r}
setwd("/workdir/users/acv46/EC_PROSeq/pileup")
data25 <- read_delim(file = "coverage_normalized_pausescores2_range25.txt",
                     delim = "\t",
                     col_names = T)
```
```{r}
min_d <- 10
min_p <- 2

# PCm
pause_count(data = data25[,c(2,3,11)], min_depth = min_d, min_pause = min_p)
# PCp
pause_count(data = data25[,c(2,4,12)], min_depth = min_d, min_pause = min_p)
# PHm
pause_count(data = data25[,c(2,5,13)], min_depth = min_d, min_pause = min_p)
#PHp
pause_count(data = data25[,c(2,6,14)], min_depth = min_d, min_pause = min_p)
```


### count pause sites with range = 15
```{r}
setwd("/workdir/users/acv46/EC_PROSeq/pileup")
data15 <- read_delim(file = "coverage_normalized_pausescores2_range15.txt",
                     delim = "\t",
                     col_names = T)
```
```{r}
min_d <- 10
min_p <- 2

# PCm
pause_count(data = data15[,c(2,3,11)], min_depth = min_d, min_pause = min_p)
# PCp
pause_count(data = data15[,c(2,4,12)], min_depth = min_d, min_pause = min_p)
# PHm
pause_count(data = data15[,c(2,5,13)], min_depth = min_d, min_pause = min_p)
#PHp
pause_count(data = data15[,c(2,6,14)], min_depth = min_d, min_pause = min_p)
```

### get pause positions with range = 25, depth >= 5, pause score >= 3
```{r}
setwd("/workdir/users/acv46/EC_PROSeq/pileup")
data25 <- read_delim(file = "coverage_normalized_pausescores_range25.txt",
                     delim = "\t",
                     col_names = T)
```
```{r}
min_d = 10
min_p = 2

# PCm
PCm_psites <- pause_site(data = data25[,c(2,3,11)], min_depth = min_d, min_pause = min_p)
# PCp
PCp_psites <- pause_site(data = data25[,c(2,4,12)], min_depth = min_d, min_pause = min_p)
# PHm
PHm_psites <- pause_site(data = data25[,c(2,5,13)], min_depth = min_d, min_pause = min_p)
#PHp
PHp_psites <- pause_site(data = data25[,c(2,6,14)], min_depth = min_d, min_pause = min_p)

sitelist <- list(PCm_psites$position, PCp_psites$position, PHm_psites$position, PHm_psites$position)

```
```{r}
ranges <- lapply(sitelist, function(x) {
  diffs <- c(1, diff(x))
  start_indexes <- c(1, which(diffs > 1))
  end_indexes <- c(start_indexes - 1, length(x))
  coloned <- paste(x[start_indexes], x[end_indexes], sep=":")
  paste0(coloned, collapse=", ")
})
```
### plot
```{r}
# need covdat_melt data from promoter section

plotrange <- function (pos) {
name <- cov_norm[which(covdat_melt$index == pos & cov_norm$variable == "PRO_control_plus"),]$name
message(name)


picked <- covdat_melt[which(covdat_melt$name == name),]

trace <- ggplot(data = picked) +
  geom_line(mapping = aes(x = index,
                          y = value,
                          color = variable)) +
  theme_classic()

trace
}

```
```{r}
plotrange(1992041)

```



# metagene plots
## load libraries
```{r}
#if (!requireNamespace("BiocManager", quietly = TRUE))
#    install.packages("BiocManager")

#BiocManager::install("metagene2")
#BiocManager::install("regutools")

library(metagene2)
library(regutools)
library(Biostrings)
```

## metagene2 test
```{r}
demo_ranges <- get_demo_rna_regions()
demo_bams <- get_demo_rna_bam_files()
demo_mg <- metagene2$new(regions = demo_ranges, 
                   bam_files = demo_bams, 
                   assay = 'rnaseq',
                   padding = 50)

demo_mg$produce_metagene(title = "Demo metagene plot")
```

## create bam list, all bams
```{r}
# bam files resorted and indexed following 
# create named vector of bam files
setwd("/workdir/users/acv46/EC_PROSeq/proseq2.0/out3/bams/sort")

bams <- c("PC1_dedup_QC_end.sort.bam",
          "PC2_dedup_QC_end.sort.bam",
          "PC3_dedup_QC_end.sort.bam",
          "PH1_dedup_QC_end.sort.bam",
          "PH2_dedup_QC_end.sort.bam",
          "PH3_dedup_QC_end.sort.bam",
          "RCD1_QC_end.sort.bam",
          "RCD2_QC_end.sort.bam",
          "RHD1_QC_end.sort.bam",
          "RHD2_QC_end.sort.bam")
names(bams) <- c("PC1",
          "PC2",
          "PC3",
          "PH1",
          "PH2",
          "PH3",
          "RCD1",
          "RCD2",
          "RHD1",
          "RHD2")

```

## create bam list, just RNA-seq
```{r}
# bam files resorted and indexed following 
# create named vector of bam files
setwd("/workdir/users/acv46/EC_PROSeq/proseq2.0/out3/bams/sort")

bams_r <- c(
          "RCD1_QC_end.sort.bam",
          "RCD2_QC_end.sort.bam",
          "RHD1_QC_end.sort.bam",
          "RHD2_QC_end.sort.bam")
names(bams_r) <- c(
          "RCD1",
          "RCD2",
          "RHD1",
          "RHD2")
  
```

## create bam list, just PRO-seq
```{r}
# bam files resorted and indexed following 
# create named vector of bam files
setwd("/workdir/users/acv46/EC_PROSeq/proseq2.0/out3/bams/sort")

bams_p <- c("PC1_dedup_QC_end.sort.bam",
          "PC2_dedup_QC_end.sort.bam",
          "PC3_dedup_QC_end.sort.bam",
          "PH1_dedup_QC_end.sort.bam",
          "PH2_dedup_QC_end.sort.bam",
          "PH3_dedup_QC_end.sort.bam")
names(bams_p) <- c("PC1",
          "PC2",
          "PC3",
          "PH1",
          "PH2",
          "PH3")
```

## retrieve regulonDB and create GRanges objects
```{r}
## Build a regulondb object
## stores database at /home/acv46/.cache/AnnotationHub
e_coli_regulondb <- regulondb(database_conn = connect_database(),
                              organism = "E.coli",
                              database_version = "10.6",
                              genome_version = "NC_000913.3")

#list_datasets(e_coli_regulondb)
#list_attributes(e_coli_regulondb, dataset = "PROMOTER")

## gene dataset
genes <- get_dataset(regulondb = e_coli_regulondb,
                     dataset = "GENE",
                     attributes = c("posleft", "posright", "strand", "name", "sigma_factor", "operon_name"))
promoters <- get_dataset(regulondb = e_coli_regulondb,
                     dataset = "PROMOTER",
                     attributes = c("tss", "name", "strand", "sigma_factor", "regulated_tu", "regulated_operon"))
operons <- get_dataset(regulondb = e_coli_regulondb,
                     dataset = "OPERON",
                     attributes = c("name","strand", "firstgeneposleft", "lastgeneposright","regulationposleft", "regulationposright",  "sigma_name", "promoter_name", "tf_name"))

## convert to GRanges object and change sequence name to match bam files

genes_ranges <- convert_to_granges(genes)
genes_ranges <- renameSeqlevels(genes_ranges, "NC_000913.3")
#promoters_ranges <- convert_to_granges(promoters)
#promoters_ranges <- renameSeqlevels(promoters_ranges, "NC_000913.3")
ops_ranges <- convert_to_granges(operons)
ops_ranges <- renameSeqlevels(ops_ranges, "NC_000913.3")

dnaK_range <- genes_ranges[which(genes_ranges$operon_name == "dnaK-tpke11-dnaJ")]

ops_sig70_range <- ops_ranges[which(ops_ranges$sigma_name == "Sigma70")]
ops_sig32_range <- ops_ranges[which(ops_ranges$sigma_name == "Sigma32")]

```

## generate metadata table
```{r}

ops_ranges_list <- GRangesList(ops_ranges[which(ops_ranges$sigma_name == "Sigma70")],
            ops_ranges[which(ops_ranges$sigma_name == "Sigma32")],
            ops_ranges[which(ops_ranges$sigma_name == "Sigma54")],
            ops_ranges[which(ops_ranges$sigma_name == "Sigma28")],
            ops_ranges[which(ops_ranges$sigma_name == "Sigma24")])

names(ops_ranges_list) <- c("Sigma70","Sigma32", "Sigma54", "Sigma28", "Sigma24")

ops_meta = data.frame(BedName=names(ops_ranges_list),
                           EvenStart=ifelse((start(ops_ranges_list) %% 2) == 0, "Even", "Odd"),
                           Strand=strand(regions_gr))
head(demo_metadata)
```

## generate metagene object
```{r}
setwd("/workdir/users/acv46/EC_PROSeq/proseq2.0/out3/bams/sort")

get_mgobj <- function(regions, bam_files){
  
  metagene2$new(regions = regions,
                    bam_files = bam_files,
                    padding_size = 0,
                    verbose = T,
                    force_seqlevels = F,
                    paired_end = T,
                    assay = "rnaseq",
                    strand_specific = T,
                    paired_end_strand_mode = 2,
                    region_mode = "separate",
                    region_metadata = NULL,
                    extend_reads = 0,
                    invert_strand = T)

}

#mg <- get_mgobj(genes_ranges, bams, NULL)

mg_r <- get_mgobj(ops_sig32_range, bams_r)
mg_p <- get_mgobj(ops_sig32_range, bams_p)

```

## experiment design
```{r}
design <- data.frame(Samples = bams,
                     align1 = c(1,1,1,0,0,0,0,0,0,0),
                     align2 = c(0,0,0,1,1,1,0,0,0,0),
                     align3 = c(0,0,0,0,0,0,1,1,0,0),
                     align4 = c(0,0,0,0,0,0,0,0,1,1))

design_r <- data.frame(Samples = bams_r,
                     control = c(1,1,0,0),
                     heat_shock = c(0,0,1,1))

design_p <- data.frame(Samples = bams_p,
                     control = c(1,1,1,0,0,0),
                     heat_shock = c(0,0,0,1,1,1))

design_r_meta <- data.frame(design = mg_r$get_design_group_names(),
                       Align=c("Control", "Control", "Heat Shock", "Heat Shock"),
                         Rep=c(1, 2, 1, 2))

design_p_meta <- data.frame(design = mg_p$get_design_group_names(),
                       Align=c("Control", "Control", "Control", "Heat Shock", "Heat Shock", "Heat Shock"),
                         Rep=c(1, 2, 3, 1, 2, 3))
```

## metagene plot, RNA-seq
```{r}
setwd("/workdir/users/acv46/EC_PROSeq/proseq2.0/out3/bams/sort")
p1 <- mg_r$produce_metagene(design = design_r,
                      #design_metadata = design_r_meta,
                      bin_count = 100,
                      normalization = "RPM")

p2 <- mg_p$produce_metagene(design = design_p,
                      #design_metadata = design_p_meta,
                      bin_count = 100,
                      normalization = "RPM")

p1
p2
```

## metagene plot, single regions
```{r}
setwd("/workdir/users/acv46/EC_PROSeq/proseq2.0/out3/bams/sort")

region <- 4
#region <- genes_ranges[which(genes_ranges$name == "dnaK")]
mg_r$plot_single_region(region = region)
```
# Differential expression volcano plots, OPERONS, highlight sigma factors

## BiocManager Installations
```{r}
# Bioconductor installation only works with R 4.0

#if (!requireNamespace("BiocManager", quietly = TRUE))
#    install.packages("BiocManager")
#BiocManager::install(version = "3.11")

#if (!requireNamespace("BiocManager", quietly = TRUE))
#    install.packages("BiocManager")

#BiocManager::install("Rsubread")
#BiocManager::install("BRGenomics")
#BiocManager::install("rtracklayer")
library(Rsubread)
library(rtracklayer)
library(BRGenomics)
#devtools::install_github('kevinblighe/EnhancedVolcano')
library(EnhancedVolcano)
library(regutools)
library(DESeq2)
library(ashr)
```

## create bam list, all bams
```{r}
# bam files resorted and indexed following 
# create named vector of bam files

files <- c("PC1_dedup_QC_end.sort.bam",
          "PC2_dedup_QC_end.sort.bam",
          "PC3_dedup_QC_end.sort.bam",
          "PH1_dedup_QC_end.sort.bam",
          "PH2_dedup_QC_end.sort.bam",
          "PH3_dedup_QC_end.sort.bam",
          "RCD1_QC_end.sort.bam",
          "RCD2_QC_end.sort.bam",
          "RHD1_QC_end.sort.bam",
          "RHD2_QC_end.sort.bam")
filenames <- c("PC1",
          "PC2",
          "PC3",
          "PH1",
          "PH2",
          "PH3",
          "RCD1",
          "RCD2",
          "RHD1",
          "RHD2")
bam_list <- tibble(files, filenames)

```

## retrieve regulonDB and create GRanges objects
```{r}
## Build a regulondb object
## stores database at /home/acv46/.cache/AnnotationHub
e_coli_regulondb_10.9 <- regulondb(database_conn = connect_database(),
                              organism = "E.coli",
                              database_version = "10.9",
                              genome_version = "NC_000913.3")

#list_datasets(e_coli_regulondb)
#list_attributes(e_coli_regulondb, dataset = "PROMOTER")

## datasets
genes <- get_dataset(regulondb = e_coli_regulondb_10.9,
                     dataset = "GENE",
                     attributes = c("posleft", "posright", "strand", "name", "sigma_factor", "operon_name"))
promoters <- get_dataset(regulondb = e_coli_regulondb_10.9,
                     dataset = "PROMOTER",
                     attributes = c("tss", "name", "strand", "sigma_factor", "regulated_tu", "regulated_operon"))
operons <- get_dataset(regulondb = e_coli_regulondb_10.9,
                     dataset = "OPERON",
                     attributes = c("name","strand", "firstgeneposleft", "lastgeneposright","regulationposleft", "regulationposright",  "sigma_name", "promoter_name", "tf_name"))

dna_objects <- get_dataset(e_coli_regulondb_10.9, dataset = "DNA_OBJECTS")
dna_objects <- convert_to_granges(dna_objects)

## convert to GRanges object and change sequence name to match bam files

genes_ranges <- convert_to_granges(genes)
genes_ranges <- renameSeqlevels(genes_ranges, "NC_000913.3")
#promoters_ranges <- convert_to_granges(promoters)
#promoters_ranges <- renameSeqlevels(promoters_ranges, "NC_000913.3")
ops_ranges <- convert_to_granges(operons)
ops_ranges <- renameSeqlevels(ops_ranges, "NC_000913.3")

dnaK_range <- genes_ranges[which(genes_ranges$operon_name == "dnaK-tpke11-dnaJ")]

ops_sig70_range <- ops_ranges[which(ops_ranges$sigma_name == "Sigma70")]
ops_sig32_range <- ops_ranges[which(ops_ranges$sigma_name == "Sigma32")]


```

## export granges objects as gtf
```{r}
setwd("/workdir/users/acv46/EC_PROSeq/proseq2.0/out3/bams/sort")

export(ops_ranges, "operons.gtf")
export(dna_objects, "dna_objects.gtf")
```

## readcounts function using Rsubread::featureCounts
```{r}
readcounts <- function(bam, gtf) {
  
  prof <- featureCounts(files = bam[1], 
                         isPairedEnd = T, 
                         annot.ext = gtf, 
                         isGTFAnnotationFile = T, 
                         GTF.attrType = "name", 
                         requireBothEndsMapped = T, 
                         GTF.featureType = c("sequence_feature")) #c("CDS","exon","gene") 

  counts <- as.data.frame(prof[["counts"]])
  counts <- cbind(rownames(counts), data.frame(counts, row.names = NULL))
  colnames(counts) <- c("operon", bam[2])

  counts[order(counts$operon),]

}

#https://support.bioconductor.org/p/110807/
```

## apply readcounts function (creates list of dataframes as counts results)
```{r}

setwd("/workdir/users/acv46/EC_PROSeq/proseq2.0/out3/bams/sort")

counts <- apply(X = bam_list, MARGIN = 1, readcounts, gtf = "operons.gtf")
names(counts) <- bam_list$filenames

```

## merge and subset data, and load coldata
```{r}

allCounts <- counts %>% purrr::reduce(left_join, by = "operon") %>% na.omit()

# get the subset of operons that contain a Sigma32 recognition site in their regulatory region
HSall <- operons[grepl("Sigma32", operons$sigma_name),]
HSall.labs <- HSall$name

# get the subset of operons that are only under control of Sigma32
HSonly <- operons[which(operons$sigma_name == "Sigma32"),]
HSonly.labs <- HSonly$name

coldata <- read.table(file = "/local/workdir/users/acv46/EC_PROSeq/proseq2.0/out3/coldata_noU",
                      header = T,
                      sep = "\t")

#order of rownames must match order of countData columns
rownames(coldata) <- c(bam_list$filenames)

# create matrix for DESEQ2
countMatrix <- as.matrix(allCounts[,-1])
rownames(countMatrix) <- allCounts[,1]
```

## generate DESeq2 object from counts matrix
```{r}
dds <- DESeqDataSetFromMatrix(countData = countMatrix, colData = coldata, design = ~ condition)
featureData <- data.frame(operon = rownames(countMatrix))
mcols(dds) <- DataFrame(mcols(dds), featureData)
mcols(dds)
dds <- DESeq(dds)
res <- results(dds)
res.data <- as.data.frame(res)

```

## get shrunken log2 fold changes for pairwise analyses of interest
```{r}

LFC <- function(data, condition1, condition2, estimator){
  
  lfcShrink(dds = data, contrast = c("condition", condition1, condition2), type = estimator) %>%
    as.data.frame()
  
}

res_PCvPH <- LFC(dds, "PRO-seq_HeatShock", "PRO-seq_Control", "ashr")
res_RCvRH <- LFC(dds, "RNA-seq_HeatShock", "RNA-seq_Control", "ashr")
res_PCvRC <- LFC(dds, "RNA-seq_Control", "PRO-seq_Control", "ashr")
res_PHvRH <- LFC(dds, "RNA-seq_HeatShock", "PRO-seq_HeatShock", "ashr")

```

## get lists of operons for each sigma group
```{r}

get_oplist <- function(sigma) {
  
  # uses closest_promoters object from Promoter Proximal Coverage section
  
  closest_promoters %>% filter(sigma_factor == sigma) %>% separate(., regulated_operon, into = c("op_id","op_name"), sep = "\t")

}

# classifies all operons by their right-most promoter sequence
s70_list_closest <- get_oplist("Sigma70")
s32_list_closest <- get_oplist("Sigma32")
s24_list_closest <- get_oplist("Sigma24")

# classifies all single-promoter operons
s70_list_single <- ops_sub[ops_sub$sigma_name == "Sigma70",]
s32_list_single <- ops_sub[ops_sub$sigma_name == "Sigma32",]
s24_list_single <- ops_sub[ops_sub$sigma_name == "Sigma24",]
```

## plot volcano function
```{r}

# original plotting function

plotVolcano <- function(res, Title, featuretype, labs = F) {

  #order is important here for proper coloration of groups 

  key.col <- rep('gray', nrow(res))
  names(key.col) <- rep('Other Operons', nrow(res))

  key.col[which(res$log2FoldChange > 3 & res$padj < 1e-100)] <- 'royalblue'
  names(key.col)[which(res$log2FoldChange > 3 & res$padj < 1e-100)] <- '> 8-fold change, P < 1e-100'

  key.col[which(res$log2FoldChange < -3 & res$pvalue < 1e-100)] <- 'royalblue'
  names(key.col)[which(res$log2FoldChange < -3 & res$padj < 1e-100)] <- '> 8-fold change, P < 1e-100'

  key.col[which(rownames(res) %in% HSlabs)] <- 'red'
  names(key.col)[which(rownames(res) %in% HSlabs)] <- 'Sigma32 Operons'

  #key.col[which(rownames(res) %in% NClabs)] <- 'darkgoldenrod2'
  #names(key.col)[which(rownames(res) %in% NClabs)] <- 'ncRNAs'
  
  #templab <- as.data.frame(subset(res, rownames(res) %in% HSlabs))
  
  nm <- deparse(substitute(res))
  
  if (labs) {
    
    labs_edit <- c(rownames(res[(res$log2FoldChange <= -3 | res$log2FoldChange >= 3) & res$padj <= 1e-100,]))
    fname <- paste(nm, featuretype, "padj_flipped_labs.pdf", sep = "_")
    
  } else if (!labs) {
    
    labs_edit <- NA
    fname <- paste(nm, featuretype, "padj_flipped.pdf", sep = "_")
    
  }
  
  #pdf(file = fname, useDingbats = F)
  
  vc1 <- EnhancedVolcano(res,
      lab = rownames(res),
      x = 'log2FoldChange',
      y = 'padj',
      xlim = c(-5, 5),
      title = Title,
      subtitle = featuretype,
      caption = '',
      titleLabSize = 12,
      subtitleLabSize = 10,
      pCutoff = 1e-100,
      FCcutoff = 3,
      cutoffLineType = 'blank',
      #cutoffLineCol = 'blank',
      pointSize = 1,
      labSize = 2.5,
      col=c('black', 'black', 'black', 'royalblue'),
      colAlpha = 1,
      legendPosition = "right",
      legendLabSize = 8,
      legendIconSize = 2.5,
      cutoffLineCol = "black",
      ylim = c(0,100),
      labCol = 'black',
      #labFace = 'bold',
      boxedLabels = T,
      selectLab = labs_edit,
      drawConnectors = T,
      widthConnectors = 0.4,
      colConnectors = "gray50",
      colCustom = key.col)

  print(vc1)

  #dev.off()

}
```

## plot volcano function, modified to create supplemental volcanos for promoter plot
```{r}

# original plotting function

plotVolcano2 <- function(res, sigma_labs, Title, featuretype, labs = F) {
  
  # res1 <- res[-which(rownames(res) %in% sigma_labs),]
  # res2 <- res[which(rownames(res) %in% sigma_labs),]
  # 
  # res_order <- rbind(res2, res1)
  
  res_order <- res[which(rownames(res) %in% sigma_labs),]
  
  key.col <- rep('gray50', nrow(res_order))
  names(key.col) <- rep('Other Operons', nrow(res_order))

  key.col[which(rownames(res_order) %in% sigma_labs)] <- 'red'
  names(key.col)[which(rownames(res_order) %in% sigma_labs)] <- 'Sigma Operons'
  
  nm <- deparse(substitute(res))
  
  if (labs) {
    
    labs_edit <- c(rownames(res_order[(res_order$log2FoldChange <= -3 | res_order$log2FoldChange >= 3) & res_order$padj <= 1e-100,]))
    fname <- paste(nm, featuretype, "padj_flipped_labs.pdf", sep = "_")
    
  } else if (!labs) {
    
    labs_edit <- NA
    fname <- paste(nm, featuretype, "padj_flipped.pdf", sep = "_")
    
  }
  
  #pdf(file = fname, useDingbats = F)
  
  vc1 <- EnhancedVolcano(res_order,
      lab = rownames(res_order),
      x = 'log2FoldChange',
      y = 'padj',
      xlim = c(-5, 5),
      title = Title,
      subtitle = featuretype,
      caption = '',
      titleLabSize = 12,
      subtitleLabSize = 10,
      pCutoff = 1e-100,
      FCcutoff = 3,
      cutoffLineType = 'solid',
      #cutoffLineCol = 'black',
      pointSize = 1,
      labSize = 2.5,
      col=c('black', 'black', 'black', 'royalblue'),
      colAlpha = 1,
      legendPosition = "right",
      legendLabSize = 8,
      legendIconSize = 2.5,
      cutoffLineCol = "black",
      ylim = c(0,100),
      labCol = 'black',
      #labFace = 'bold',
      boxedLabels = T,
      selectLab = labs_edit,
      drawConnectors = T,
      widthConnectors = 0.4,
      colConnectors = "gray50",
      colCustom = key.col,
      gridlines.major = FALSE,
    gridlines.minor = FALSE)

  print(vc1)

  #dev.off()

}
```

## apply plotvolcano function
```{r}
setwd(dir = "/local/workdir/users/acv46/EC_PROSeq/figures/volcano")

#HSlans <- HSonly.labs
HSlabs <- HSall.labs
featuretype <- "Operons"

plotVolcano(res_PCvPH, 'PRO-seq HS v. PRO-seq Control', featuretype, labs = T)
plotVolcano(res_RCvRH, 'RNA-seq HS v. RNA-seq Control', featuretype, labs = T)
plotVolcano(res_PCvRC, 'PRO-seq Control v. RNA-seq Control', featuretype, labs = T)
plotVolcano(res_PHvRH, 'PRO-seq HS v. RNA-seq HS', featuretype, labs = T)
```

## apply plotvolcano2 function
```{r}
setwd(dir = "/local/workdir/users/acv46/EC_PROSeq/figures/volcano")

#HSlabs <- HSall.labs
featuretype <- "Operons"

plotVolcano2(res_RCvRH, s70_list_single$name, 'RNA-seq HS v. RNA-seq Control, s70', featuretype, labs = F)
plotVolcano2(res_RCvRH, s32_list_single$name, 'RNA-seq HS v. RNA-seq Control, s32', featuretype, labs = F)
plotVolcano2(res_RCvRH, s24_list_single$name, 'RNA-seq HS v. RNA-seq Control, s24', featuretype, labs = F)
```

# Differential expression volcano plots, sRNAs

## BiocManager Installations
```{r}
# Bioconductor installation only works with R 4.0

#if (!requireNamespace("BiocManager", quietly = TRUE))
#    install.packages("BiocManager")
#BiocManager::install(version = "3.11")

if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

BiocManager::install("Rsubread")
BiocManager::install("BRGenomics")
BiocManager::install("rtracklayer")
library(Rsubread)
library(rtracklayer)
library(BRGenomics)
devtools::install_github('kevinblighe/EnhancedVolcano')
library(EnhancedVolcano)
library(regutools)
library(DESeq2)
library(ashr)
```

## create bam list, all bams
```{r}
# bam files resorted and indexed following 
# create named vector of bam files

files <- c("PC1_dedup_QC_end.sort.bam",
          "PC2_dedup_QC_end.sort.bam",
          "PC3_dedup_QC_end.sort.bam",
          "PH1_dedup_QC_end.sort.bam",
          "PH2_dedup_QC_end.sort.bam",
          "PH3_dedup_QC_end.sort.bam",
          "RCD1_QC_end.sort.bam",
          "RCD2_QC_end.sort.bam",
          "RHD1_QC_end.sort.bam",
          "RHD2_QC_end.sort.bam")
filenames <- c("PC1",
          "PC2",
          "PC3",
          "PH1",
          "PH2",
          "PH3",
          "RCD1",
          "RCD2",
          "RHD1",
          "RHD2")
bam_list <- tibble(files, filenames)

```

## retrieve regulonDB and create GRanges objects
```{r}
## Build a regulondb object
## stores database at /home/acv46/.cache/AnnotationHub
e_coli_regulondb <- regulondb(database_conn = connect_database(),
                              organism = "E.coli",
                              database_version = "10.6",
                              genome_version = "NC_000913.3")

#list_datasets(e_coli_regulondb)
#list_attributes(e_coli_regulondb, dataset = "PROMOTER")

## datasets

dna_objects <- get_dataset(e_coli_regulondb, dataset = "DNA_OBJECTS") %>%
  convert_to_granges(.) %>%
  renameSeqlevels(., "NC_000913.3")

sRNA_labs <- get_dataset(e_coli_regulondb, dataset = "DNA_OBJECTS")
sRNA_labs <- sRNA_labs[which(sRNA_labs$type == "sRNA interaction"),]
sRNA_labs <- sRNA_labs$name

HSall <- operons[grepl("Sigma32", operons$sigma_name),]
HSall.labs <- HSall$name

```

## export granges objects as gtf
```{r}
setwd("/workdir/users/acv46/EC_PROSeq/proseq2.0/out3/bams/sort")

export(dna_objects, "dna_objects.gtf")

## bash edits

#sed "s/sRNA binds to /(/g" dna_objects.gtf | sed "s/ gene as//g" | sed "s/activator\"/activator)\"/g" | sed "s/repressor\"/repressor)\"/g" | sed "s/ryeA\"/ryeA)\"/g" > dna_objects_sRNA_edit.gtf

# rhyB manually annotated as translational regulator per https://pubmed.ncbi.nlm.nih.gov/20696910/#&gid=article-figures&pid=fig-4-uid-3

#sed "s/sRNA binds to /(/g" dna_objects.gtf | sed "s/ gene as//g" | sed "s/activator\"/activator)\"/g" | sed "s/repressor\"/repressor)\"/g" | sed "s/ryeA\"/ryeA)\"/g" | sed "s/\"\; name \"/ - /g" | sed "s/ryhB (cysE repressor)\"\;/ryhB (cysE repressor)\"\; description \"translational regulation\"/g"> dna_objects_sRNA_edit2.gtf

# gcvB regulation of dppA changed from transcriptional to post-transcriptional, per https://pubmed.ncbi.nlm.nih.gov/18312576/
```

## import manually edited gtf and create labels for plot
```{r}
sRNA_ranges <- rtracklayer::import("/workdir/users/acv46/EC_PROSeq/proseq2.0/out3/bams/sort/dna_objects_sRNA_edit2.gtf")
sRNA_ranges <- sRNA_ranges[sRNA_ranges$type == "sRNA interaction",]

txn <- sRNA_ranges[grepl("post-transcriptional", sRNA_ranges$description),]$id
trl <- sRNA_ranges[grepl("translational", sRNA_ranges$description),]$id
```

## readcounts function using Rsubread::featureCounts
```{r}
readcounts <- function(bam, gtf) {
  
  prof <- featureCounts(files = bam[1], 
                         isPairedEnd = T, 
                         annot.ext = gtf, 
                         isGTFAnnotationFile = T, 
                         GTF.attrType = "id", 
                         requireBothEndsMapped = T, 
                         GTF.featureType = c("sRNA interaction")) #c("CDS","exon","gene") 

  counts <- as.data.frame(prof[["counts"]])
  counts <- cbind(rownames(counts), data.frame(counts, row.names = NULL))
  colnames(counts) <- c("sRNA", bam[2])

  counts[order(counts$sRNA),]

}

#https://support.bioconductor.org/p/110807/
```

## apply readcounts function (creates list of dataframes as counts results)
```{r}

setwd("/workdir/users/acv46/EC_PROSeq/proseq2.0/out3/bams/sort")

counts <- apply(X = bam_list, MARGIN = 1, readcounts, gtf = "dna_objects_sRNA_edit2.gtf")
names(counts) <- bam_list$filenames

```

## merge and subset data, and load coldata
```{r}

allCounts <- counts %>% reduce(left_join, by = "sRNA") %>% na.omit()

coldata <- read.table(file = "/local/workdir/users/acv46/EC_PROSeq/proseq2.0/out3/coldata_noU",
                      header = T,
                      sep = "\t")

#order of rownames must match order of countData columns
rownames(coldata) <- c(bam_list$filenames)

# create matrix for DESEQ2
countMatrix <- as.matrix(allCounts[,-1])
rownames(countMatrix) <- allCounts[,1]
```

## generate DESeq2 object from counts matrix
```{r}
dds <- DESeqDataSetFromMatrix(countData = countMatrix, colData = coldata, design = ~ condition)
featureData <- data.frame(sRNA = rownames(countMatrix))
mcols(dds) <- DataFrame(mcols(dds), featureData)
mcols(dds)
dds <- DESeq(dds)
res <- results(dds)
res.data <- as.data.frame(res)

```

## get shrunken log2 fold changes for pairwise analyses of interest
```{r}

LFC <- function(data, condition1, condition2, estimator){
  
  lfcShrink(dds = data, contrast = c("condition", condition1, condition2), type = estimator) %>%
    as.data.frame()
  
}

res_PCvPH <- LFC(dds, "PRO-seq_HeatShock", "PRO-seq_Control", "ashr")
res_RCvRH <- LFC(dds, "RNA-seq_HeatShock", "RNA-seq_Control", "ashr")
res_PCvRC <- LFC(dds, "RNA-seq_Control", "PRO-seq_Control", "ashr")
res_PHvRH <- LFC(dds, "RNA-seq_HeatShock", "PRO-seq_HeatShock", "ashr")

```

## plot volcano function
```{r}

plotVolcano <- function(res, Title, featuretype, labs = F) {

  #order is important here for proper coloration of groups 

  key.col <- rep('black', nrow(res))
  names(key.col) <- rep('', nrow(res))

  key.col[which(res$log2FoldChange > 2 & res$padj < 1e-5)] <- 'royalblue'
  names(key.col)[which(res$log2FoldChange > 2 & res$padj < 1e-5)] <- '> 8-fold change, P < 1e-100'

  key.col[which(res$log2FoldChange < -2 & res$pvalue < 1e-5)] <- 'royalblue'
  names(key.col)[which(res$log2FoldChange < -2 & res$padj < 1e-5)] <- '> 8-fold change, P < 1e-100'

  key.col[which(rownames(res) %in% txn)] <- 'orange'
  names(key.col)[which(rownames(res) %in% txn)] <- 'Sites of post-transcriptional regulation by sRNA'
  key.col[which(rownames(res) %in% trl)] <- 'blue'
  names(key.col)[which(rownames(res) %in% trl)] <- 'Sites of translational regulation by sRNA'

  #key.col[which(rownames(res) %in% NClabs)] <- 'darkgoldenrod2'
  #names(key.col)[which(rownames(res) %in% NClabs)] <- 'ncRNAs'
  
  #templab <- as.data.frame(subset(res, rownames(res) %in% HSlabs))
  
  nm <- deparse(substitute(res))
  
  if (labs) {
    
    labs_edit <- c(rownames(res[(res$log2FoldChange <= -3 | res$log2FoldChange >= 3) & res$padj <= 1e-100,]))
    fname <- paste(nm, featuretype, "padj_labs.pdf", sep = "_")
    
  } else if (!labs) {
    
    labs_edit <- NA
    fname <- paste(nm, featuretype, "padj.pdf", sep = "_")
    
  }
  
  #pdf(file = fname, useDingbats = F)
  
  vc1 <- EnhancedVolcano(res,
      lab = rownames(res),
      x = 'log2FoldChange',
      y = 'padj',
      xlim = c(-5, 5),
      title = Title,
      subtitle = featuretype,
      caption = '',
      titleLabSize = 12,
      subtitleLabSize = 10,
      pCutoff = 1e-5,
      FCcutoff = 2,
      pointSize = 1,
      labSize = 2.5,
      col=c('black', 'black', 'black', 'royalblue'),
      colAlpha = 1,
      legendPosition = "right",
      legendLabSize = 8,
      legendIconSize = 2.5,
      cutoffLineCol = "black",
      ylim = c(0,15),
      labCol = 'black',
      #labFace = 'bold',
      boxedLabels = T,
      selectLab = labs_edit,
      drawConnectors = T,
      widthConnectors = 0.4,
      colConnectors = "gray50",
      colCustom = key.col)

  print(vc1)

  #dev.off()

}
```

## apply plot volcano function
```{r}
setwd(dir = "/local/workdir/users/acv46/EC_PROSeq/figures/volcano")

#HSlans <- HSonly.labs
featuretype <- "sRNA"

plotVolcano(res_PCvPH, 'PRO-seq HS v. PRO-seq Control', featuretype, labs = T)
plotVolcano(res_RCvRH, 'RNA-seq HS v. RNA-seq Control', featuretype, labs = T)
plotVolcano(res_PCvRC, 'PRO-seq Control v. RNA-seq Control', featuretype, labs = T)
plotVolcano(res_PHvRH, 'PRO-seq HS v. RNA-seq HS', featuretype, labs = T)
```



# Differential expression volcano plots, all DNA objects, highlight RNA types

## BiocManager Installations
```{r}
# Bioconductor installation only works with R 4.0

#if (!requireNamespace("BiocManager", quietly = TRUE))
#    install.packages("BiocManager")
#BiocManager::install(version = "3.11")

if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

BiocManager::install("Rsubread")
BiocManager::install("BRGenomics")
BiocManager::install("rtracklayer")
library(Rsubread)
library(rtracklayer)
library(BRGenomics)
devtools::install_github('kevinblighe/EnhancedVolcano')
library(EnhancedVolcano)
library(regutools)
library(DESeq2)
library(ashr)
```

## create bam list, all bams
```{r}
# bam files resorted and indexed following 
# create named vector of bam files

files <- c("PC1_dedup_QC_end.sort.bam",
          "PC2_dedup_QC_end.sort.bam",
          "PC3_dedup_QC_end.sort.bam",
          "PH1_dedup_QC_end.sort.bam",
          "PH2_dedup_QC_end.sort.bam",
          "PH3_dedup_QC_end.sort.bam",
          "RCD1_QC_end.sort.bam",
          "RCD2_QC_end.sort.bam",
          "RHD1_QC_end.sort.bam",
          "RHD2_QC_end.sort.bam")
filenames <- c("PC1",
          "PC2",
          "PC3",
          "PH1",
          "PH2",
          "PH3",
          "RCD1",
          "RCD2",
          "RHD1",
          "RHD2")
bam_list <- tibble(files, filenames)

```

## retrieve regulonDB and create GRanges objects
```{r}
## Build a regulondb object
## stores database at /home/acv46/.cache/AnnotationHub
e_coli_regulondb_10.9 <- regulondb(database_conn = connect_database(),
                              organism = "E.coli",
                              database_version = "10.9",
                              genome_version = "NC_000913.3")

#list_datasets(e_coli_regulondb)
#list_attributes(e_coli_regulondb, dataset = "PROMOTER")

## datasets

genes <- get_dataset(e_coli_regulondb_10.9, 
                     dataset = "GENE") %>%
  convert_to_granges(.) %>%
  renameSeqlevels(., "NC_000913.3")


# Subread doesn't work with some combinations of attribute names
genes_sub <- get_dataset(e_coli_regulondb_10.9, 
                     dataset = "GENE",
                     attributes = c("posleft", "posright", "strand", "name", "sigma_factor", "operon_name", "id")) %>%
  convert_to_granges(.) %>%
  renameSeqlevels(., "NC_000913.3")

```

## export granges objects as gtf
```{r}
setwd("/workdir/users/acv46/EC_PROSeq/proseq2.0/out3/bams/sort")

export(genes_sub, "genes.gtf")

## bash edits

#sed "s/sRNA binds to /(/g" dna_objects.gtf | sed "s/ gene as//g" | sed "s/activator\"/activator)\"/g" | sed "s/repressor\"/repressor)\"/g" | sed "s/ryeA\"/ryeA)\"/g" > dna_objects_sRNA_edit.gtf

# rhyB manually annotated as translational regulator per https://pubmed.ncbi.nlm.nih.gov/20696910/#&gid=article-figures&pid=fig-4-uid-3

#sed "s/sRNA binds to /(/g" dna_objects.gtf | sed "s/ gene as//g" | sed "s/activator\"/activator)\"/g" | sed "s/repressor\"/repressor)\"/g" | sed "s/ryeA\"/ryeA)\"/g" | sed "s/\"\; name \"/ - /g" | sed "s/ryhB (cysE repressor)\"\;/ryhB (cysE repressor)\"\; description \"translational regulation\"/g"> dna_objects_sRNA_edit2.gtf

# gcvB regulation of dppA changed from transcriptional to post-transcriptional, per https://pubmed.ncbi.nlm.nih.gov/18312576/
```

## import manually edited gtf and create labels for plot
```{r}
rRNA <- genes[which(genes$product_type == "rRNA"),]$id
tRNA <- genes[which(genes$product_type == "tRNAs"),]$id
sRNA <- genes[which(genes$product_type == "small RNA"),]$id
```

## readcounts function using Rsubread::featureCounts
```{r}
readcounts <- function(bam, gtf) {
  
  prof <- featureCounts(files = bam[1], 
                         isPairedEnd = T, 
                         annot.ext = gtf, 
                         isGTFAnnotationFile = T, 
                         GTF.attrType = "id", 
                         requireBothEndsMapped = T, 
                         GTF.featureType = c("sequence_feature")) #c("CDS","exon","gene") 

  counts <- as.data.frame(prof[["counts"]])
  counts <- cbind(rownames(counts), data.frame(counts, row.names = NULL))
  colnames(counts) <- c("id", bam[2])

  counts[order(counts$id),]

}

#https://support.bioconductor.org/p/110807/
```

## apply readcounts function (creates list of dataframes as counts results)
```{r}

setwd("/workdir/users/acv46/EC_PROSeq/proseq2.0/out3/bams/sort")

counts <- apply(X = bam_list, MARGIN = 1, readcounts, gtf = "genes.gtf")
names(counts) <- bam_list$filenames

```

## merge and subset data, and load coldata
```{r}

allCounts <- counts %>% reduce(left_join, by = "id") %>% na.omit()

coldata <- read.table(file = "/local/workdir/users/acv46/EC_PROSeq/proseq2.0/out3/coldata_noU",
                      header = T,
                      sep = "\t")

#order of rownames must match order of countData columns
rownames(coldata) <- c(bam_list$filenames)

# create matrix for DESEQ2
countMatrix <- as.matrix(allCounts[,-1])
rownames(countMatrix) <- allCounts[,1]
```

## generate DESeq2 object from counts matrix
```{r}
dds <- DESeqDataSetFromMatrix(countData = countMatrix, colData = coldata, design = ~ condition)
featureData <- data.frame(sRNA = rownames(countMatrix))
mcols(dds) <- DataFrame(mcols(dds), featureData)
mcols(dds)
dds <- DESeq(dds)
res <- results(dds)
res.data <- as.data.frame(res)

```

## get shrunken log2 fold changes for pairwise analyses of interest
```{r}

LFC <- function(data, condition1, condition2, estimator){
  
  lfcShrink(dds = data, contrast = c("condition", condition1, condition2), type = estimator) %>%
    as.data.frame()
  
}

res_PCvPH <- LFC(dds, "PRO-seq_HeatShock", "PRO-seq_Control", "ashr")
res_RCvRH <- LFC(dds, "RNA-seq_HeatShock", "RNA-seq_Control", "ashr")
res_PCvRC <- LFC(dds, "RNA-seq_Control", "PRO-seq_Control", "ashr")
res_PHvRH <- LFC(dds, "RNA-seq_HeatShock", "PRO-seq_HeatShock", "ashr")

```

## plot volcano function
```{r}

plotVolcano <- function(res, Title, featuretype, labs = F) {

  #order is important here for proper coloration of groups 

  key.col <- rep('gray30', nrow(res))
  names(key.col) <- rep('protein-coding genes', nrow(res))

  #key.col[which(res$log2FoldChange > 2 & res$padj < 1e-5)] <- 'royalblue'
  #names(key.col)[which(res$log2FoldChange > 2 & res$padj < 1e-5)] <- '> 8-fold change, P < 1e-100'

  #key.col[which(res$log2FoldChange < -2 & res$pvalue < 1e-5)] <- 'royalblue'
  #names(key.col)[which(res$log2FoldChange < -2 & res$padj < 1e-5)] <- '> 8-fold change, P < 1e-100'
  
  # reorder res so that all "genes" are plotted first
  # rRNA, tRNA, sRNA dataframes from above
  
  second <- res[which(rownames(res) %in% rRNA | rownames(res) %in% tRNA | rownames(res) %in% sRNA),]
  first <- res[-which(rownames(res) %in% rRNA | rownames(res) %in% tRNA | rownames(res) %in% sRNA),]
  
  res_ordered <- rbind(first, second)
  
  key.col[which(rownames(res_ordered) %in% rRNA)] <- '#1b9e77'
  names(key.col)[which(rownames(res_ordered) %in% rRNA)] <- 'rRNAs'
  key.col[which(rownames(res_ordered) %in% tRNA)] <- '#d95f02'
  names(key.col)[which(rownames(res_ordered) %in% tRNA)] <- 'tRNAs'
  key.col[which(rownames(res_ordered) %in% sRNA)] <- '#7570b3'
  names(key.col)[which(rownames(res_ordered) %in% sRNA)] <- 'sRNAs'

  #key.col[which(rownames(res) %in% NClabs)] <- 'darkgoldenrod2'
  #names(key.col)[which(rownames(res) %in% NClabs)] <- 'ncRNAs'
  
  #templab <- as.data.frame(subset(res, rownames(res) %in% HSlabs))
  
  nm <- deparse(substitute(res))
  
  if (labs) {
    
    labs_edit <- c(rownames(res_ordered[(res_ordered$log2FoldChange <= -3 | res_ordered$log2FoldChange >= 3) & res_ordered$padj <= 1e-100,]))
    fname <- paste(nm, featuretype, "padj_labs.pdf", sep = "_")
    
  } else if (!labs) {
    
    labs_edit <- NA
    fname <- paste(nm, featuretype, "padj.pdf", sep = "_")
    
  }
  
  pdf(file = fname, useDingbats = F)
  
  vc1 <- EnhancedVolcano(res_ordered,
      lab = rownames(res_ordered),
      x = 'log2FoldChange',
      y = 'padj',
      xlim = c(-5, 5),
      title = Title,
      subtitle = featuretype,
      caption = '',
      titleLabSize = 12,
      subtitleLabSize = 10,
      pCutoff = 1e-100,
      FCcutoff = 3,
      pointSize = c(ifelse(rownames(res_ordered) %in% rownames(second), 2, 1)),
      labSize = 2.5,
      col = c('black', 'black', 'black', 'royalblue'),
      colAlpha = 0.5,
      legendPosition = "right",
      legendLabSize = 8,
      legendIconSize = 2.5,
      cutoffLineCol = "black",
      ylim = c(0,250),
      labCol = 'black',
      #labFace = 'bold',
      boxedLabels = T,
      selectLab = labs_edit,
      drawConnectors = T,
      widthConnectors = 0.4,
      colConnectors = "gray60",
      colCustom = key.col)

  print(vc1)

  dev.off()

}
```

## apply plot volcano function
```{r}
setwd(dir = "/local/workdir/users/acv46/EC_PROSeq/figures/volcano")

#HSlans <- HSonly.labs
featuretype <- "Genes"

plotVolcano(res_PCvPH, 'PRO-seq HS v. PRO-seq Control', featuretype, labs = F)
plotVolcano(res_RCvRH, 'RNA-seq HS v. RNA-seq Control', featuretype, labs = F)
plotVolcano(res_PCvRC, 'PRO-seq Control v. RNA-seq Control', featuretype, labs = F)
plotVolcano(res_PHvRH, 'PRO-seq HS v. RNA-seq HS', featuretype, labs = F)
```

# Differential expression volcano plots, all DNA objects, highlight sigma factors

## BiocManager Installations
```{r}
# Bioconductor installation only works with R 4.0

#if (!requireNamespace("BiocManager", quietly = TRUE))
#    install.packages("BiocManager")
#BiocManager::install(version = "3.11")

if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

BiocManager::install("Rsubread")
BiocManager::install("BRGenomics")
BiocManager::install("rtracklayer")
library(Rsubread)
library(rtracklayer)
library(BRGenomics)
devtools::install_github('kevinblighe/EnhancedVolcano')
library(EnhancedVolcano)
library(regutools)
library(DESeq2)
library(ashr)
```

## create bam list, all bams
```{r}
# bam files resorted and indexed following 
# create named vector of bam files

files <- c("PC1_dedup_QC_end.sort.bam",
          "PC2_dedup_QC_end.sort.bam",
          "PC3_dedup_QC_end.sort.bam",
          "PH1_dedup_QC_end.sort.bam",
          "PH2_dedup_QC_end.sort.bam",
          "PH3_dedup_QC_end.sort.bam",
          "RCD1_QC_end.sort.bam",
          "RCD2_QC_end.sort.bam",
          "RHD1_QC_end.sort.bam",
          "RHD2_QC_end.sort.bam")
filenames <- c("PC1",
          "PC2",
          "PC3",
          "PH1",
          "PH2",
          "PH3",
          "RCD1",
          "RCD2",
          "RHD1",
          "RHD2")
bam_list <- tibble(files, filenames)

```

## retrieve regulonDB and create GRanges objects
```{r}
## Build a regulondb object
## stores database at /home/acv46/.cache/AnnotationHub
e_coli_regulondb_10.9 <- regulondb(database_conn = connect_database(),
                              organism = "E.coli",
                              database_version = "10.9",
                              genome_version = "NC_000913.3")

#list_datasets(e_coli_regulondb)
#list_attributes(e_coli_regulondb, dataset = "PROMOTER")

## datasets

genes <- get_dataset(e_coli_regulondb_10.9, 
                     dataset = "GENE") %>%
  convert_to_granges(.) %>%
  renameSeqlevels(., "NC_000913.3")


# Subread doesn't work with some combinations of attribute names
genes_sub <- get_dataset(e_coli_regulondb_10.9, 
                     dataset = "GENE",
                     attributes = c("posleft", "posright", "strand", "name", "sigma_factor", "operon_name", "id")) %>%
  convert_to_granges(.) %>%
  renameSeqlevels(., "NC_000913.3")

```

## export granges objects as gtf
```{r}
setwd("/workdir/users/acv46/EC_PROSeq/proseq2.0/out3/bams/sort")

export(genes_sub, "genes.gtf")

## bash edits

#sed "s/sRNA binds to /(/g" dna_objects.gtf | sed "s/ gene as//g" | sed "s/activator\"/activator)\"/g" | sed "s/repressor\"/repressor)\"/g" | sed "s/ryeA\"/ryeA)\"/g" > dna_objects_sRNA_edit.gtf

# rhyB manually annotated as translational regulator per https://pubmed.ncbi.nlm.nih.gov/20696910/#&gid=article-figures&pid=fig-4-uid-3

#sed "s/sRNA binds to /(/g" dna_objects.gtf | sed "s/ gene as//g" | sed "s/activator\"/activator)\"/g" | sed "s/repressor\"/repressor)\"/g" | sed "s/ryeA\"/ryeA)\"/g" | sed "s/\"\; name \"/ - /g" | sed "s/ryhB (cysE repressor)\"\;/ryhB (cysE repressor)\"\; description \"translational regulation\"/g"> dna_objects_sRNA_edit2.gtf

# gcvB regulation of dppA changed from transcriptional to post-transcriptional, per https://pubmed.ncbi.nlm.nih.gov/18312576/
```

## single sigma groups
```{r}
# 1719 objects under control of a single sigma factor
# 392 objects under control of multiple sigma factors
# 2472 objects "NA"

s38 <- genes[which(genes$sigma_factor == "Sigma38"),]
s32 <- genes[which(genes$sigma_factor == "Sigma32"),]
s70 <- genes[which(genes$sigma_factor == "Sigma70"),]
s28 <- genes[which(genes$sigma_factor == "Sigma28"),]
s24 <- genes[which(genes$sigma_factor == "Sigma24"),]
s54 <- genes[which(genes$sigma_factor == "Sigma54"),]
single <- c(s28,s32,s24,s54,s38,s70)

combo_single <- granges(single, use.mcols = T)
```

## readcounts function using Rsubread::featureCounts
```{r}
readcounts <- function(bam, gtf) {
  
  prof <- featureCounts(files = bam[1], 
                         isPairedEnd = T, 
                         annot.ext = gtf, 
                         isGTFAnnotationFile = T, 
                         GTF.attrType = "id", 
                         requireBothEndsMapped = T, 
                         GTF.featureType = c("sequence_feature")) #c("CDS","exon","gene") 

  counts <- as.data.frame(prof[["counts"]])
  counts <- cbind(rownames(counts), data.frame(counts, row.names = NULL))
  colnames(counts) <- c("id", bam[2])

  counts[order(counts$id),]

}

#https://support.bioconductor.org/p/110807/
```

## apply readcounts function (creates list of dataframes as counts results)
```{r}

setwd("/workdir/users/acv46/EC_PROSeq/proseq2.0/out3/bams/sort")

counts <- apply(X = bam_list, MARGIN = 1, readcounts, gtf = "genes.gtf")
names(counts) <- bam_list$filenames

```

## merge and subset data, and load coldata
```{r}

allCounts <- counts %>% reduce(left_join, by = "id") %>% na.omit()

coldata <- read.table(file = "/local/workdir/users/acv46/EC_PROSeq/proseq2.0/out3/coldata_noU",
                      header = T,
                      sep = "\t")

#order of rownames must match order of countData columns
rownames(coldata) <- c(bam_list$filenames)

# create matrix for DESEQ2
countMatrix <- as.matrix(allCounts[,-1])
rownames(countMatrix) <- allCounts[,1]
```

## generate DESeq2 object from counts matrix
```{r}
dds <- DESeqDataSetFromMatrix(countData = countMatrix, colData = coldata, design = ~ condition)
featureData <- data.frame(sRNA = rownames(countMatrix))
mcols(dds) <- DataFrame(mcols(dds), featureData)
mcols(dds)
dds <- DESeq(dds)
res <- results(dds)
res.data <- as.data.frame(res)

```

## get shrunken log2 fold changes for pairwise analyses of interest
```{r}

LFC <- function(data, condition1, condition2, estimator){
  
  lfcShrink(dds = data, contrast = c("condition", condition1, condition2), type = estimator) %>%
    as.data.frame()
  
}

res_PCvPH <- LFC(dds, "PRO-seq_HeatShock", "PRO-seq_Control", "ashr")
res_RCvRH <- LFC(dds, "RNA-seq_HeatShock", "RNA-seq_Control", "ashr")
res_PCvRC <- LFC(dds, "RNA-seq_Control", "PRO-seq_Control", "ashr")
res_PHvRH <- LFC(dds, "RNA-seq_HeatShock", "PRO-seq_HeatShock", "ashr")

```

## plot volcano function
```{r}

plotVolcano <- function(res, Title, featuretype, labs = F) {

  #order is important here for proper coloration of groups 
  
  pal <- c("#56a3a6","#ffc857","#e9724c","#c5283d","#4e4187","#d30c7b","#6eeb83")

  key.col <- rep('gray30', nrow(res))
  names(key.col) <- rep('unannotated', nrow(res))

  #key.col[which(res$log2FoldChange > 2 & res$padj < 1e-5)] <- 'royalblue'
  #names(key.col)[which(res$log2FoldChange > 2 & res$padj < 1e-5)] <- '> 8-fold change, P < 1e-100'

  #key.col[which(res$log2FoldChange < -2 & res$pvalue < 1e-5)] <- 'royalblue'
  #names(key.col)[which(res$log2FoldChange < -2 & res$padj < 1e-5)] <- '> 8-fold change, P < 1e-100'
  
  # reorder res so that all "genes" are plotted first
  # rRNA, tRNA, sRNA dataframes from above
  
  first <- res[-which(rownames(res) %in% combo_single$id),]
  second <- res[which(rownames(res) %in% combo_single$id),]
  
  res_ordered <- rbind(first, second)
  
  key.col[which(rownames(res_ordered) %in% s38$id)] <- pal[1]
  names(key.col)[which(rownames(res_ordered) %in% s38$id)] <- 'sigma38'
  key.col[which(rownames(res_ordered) %in% s32$id)] <- pal[2]
  names(key.col)[which(rownames(res_ordered) %in% s32$id)] <- 'sigma32'
  key.col[which(rownames(res_ordered) %in% s70$id)] <- pal[3]
  names(key.col)[which(rownames(res_ordered) %in% s70$id)] <- 'sigma70'
  key.col[which(rownames(res_ordered) %in% s28$id)] <- pal[4]
  names(key.col)[which(rownames(res_ordered) %in% s28$id)] <- 'sigma28'
  key.col[which(rownames(res_ordered) %in% s24$id)] <- pal[5]
  names(key.col)[which(rownames(res_ordered) %in% s24$id)] <- 'sigma24'
  key.col[which(rownames(res_ordered) %in% s54$id)] <- pal[6]
  names(key.col)[which(rownames(res_ordered) %in% s54$id)] <- 'sigma54'
  key.col[which(rownames(res_ordered) %in% genes[is.na(genes$sigma_factor)]$id)] <- pal[7]
  names(key.col)[which(rownames(res_ordered) %in% genes[is.na(genes$sigma_factor)]$id)] <- 'sigma38'

  #key.col[which(rownames(res) %in% NClabs)] <- 'darkgoldenrod2'
  #names(key.col)[which(rownames(res) %in% NClabs)] <- 'ncRNAs'
  
  #templab <- as.data.frame(subset(res, rownames(res) %in% HSlabs))
  
  nm <- deparse(substitute(res))
  
  if (labs) {
    
    labs_edit <- c(rownames(res_ordered[(res_ordered$log2FoldChange <= -3 | res_ordered$log2FoldChange >= 3) & res_ordered$padj <= 1e-100,]))
    fname <- paste(nm, featuretype, "padj_bysigma_labs.png", sep = "_")
    
  } else if (!labs) {
    
    labs_edit <- NA
    fname <- paste(nm, featuretype, "padj_bysigma.png", sep = "_")
    
  }
  
  png(file = fname, res = 600, width = 8, height = 6)
  
  vc1 <- EnhancedVolcano(res_ordered,
      lab = rownames(res_ordered),
      x = 'log2FoldChange',
      y = 'padj',
      xlim = c(-5, 5),
      title = Title,
      subtitle = featuretype,
      caption = '',
      titleLabSize = 12,
      subtitleLabSize = 10,
      pCutoff = 1e-100,
      FCcutoff = 3,
      pointSize = c(ifelse(rownames(res_ordered) %in% rownames(second), 2, 1)),
      labSize = 2.5,
      col = c('black', 'black', 'black', 'royalblue'),
      colAlpha = 0.5,
      legendPosition = "right",
      legendLabSize = 8,
      legendIconSize = 2.5,
      cutoffLineCol = "black",
      ylim = c(0,200),
      labCol = 'black',
      #labFace = 'bold',
      boxedLabels = T,
      selectLab = labs_edit,
      drawConnectors = T,
      widthConnectors = 0.4,
      colConnectors = "gray60",
      colCustom = key.col)

  print(vc1)

  dev.off()

}
```

## apply plot volcano function
```{r}
setwd(dir = "/local/workdir/users/acv46/EC_PROSeq/figures/volcano")

#HSlans <- HSonly.labs
featuretype <- "Genes"

plotVolcano(res_PCvPH, 'PRO-seq HS v. PRO-seq Control', featuretype, labs = F)
plotVolcano(res_RCvRH, 'RNA-seq HS v. RNA-seq Control', featuretype, labs = F)
plotVolcano(res_PCvRC, 'PRO-seq Control v. RNA-seq Control', featuretype, labs = F)
plotVolcano(res_PHvRH, 'PRO-seq HS v. RNA-seq HS', featuretype, labs = F)
```

# rRNA abundance plot

## BiocManager Installations
```{r}
# Bioconductor installation only works with R 4.0

#if (!requireNamespace("BiocManager", quietly = TRUE))
#    install.packages("BiocManager")
#BiocManager::install(version = "3.11")

if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

BiocManager::install("Rsubread")
#BiocManager::install("BRGenomics")
#BiocManager::install("rtracklayer")
library(Rsubread)
library(rtracklayer)
library(BRGenomics)
#devtools::install_github('kevinblighe/EnhancedVolcano')
#library(EnhancedVolcano)
library(regutools)
library(DESeq2)
#library(ashr)
library(tidyverse)
```

## create bam list, all bams
```{r}
# bam files resorted and indexed following 
# create named vector of bam files

files <- c("PC1_dedup_QC_end.sort.bam",
          "PC2_dedup_QC_end.sort.bam",
          "PC3_dedup_QC_end.sort.bam",
          "PH1_dedup_QC_end.sort.bam",
          "PH2_dedup_QC_end.sort.bam",
          "PH3_dedup_QC_end.sort.bam",
          "RCD1_QC_end.sort.bam",
          "RCD2_QC_end.sort.bam",
          "RHD1_QC_end.sort.bam",
          "RHD2_QC_end.sort.bam",
          "RCU1_QC_end.sort.bam",
          "RCU2_QC_end.sort.bam",
          "RHU1_QC_end.sort.bam",
          "RHU2_QC_end.sort.bam")
filenames <- c("PC1",
          "PC2",
          "PC3",
          "PH1",
          "PH2",
          "PH3",
          "RCD1",
          "RCD2",
          "RHD1",
          "RHD2",
          "RCU1",
          "RCU2",
          "RHU1",
          "RHU2")
bam_list <- tibble(files, filenames)

```

## retrieve regulonDB and create GRanges objects
```{r}
## Build a regulondb object
## stores database at /home/acv46/.cache/AnnotationHub
e_coli_regulondb_10.9 <- regulondb(database_conn = connect_database(),
                              organism = "E.coli",
                              database_version = "10.9",
                              genome_version = "NC_000913.3")

#list_datasets(e_coli_regulondb)
#list_attributes(e_coli_regulondb, dataset = "PROMOTER")

## datasets

genes <- get_dataset(e_coli_regulondb_10.9, 
                     dataset = "GENE") %>%
  convert_to_granges(.) %>%
  renameSeqlevels(., "NC_000913.3")


# Subread doesn't work with some combinations of attribute names
genes_sub <- get_dataset(e_coli_regulondb_10.9, 
                     dataset = "GENE",
                     attributes = c("posleft", "posright", "strand", "name", "sigma_factor", "operon_name", "id")) %>%
  convert_to_granges(.) %>%
  renameSeqlevels(., "NC_000913.3")

rRNA <- genes[which(genes$product_type == "rRNA"),]
```

## export granges objects as gtf
```{r}
setwd("/workdir/users/acv46/EC_PROSeq/proseq2.0/out3/bams/sort")

export(genes_sub, "genes.gtf")

## bash edits

#sed "s/sRNA binds to /(/g" dna_objects.gtf | sed "s/ gene as//g" | sed "s/activator\"/activator)\"/g" | sed "s/repressor\"/repressor)\"/g" | sed "s/ryeA\"/ryeA)\"/g" > dna_objects_sRNA_edit.gtf

# rhyB manually annotated as translational regulator per https://pubmed.ncbi.nlm.nih.gov/20696910/#&gid=article-figures&pid=fig-4-uid-3

#sed "s/sRNA binds to /(/g" dna_objects.gtf | sed "s/ gene as//g" | sed "s/activator\"/activator)\"/g" | sed "s/repressor\"/repressor)\"/g" | sed "s/ryeA\"/ryeA)\"/g" | sed "s/\"\; name \"/ - /g" | sed "s/ryhB (cysE repressor)\"\;/ryhB (cysE repressor)\"\; description \"translational regulation\"/g"> dna_objects_sRNA_edit2.gtf

# gcvB regulation of dppA changed from transcriptional to post-transcriptional, per https://pubmed.ncbi.nlm.nih.gov/18312576/
```

## readcounts function using Rsubread::featureCounts
```{r}
readcounts <- function(bam, gtf) {
  
  prof <- featureCounts(files = bam[1], 
                         isPairedEnd = T, 
                         annot.ext = gtf, 
                         isGTFAnnotationFile = T, 
                         GTF.attrType = "id", 
                         requireBothEndsMapped = T, 
                         GTF.featureType = c("sequence_feature")) #c("CDS","exon","gene") 

  counts <- as.data.frame(prof[["counts"]])
  counts <- cbind(rownames(counts), data.frame(counts, row.names = NULL))
  colnames(counts) <- c("id", bam[2])

  counts[order(counts$id),]

}

#https://support.bioconductor.org/p/110807/
```

## apply readcounts function (creates list of dataframes as counts results)
```{r}

setwd("/workdir/users/acv46/EC_PROSeq/proseq2.0/out3/bams/sort")

counts <- apply(X = bam_list, MARGIN = 1, readcounts, gtf = "genes.gtf")
names(counts) <- bam_list$filenames

```

## merge and subset data, and load coldata
```{r}

allCounts <- counts %>% purrr::reduce(left_join, by = "id") %>% na.omit()

coldata <- read.table(file = "/local/workdir/users/acv46/EC_PROSeq/proseq2.0/out3/coldata",
                      header = T,
                      sep = "\t")

#order of rownames must match order of countData columns
coldata$sample <- c(bam_list$filenames)


```

## subset for rRNA data
```{r}
rRNA_counts <- allCounts[which(allCounts$id %in% rRNA$id),]
rRNA_counts$name <- rRNA$name[match(rRNA_counts$id, rRNA$id)]
rRNA_counts$type <- rRNA$product_name[match(rRNA_counts$id, rRNA$id)]
rRNA_counts <- rRNA_counts[,-1]

rRNA_counts$PC1 <- rRNA_counts$PC1 / sum(allCounts$PC1) * 10^2 #+0.001
rRNA_counts$PC2 <- rRNA_counts$PC2 / sum(allCounts$PC2) * 10^2 #+0.001
rRNA_counts$PC3 <- rRNA_counts$PC3 / sum(allCounts$PC3) * 10^2 #+0.001
rRNA_counts$PH1 <- rRNA_counts$PH1 / sum(allCounts$PH1) * 10^2 #+0.001
rRNA_counts$PH2 <- rRNA_counts$PH2 / sum(allCounts$PH2) * 10^2 #+0.001
rRNA_counts$PH3 <- rRNA_counts$PH3 / sum(allCounts$PH3) * 10^2 #+0.001
rRNA_counts$RCD1 <- rRNA_counts$RCD1 / sum(allCounts$RCD1) * 10^2 #+0.001
rRNA_counts$RCD2 <- rRNA_counts$RCD2 / sum(allCounts$RCD2) * 10^2 #+0.001
rRNA_counts$RHD1 <- rRNA_counts$RHD1 / sum(allCounts$RHD1) * 10^2 #+0.001
rRNA_counts$RHD2 <- rRNA_counts$RHD2 / sum(allCounts$RHD2) * 10^2 #+0.001
rRNA_counts$RCU1 <- rRNA_counts$RCU1 / sum(allCounts$RCU1) * 10^2 #+0.001
rRNA_counts$RCU2 <- rRNA_counts$RCU2 / sum(allCounts$RCU2) * 10^2 #+0.001
rRNA_counts$RHU1 <- rRNA_counts$RHU1 / sum(allCounts$RHU1) * 10^2 #+0.001
rRNA_counts$RHU2 <- rRNA_counts$RHU2 / sum(allCounts$RHU2) * 10^2 #+0.001

rRNA_counts <- pivot_longer(rRNA_counts, !c(name,type), names_to = "sample", values_to = "count")

get_condition <- function(x) {
  
  # x is a row in the rRNA_counts dataframe
  
  coldata$condition[which(coldata$sample == x[3])]
  
}

rRNA_counts$condition <- apply(X = rRNA_counts, MARGIN = 1, FUN = get_condition) %>% purrr::as_vector()
rRNA_counts_simp <- rRNA_counts[,c(2,3,4,5)] %>% dplyr::group_by(type,condition,sample) %>% summarise(sum = sum(count))

rRNA_counts_simp$condition <- factor(rRNA_counts_simp$condition, levels = c("PC","PH","RCD","RHD","RCU","RHU"))

#part1 <- rRNA_counts_simp[grep("^P", rRNA_counts_simp$condition),]
#part2 <- rRNA_counts_simp[grep("R*D$", rRNA_counts_simp$condition),]
#part3 <- rRNA_counts_simp[grep("R*U$", rRNA_counts_simp$condition),]

#rRNA_counts_simp <- rbind(part1, part2, part3)

```

### summary numbers for text
```{r}
# segregate by treatment
rRNA_counts %>%
  group_by(sample) %>%
  mutate(grpsum = sum(count)) %>%
  ungroup() %>%
  select(sample,grpsum,condition) %>%
  unique() %>%
  group_by(condition) %>%
  mutate(mean = mean(grpsum)) %>%
  mutate(sd = stats::sd(grpsum)) %>%
  select(condition, mean, sd) %>%
  unique()

# combine treatments
rRNA_counts %>%
  group_by(sample) %>%
  mutate(grpsum = sum(count)) %>%
  ungroup() %>%
  mutate(type = ifelse(grepl("P",condition), "PRO-seq",
                       ifelse(grepl("D", sample), "RNAseqD", "RNAseqU"))) %>%
  select(type, grpsum) %>%
  group_by(type) %>%
  mutate(mean = mean(grpsum)) %>%
  mutate(sd = stats::sd(grpsum)) %>%
  ungroup() %>%
  select(type, mean, sd) %>%
  unique()
```

## plot composite
```{r}
#library(ggplot2)
#library(scales)

pal <- c("#E69F00FF","#D55E00FF","#56B4E9FF","#0072B2FF","#9A969C","#48454A")

plain <- function(x,...) {
  format(x, ..., scientific = FALSE, drop0trailing = TRUE)
}

rc <- ggplot(data = rRNA_counts_simp,
             mapping = aes(x = type,
                           fill = condition,
                           y = sum)) +
  geom_dotplot(binaxis = "y",
               stackdir = "center",
               position = "dodge",
               dotsize = 0.75) +
  # scale_y_continuous(breaks = seq(0,100,10),
  #                    labels = seq(0,100,10)) +
  scale_y_log10(labels = plain,
                breaks = c(1 %o% 10^(-3:2))) +
  theme_classic() +
  theme(axis.text.x = element_text(size = 12),
        axis.text.y = element_text(size = 12)) +
  scale_x_discrete(labels = c("16S rRNA","23S rRNA","5S rRNA")) +
  scale_fill_manual(values = pal, name = "Condition") +
  #scale_color_manual(values = pal, name = "Condition") +
  ylab("Library Percent") +
  xlab("") +
  geom_vline(xintercept = 1.5) +
  geom_vline(xintercept = 2.5) +
  geom_vline(xintercept = 3.5)

rc <- rc + annotation_logticks(sides = "l") 

rc
```

### ggsave
```{r}
#library(svglite)
setwd("/workdir/users/acv46/EC_PROSeq/figures/rRNA")
ggsave(filename = "rRNA_percent_v4_blackOutline.svg",
       plot = rc,
       device = "svg",
       dpi = 600,
       width = 5,
       height = 3.5)
ggsave(filename = "rRNA_percent_v4_blackOutline.pdf",
       plot = rc,
       device = "pdf",
       dpi = 600,
       width = 5,
       height = 3.5,
       useDingbats = F)

```

# tRNA abundance, enricment, and processing
## read in coverage data (from "Pause Sites, take 2")
```{r}
coverage <- read_csv("/workdir/users/acv46/EC_PROSeq/pileup/iter_correct/all_coverage_formatted.txt")
# flip orintation of plus and minus, just for fun
# 3' and 5' ends must also be flipped for correct orientation
# get normalized values by grouping lib types
## normalize based on full coverage values
coverage <- coverage %>% mutate(strand1 = ifelse(strand == "plus", "minus", "plus")) %>%
  select(-strand) %>% dplyr::rename(strand = strand1) %>%
  mutate(end1 = ifelse(end == "3", "5", ifelse(end == "5", "3", "full"))) %>%
  select(-end) %>% dplyr::rename(end = end1)
  # group_by(type, treatment, end) %>%
  # mutate(norm = (value / sum(value)) * 10^6) %>%
  # ungroup()

cp_sum <- coverage %>% filter(end == "full" & treatment == "control" & type == "PRO-seq") %>% select(value) %>% sum()
hp_sum <- coverage %>% filter(end == "full" & treatment == "heat shock" & type == "PRO-seq") %>% select(value) %>% sum()
cr_sum <- coverage %>% filter(end == "full" & treatment == "control" & type == "RNA-seq") %>% select(value) %>% sum()
hr_sum <- coverage %>% filter(end == "full" & treatment == "heat shock" & type == "RNA-seq") %>% select(value) %>% sum()

coverage <- coverage %>% mutate(norm = ifelse(treatment == "control" & type == "PRO-seq", (value / cp_sum) * 10^6,
                                              ifelse(treatment == "heat shock" & type == "PRO-seq", (value / hp_sum) * 10^6,
                                                     ifelse(treatment == "control" & type == "RNA-seq", (value / cr_sum) * 10^6,
                                                            ifelse(treatment == "heat shock" & type == "RNA-seq", (value / hr_sum) * 10^6, NA)
                                                            )
                                                     )
                                              )
                                )

covdat <- coverage %>%
  mutate(value = ifelse(strand == "minus", -value, value)) %>%
  mutate(norm = ifelse(strand == "minus", -norm, norm)) %>%
  mutate(type = ifelse(type == "RNA-seq", "RNAseq", type)) %>%
  mutate(lab = ifelse(end == "full",
                      paste0(type," ",end),
                      paste0(type," ",end,"' end")))
```

## read in RegulonDB annotation and subset for tRNAs
```{r}
require(regutools)
require(dplyr)
## Build a regulondb object
## stores database at /home/acv46/.cache/AnnotationHub
e_coli_regulondb_10.9 <- regulondb(database_conn = connect_database(),
                              organism = "E.coli",
                              database_version = "10.9",
                              genome_version = "NC_000913.3")

#list_datasets(e_coli_regulondb)
#list_attributes(e_coli_regulondb, dataset = "PROMOTER")

ec_tRNAs <- get_dataset(e_coli_regulondb_10.9, dataset = "DNA_OBJECTS") %>%
  as.tibble() %>%
  filter(grepl("tRNA-.*\\(", description))
```

## plot coverage
```{r}
require(ggplot2)
require(staplr)

setwd("/workdir/users/acv46/EC_PROSeq/figures/tRNA")
oldfiles <- dir(path = ".", pattern = "*_partial.pdf")
file.remove(file.path(".", oldfiles))

apply(X = ec_tRNAs, MARGIN = 1, function(tRNA) {
  
  tL <- as.numeric(tRNA[4])
  tR <- as.numeric(tRNA[5])
  buffer <- 30
  xmin <- ifelse(tL - buffer > 0, tL - buffer, 1)
  xmax <- ifelse(tR + buffer <= max(covdat$position), tR + buffer, max(covdat$position))
  cov <- covdat %>% filter(position >= xmin & position <= xmax) %>%
    select(-c(type,end,norm))
  ymax <- max(abs(cov$value))
  str <- ifelse(tRNA[6] == "forward", -1, 1)
  
  b1 <- round(xmin,nchar(xmin - 4))
  b2 <- round(xmax,nchar(xmin - 4))
  breaks <- seq(from = b1, to = b2, by = (b2 - b1) / 4)
  breaks <- breaks[which(breaks >= xmin & breaks <= xmax)]
  
  # https://livebook.manning.com/book/exploring-data-with-r/chapter-10/v-5/38
  
  pt <- ggplot(data = cov) +
    geom_area(mapping  = aes(x = position, y = value, linetype = strand),
              fill = "red") +
    geom_text(mapping = aes(x = xmin,
                            y = str * 0.75 * ymax,
                            label = lab),
             size = 3,
             check_overlap = TRUE,
             hjust = 0) +
    scale_linetype_manual(values = c(1,1)) +
    facet_grid(lab ~ treatment) + 
    scale_x_continuous(breaks = breaks,
                       labels = sprintf("%.2f", (breaks / 1000))) +
    coord_cartesian(ylim = c(-ymax - (0.05 * ymax), ymax + (0.05 * ymax))) +
    theme_classic() + 
    theme(legend.position = "none",
          strip.background.y = element_blank(),
          strip.text.y = element_blank()) +
    geom_hline(yintercept = 0,
               color = "black") +
    xlab("position (kb)") +
    ylab("depth") +
    annotate("segment",
             x = ifelse(tRNA[6] == "forward", tL, tR),
             xend = ifelse(tRNA[6] == "forward", tR, tL),
             y = str * ymax * 0.3,
             yend = str * ymax * 0.3,
             size = 1,
             arrow = arrow(type = "closed", length = unit(0.05, "npc")),
             color = "black",
             alpha = 0.5) +
    ggtitle(paste0(tRNA[3],", ",tRNA[7]))
  
  print(pt)
  
  ggsave(filename = paste(tRNA[1], "partial.pdf", sep = "_"),
         plot = pt,
         device = cairo_pdf,
         dpi = 400,
         width = 6,
         height = 4)
  
})


pdflist <- list.files(path = ".", pattern = "partial.pdf")
staple_pdf(input_files = pdflist,
           output_filepath = file.path(".", "ec_tRNA_merged_v2.pdf"))
do.call(file.remove, list(pdflist))
```

# Plot DNA objects

## get fresh regulondb object with appropriate organism name
```{r}
e_coli_regulondb_chr <- regulondb(database_conn = connect_database(),
                              organism = "chr",
                              database_version = "10.9",
                              genome_version = "NC_000913.3")
plot_dna_objects(e_coli_regulondb_chr,
                 grange = GRanges("chr",
                                                        IRanges(457000,462000)),
                 elements = c("gene", "promoter"))
```


# Pearson + Spearman correlation

## load libraries
```{r}
# BRGenomics functions seems to be broken in R 4.0.0
# fresh Biocnductor install in 4.1.2

if (!requireNamespace("BiocManager", quietly=TRUE))
    install.packages("BiocManager")
BiocManager::install("BRGenomics")
BiocManager::install("regutools")
install.packages("tidyverse")
library(BRGenomics)
library(regutools)
library(tidyverse)
library(parallel)
library(data.table)
```

## function to create basepair-resolution (BR) objects from bam alignments
```{r}
# For PRO-seq data -- 3p position of alignments, reverse complement
makeBRobj_3p <- function(path){
  
  import_bam(file = path, 
             mapq = 30, 
             revcomp = F, 
             shift = -1L, 
             trim.to = "3p", 
             paired_end = T,
             ignore.strand = F)

}

# For RNA-seq data -- no trimming
makeBRobj <- function(path){
  
  import_bam(file = path, 
             mapq = 30, 
             revcomp = T, 
             shift = 0, 
             #trim.to = "3p",
             paired_end = T,
             ignore.strand = F)

}
```

## apply BR object function
```{r}
setwd(dir = "/workdir/users/acv46/EC_PROSeq/proseq2.0/out3/bams/sort/")

PC1 <- makeBRobj_3p("PC1_dedup_QC_end.sort.bam")
PC2 <- makeBRobj_3p("PC2_dedup_QC_end.sort.bam")
PC3 <- makeBRobj_3p("PC3_dedup_QC_end.sort.bam")
PH1 <- makeBRobj_3p("PH1_dedup_QC_end.sort.bam")
PH2 <- makeBRobj_3p("PH2_dedup_QC_end.sort.bam")
PH3 <- makeBRobj_3p("PH3_dedup_QC_end.sort.bam")

RCD1 <- makeBRobj("RCD1_QC_end.sort.bam")
RCD2 <- makeBRobj("RCD2_QC_end.sort.bam")
RHD1 <- makeBRobj("RHD1_QC_end.sort.bam")
RHD2 <- makeBRobj("RHD2_QC_end.sort.bam")

RCU1 <- makeBRobj("RCU1_QC_end.sort.bam")
RCU2 <- makeBRobj("RCU2_QC_end.sort.bam")
RHU1 <- makeBRobj("RHU1_QC_end.sort.bam")
RHU2 <- makeBRobj("RHU2_QC_end.sort.bam")

```

## Combine BR objects into a named list
```{r}

PS.list <- list(PC1,PC2,PC3,PH1,PH2,PH3,
                RCD1,RCD2,RHD1,RHD2,
                RCU1,RCU2,RHU1,RHU2)

names(PS.list) <- as.character(expression(PC1,PC2,PC3,PH1,PH2,PH3,
                                          RCD1,RCD2,RHD1,RHD2,
                                          RCU1,RCU2,RHU1,RHU2))
```

## Merge replicates -- must follow ID_1, ID_2, etc. scheme
```{r}
mergedReps <- mergeReplicates(PS.list, 
                              makeBRG = T, 
                              ncores = round(detectCores()/10))
```

## Function to generate region counts
```{r}
#For All Genes
counts_region <- function(dataset_gr,
                     features_list,
                     start,
                     end){
  
  getCountsByRegions(dataset.gr = dataset_gr, 
                     regions.gr = genebodies(genelist = features_list,
                                             start = start,
                                             end = end),
                     field = "score",
                     region_names = features_list$name,
                     ncores = round(detectCores()/10))

}

```

## Full Gene Bodies, sense and antisense
```{r}
require(regutools)
require(dplyr)

setwd(dir = "/workdir/users/acv46/EC_PROSeq/compare/BRgenomics/")

## Old, from gff
# featurelist_sense <- import.gff3(con = "Escherichia_coli_str_k_12_substr_mg1655.ASM584v2.46.gff3",
#                                 colnames = c("Name","gene_id"),
#                                 feature.type = "gene")
# 
# featurelist_antisense <- import.gff3(con = "ASM584v2_full_antisense.gff3",
#                                 colnames = c("Name","gene_id"),
#                                 feature.type = "gene")

# Strange note -- having a sequence named "Chromosome" in the gff3 breaks this script
# sed -i 's/Chromosome/NC_000913.3/g' ASM584v2_genes_edit.gff3

## New, granges object from regulondb
featurelist_sense <- get_dataset(regulondb(database_conn = connect_database(),
                                           organism = "NC_000913.3",
                                           database_version = "10.9",
                                           genome_version = "NC_000913.3"),
                      dataset = "GENE",
                      attributes = c("name", "posleft", "posright", "strand", "product_type")) %>%
  as_tibble() %>%
  mutate(product_type = ifelse(is.na(product_type), "gene", product_type)) %>%
  mutate(strand = ifelse(strand == "forward", "+", "-")) %>%
  drop_na() %>%
  mutate(seqnames = "NC_000913.3") %>%
  GenomicRanges::makeGRangesFromDataFrame(keep.extra.columns = TRUE,
                                          ignore.strand = FALSE,
                                          seqinfo = NULL,
                                          seqnames.field = "seqnames",
                                          start.field = "posleft",
                                          end.field = "posright",
                                          strand.field = "strand",
                                          starts.in.df.are.0based = FALSE)

counts_sense <- counts_region(dataset_gr = mergedReps,
                        features_list = featurelist_sense,
                        start = 0,
                        end = 0)

# Append gene name and length to each row
# Normalize to region length and experiment total counts
# Add 1 to every field to avoid Inf and NAN errors

### Normalization - Sense PRO-seq v. Sense RNA-seq ###

counts_sense$gene <- featurelist_sense$name
counts_sense$kb <- width(featurelist_sense) / 1000
counts_sense$norm_p <- (((counts_sense$HP) / sum(counts_sense$HP)) / ((counts_sense$CP)/ sum(counts_sense$CP))) / counts_sense$kb
counts_sense$norm_r <- (((counts_sense$HR) / sum(counts_sense$HR)) / ((counts_sense$CR)/ sum(counts_sense$CR))) / counts_sense$kb

# counts_antisense$gene <- featurelist_antisense$Name
# counts_antisense$kb <- width(featurelist_antisense) / 1000
# counts_antisense$norm_p <- (((counts_antisense$HP) / sum(counts_antisense$HP)) / ((counts_antisense$CP)/ sum(counts_antisense$CP))) / counts_antisense$kb
# counts_antisense$norm_r <- (((counts_antisense$HR) / sum(counts_antisense$HR)) / ((counts_antisense$CR)/ sum(counts_antisense$CR))) / counts_antisense$kb

# Reorder to plot heat shock genes last

HSindex <- as.data.frame(read.table("genes_4140_ordered.txt"))

sense_HS <- counts_sense[match(HSindex$V1, counts_sense$gene),]
# antisense_HS <- counts_antisense[match(HSindex$V1, counts_antisense$gene),]

merged_HS <- sense_HS
merged_HS$CP_a <- antisense_HS$CP
merged_HS$HP_a <- antisense_HS$HP
merged_HS$CR_a <- antisense_HS$CR
merged_HS$HR_a <- antisense_HS$HR
merged_HS$norm_p_a <- antisense_HS$norm_p
merged_HS$norm_r_a <- antisense_HS$norm_r

# rpkm calcs

merged_HS$CP_RPKM <- (merged_HS$CP / merged_HS$kb) / (length(mergedReps$CP) / 10^6)
merged_HS$HP_RPKM <- (merged_HS$HP / merged_HS$kb) / (length(mergedReps$HP) / 10^6)
merged_HS$CR_RPKM <- (merged_HS$CR / merged_HS$kb) / (length(mergedReps$CR) / 10^6)
merged_HS$HR_RPKM <- (merged_HS$HR / merged_HS$kb) / (length(mergedReps$HR) / 10^6)

merged_HS$CP_RPKM_a <- (merged_HS$CP_a / merged_HS$kb) / (length(mergedReps$CP) / 10^6)
merged_HS$HP_RPKM_a <- (merged_HS$HP_a / merged_HS$kb) / (length(mergedReps$HP) / 10^6)
merged_HS$CR_RPKM_a <- (merged_HS$CR_a / merged_HS$kb) / (length(mergedReps$CR) / 10^6)
merged_HS$HR_RPKM_a <- (merged_HS$HR_a / merged_HS$kb) / (length(mergedReps$HR) / 10^6)

HSlabs.dat <- as.data.frame(read.table("HSgenes_63good.txt"))
HSlabs <- HSlabs.dat[[1]]

key.col <- rep('other gene', nrow(merged_HS))
key.col[which(merged_HS$gene %in% HSlabs)] <- 'heat shock gene'

merged_HS$lab <- key.col

merged_HSonly <- merged_HS[which(merged_HS$lab == 'heat shock gene'),]
merged_noHS <- merged_HS[which(merged_HS$lab == 'other gene'),]

# https://stackoverflow.com/questions/26218002/r-manually-set-shape-by-factor

# Remove inf and NaN rows for spearman rank correlation analysis

sense_finite <- merged_HS[is.finite(merged_HS$norm_p) & is.finite(merged_HS$norm_r), ]
antisense_finite <- merged_HS[is.finite(merged_HS$norm_p_a) & is.finite(merged_HS$norm_r_a), ]
merged_finite <- merged_HS[is.finite(merged_HS$norm_p) & is.finite(merged_HS$norm_r) 
                           & is.finite(merged_HS$norm_p_a) & is.finite(merged_HS$norm_r_a), ]
```

### move cache, or regulondb won't work
```{r}
# https://bioconductor.org/packages/devel/bioc/vignettes/AnnotationHub/inst/doc/TroubleshootingTheCache.html#default-caching-location-update
# https://www.bioconductor.org/packages/devel/bioc/vignettes/BiocFileCache/inst/doc/BiocFileCache.html#default-caching-location-update
moveFiles<-function(package){
        olddir <- path.expand(rappdirs::user_cache_dir(appname=package))
        newdir <- tools::R_user_dir(package, which="cache")
        dir.create(path=newdir, recursive=TRUE)
        files <- list.files(olddir, full.names =TRUE)
        moveres <- vapply(files,
        FUN=function(fl){
          filename = basename(fl)
          newname = file.path(newdir, filename)
          file.rename(fl, newname)
        },
        FUN.VALUE = logical(1))
        if(all(moveres)) unlink(olddir, recursive=TRUE)
    }


    package="AnnotationHub"
    moveFiles(package)
    package="BiocFileCache"
    moveFiles(package)
```

## import regulon DB features as gff
```{r}
genes <- regulondb(database_conn = connect_database(),
                              organism = "NC_000913.3",
                              database_version = "10.9",
                              genome_version = "NC_000913.3") %>%
  get_dataset(., dataset = "GENE", attributes = c("id","posleft","posright","strand","name","go_index_bp","bnumber","product_type")) %>%
  convert_to_granges()
```

## function to turn list of granges into counts data
```{r}
# copied from above
featurelist_sense <- get_dataset(regulondb(database_conn = connect_database(),
                                           organism = "NC_000913.3",
                                           database_version = "10.9",
                                           genome_version = "NC_000913.3"),
                      dataset = "GENE",
                      attributes = c("name", "posleft", "posright", "strand", "product_type")) %>%
  as_tibble() %>%
  mutate(product_type = ifelse(is.na(product_type), "gene", product_type)) %>%
  mutate(strand = ifelse(strand == "forward", "+", "-")) %>%
  drop_na() %>%
  mutate(seqnames = "NC_000913.3") %>%
  GenomicRanges::makeGRangesFromDataFrame(keep.extra.columns = TRUE,
                                          ignore.strand = FALSE,
                                          seqinfo = NULL,
                                          seqnames.field = "seqnames",
                                          start.field = "posleft",
                                          end.field = "posright",
                                          strand.field = "strand",
                                          starts.in.df.are.0based = FALSE)

# get counts
counts_dat <- data.frame()
FLAG <- 0

for (i in seq_along(PS.list)){
  
  if (FLAG == 0){
    
    FLAG <- 1
    newrep <- counts_region(dataset_gr = PS.list[i],
                            features_list = featurelist_sense,
                            start = 0,
                            end = 0)
    
    counts_dat <<- data.frame(newrep)

  } 
  
  else{
    
    newrep <- counts_region(dataset_gr = PS.list[i],
                            features_list = featurelist_sense,
                            start = 0,
                            end = 0)
    
    counts_dat <<- cbind(counts_dat, newrep) 
    
  }
}




```

## convert counts to matrix and plot correlation -- heat map output
```{r}
require(stats)
#require(ggcorrplot)

# remove all rows where any replicate count equals zero
nozero <- apply(counts_dat, 1, function(row) all(row !=0 ))

width <- width(featurelist_sense)

zeros <- T
#if (zeros)
counts_mat_nozero <- as.matrix(counts_dat[nozero,])
counts_mat_withzero <- as.matrix(counts_dat)
counts_mat_zeros_width <- cbind(counts_mat_withzero, width)

```

### old stuff
```{r}
# calculate correlation matrix
cormat_nozero <- cor(counts_mat_withzero, method = "pearson")
#p.nozero <- cor_pmat(counts_mat_withzero)

reorder <- as.character(expression(PC1,PC2,PC3,RCD1,RCD2,PH1,PH2,PH3,RHD1,RHD2))
cormat_nozero <- cormat_nozero[reorder,reorder]

cordt <- as.data.table(cormat_nozero, keep.rownames = 'col_name')
cordt <- melt(cordt, id.vars = 'col_name', variable.name = 'row_name')

# convert to factor so that rows and columns have the same order as the data
cordt[, row_name := factor(row_name, levels = rev(rownames(cormat_nozero)))]
cordt[, col_name := factor(col_name, levels = rownames(cormat_nozero))]

# set diagonal and the top-right half of the matrix to 0 so that those cells appears white
cordt[ncol(cormat_nozero) - as.integer(row_name) < as.integer(col_name), value := 0]
# remove the last column and the bottom row (where left cells are self correlations only)
cordt <- cordt[as.integer(row_name) < ncol(cormat_nozero) &
        as.integer(col_name) < ncol(cormat_nozero)]

# reorder columns and remove undepleted RNA-seq libraries
# c("PC1","PC2","PC3","PH1","PH2","PH3","RCD1","RCD2","RHD1","RHD2","RCU1","RCU2","RHU1","RHU2")
#reorder <- c("RHD2","RHD1","PH3","PH2","PH1","RCD2","RCD1","PC3","PC2","PC1")
#cormat_nozero <- cormat_nozero[reorder,reorder]

#cormat_withzero <- cor(counts_mat_withzero, method = "pearson")
#p.withzero <- cor_pmat(counts_mat_withzero)

legend.lab <- expression(paste("Pearson's ", italic("r")))

# plot  
# ggcorrplot(cormat_nozero,
#            method = "square",
#            type = "lower",
#            show.diag = T,
#            lab = T,
#            lab_size = 3,
#            hc.order = F,
#            ggtheme = ggplot2::theme_classic(),
#            title = "Correlations of libraries, all genes, raw counts, zero-depleted") +
#   scale_fill_gradient2(low = "white", high = "red", breaks=c(0, 1), limit=c(0, 1)) +
#   labs(fill = legend.lab)

pc <- ggplot(subset(cordt, value != 0), aes(x = col_name, y = row_name, fill = value)) +
  geom_tile(color = "black") +
  coord_equal() +
  geom_text(aes(label = round(value, 2))) +
  scale_fill_gradient2(low = 'white', high = 'red') +
  labs(x = NULL, y = NULL, fill = legend.lab) +
  theme_classic()
pc
```

### ggsave
```{r}
#library(svglite)
setwd("/workdir/users/acv46/EC_PROSeq/figures/correlation")
ggsave(filename = "pearson_corr_red_noU.svg",
       plot = pc,
       device = "svg",
       dpi = 600,
       width = 5,
       height = 4.5)
ggsave(filename = "pearson_corr_red_noU.pdf",
       plot = pc,
       device = cairo_pdf,
       dpi = 600,
       width = 5,
       height = 4.5)
```

## RNA stability
```{r}
# analysis based on https://www.biorxiv.org/content/10.1101/690644v2.full
# counts_sense generated from section "Full Gene Bodies, sense and antisense"

# remove rows containing zero counts for any merged dataset
csn <- counts_sense
csn[csn == 0] <- NA
csn <- na.omit(csn)

#
csn$PRO_c_TPM <- (csn$CP / sum(csn$CP)) * 10^6
csn$RNA_c_TPM <- (csn$CR / sum(csn$CR)) * 10^6
csn$PRO_h_TPM <- (csn$HP/ sum(csn$HP)) * 10^6
csn$RNA_h_TPM <- (csn$HR / sum(csn$HR)) * 10^6

# calculate half life for gene transcripts 
csn$HL_c <- (csn$CR / sum(csn$CR)) / (csn$CP / sum(csn$CP))
csn$HL_h <- (csn$HR / sum(csn$HR)) / (csn$HP / sum(csn$HP))

csn$delta_RNA <- abs(csn$HR - csn$CR) / sum(csn$HR + csn$CR)
csn$delta_PRO <- abs(csn$HP - csn$CP) / sum(csn$HP + csn$CP)

csn$HL_delta <- csn$HL_h / csn$HL_c
csn$delta_proportion <- (csn$CP + csn$HP) / sum(csn$CP + csn$HP) 
#csn$Zpro <- (abs(csn$CP - csn$HP) - mean(abs(csn$CP - csn$HP))) / sd(abs(csn$CP - csn$HP))

HSlabs.dat <- as.data.frame(read.table("HSgenes_63good.txt"))
HSlabs <- HSlabs.dat[[1]]

key.col <- rep('other gene', nrow(csn))
key.col[which(csn$gene %in% HSlabs)] <- 'heat shock gene'

csn$lab <- key.col

#merged_HSonly <- merged_HS[which(merged_HS$lab == 'heat shock gene'),]
#merged_noHS <- merged_HS[which(merged_HS$lab == 'other gene'),]
```

```{r}
p1.spearman <- cor.test(x = csn$PRO_h_TPM,
                        y = csn$RNA_h_TPM,
                        method = "spearman",
                        conf.level = 0.95)

p1 <- ggplot(csn, aes(x = log10(PRO_h_TPM), y = log10(RNA_h_TPM))) +
        geom_point() + 
        #geom_hline(yintercept = 0.001, color = "goldenrod") +
        #geom_vline(xintercept = 1, color = "goldenrod") +
        theme_classic() +
        ggtitle("All nonzero genes, Heat Shock") +
        annotate("text",
                 label = paste("ρ =", round(p1.spearman$estimate, digits = 4), "\n", paste(nrow(csn)), "genes"), 
                  x = 0.5,
                  y = 3.5) +
        geom_smooth(method=lm, 
                    se=TRUE, 
                    fullrange=TRUE) +
        theme(plot.margin = margin(1,3,1,3, "cm"))
  
p1
```

## HS signal over control
```{r}
# PLOT

pal <- wes_palette(name = "Zissou1",
                   type = "continuous")

p1 <- ggplot(data = merged_noHS) + 
  #Plot non-HS points first
  geom_point(mapping = aes(x = log10(norm_p_a),
                           y = log10(norm_r_a),
                           colour = abs(log10(norm_p_a/norm_r_a))),
             size = 2) +
  labs(color='log10 enrichment') +
  #Plot HS points next
  geom_point(data = merged_HSonly,
             mapping = aes(x = log10(norm_r_a),
                           y = log10(norm_p_a)),
             size = 2,
             colour = "black") +
  geom_abline(slope = 1, intercept = 0, color = "black", alpha = 0.75) +
  #Plot smoothed relationship for finite data (no NaN or Inf)
  #geom_smooth(data = merged_finite,
  #            mapping = aes(x = log10(norm_r),
  #                         y = log10(norm_p)),
  #            method=lm, 
  #            se=TRUE, 
  #            fullrange=TRUE) +
  geom_label_repel(data = merged_HS,
                   aes(label = ifelse(abs(log10(norm_p_a/norm_r_a))>1.5 & abs(log10(norm_p_a/norm_r_a))<3,
                                      as.character(gene),
                                      ''),
                       x = log10(norm_r_a),
                       y = log10(norm_p_a)),
                   box.padding   = 0.5, 
                   point.padding = 0.25,
                   segment.color = 'grey50',
                   size = 2.5) +
  scale_colour_gradientn(colours = pal) +
  #geom_vline(xintercept = 0, color = "royalblue") +
  #geom_hline(yintercept = 0, color = "royalblue") +
  #geom_abline(slope = log10(2), intercept = log10(1), color = "red") +
  #geom_abline(slope = log10(2), intercept = -log10(1), color = "red") +
  theme_classic() +
  xlim(-2.5,3.5) +
  ylim(-2.5,3.5) +
  labs(title = "", 
       y = "PRO-seq, norm. log10(Heat Shock / Control)", 
       x = "RNA-seq, norm. log10(Heat Shock / Control)") +
  ggtitle("PRO-seq vs. RNAseq, gene bodies, sense strand") +
  annotate("text",
           label = "Spearman ρ = 0.7770451 \n p < 2.2e-16", 
            x = -1.4,
            y = 3)
  
p1

p1.spearman <- cor.test(x = merged_finite$norm_r,
                        y = merged_finite$norm_p,
                        method = "spearman",
                        conf.level = 0.95)

p1.pearson <- cor.test(x = merged_finite$norm_r,
                        y = merged_finite$norm_p,
                        method = "pearson",
                        conf.level = 0.95)
```

## log-log replicate plots
```{r}
require(ggplot2)
require(tidyr)
require(dplyr)
require(stats)
require(ggpubr)

# uses counts_mat_withzero object from correlation plot above

plotdat <- counts_mat_zeros_width %>%
  as_tibble() %>% 
  mutate(index = row.names(.)) %>% 
  #mutate_at(vars(-c(index, width)), funs(10^6 * ((. + 1) / sum(.))))
  mutate_at(vars(-c(index, width)), funs(10^6 * (((.) / (width / 10^3)) / sum(.))))
  #pivot_longer(!index, names_to = "lib", values_to = "value")
  
loglog <- function(lib1, lib2, color, spearman, pearson) {

  pc <- ggplot(data = plotdat,
               mapping = aes(x = log10(lib1), y = log10(lib2))) +
    geom_point(size = 1.5,
               alpha = 0.5,
               color = color) +
    geom_label(x = 0.25, y = 4.5, size = 3, label.size = NA, 
               label = paste0("ρ = ", round(spearman,3),
                              "\n", "r = ", round(pearson,3)),
               hjust = 0) +
    theme_classic() +
    theme(axis.title = element_blank(),
          axis.text = element_text(size = 14)) +
    xlim(0,5) +
    ylim(0,5) +
    geom_abline(slope = 1, color = "black", intercept = 0)
  
  print(pc)

}

#'#e41a1c','#377eb8','#4daf4a','#984ea3','#ff7f00','#ffff33'

#"#E69F00" - PC
#"#D55E00" - PH
#"#7acfff" - RC
#"#0072B2"- RH

spearman <- cor(counts_mat_zeros_width, method = "spearman")
pearson <- cor(counts_mat_zeros_width, method = "pearson")

a <- loglog(plotdat$PC1, plotdat$PC2, "#E69F00", spearman["PC1","PC2"], pearson["PC1","PC2"])
b <- loglog(plotdat$PC1, plotdat$PC3, "#E69F00", spearman["PC1","PC3"], pearson["PC1","PC3"])
c <- loglog(plotdat$PC2, plotdat$PC3, "#E69F00", spearman["PC2","PC3"], pearson["PC2","PC3"])
d <- loglog(plotdat$PH1, plotdat$PH2, "#D55E00", spearman["PH1","PH2"], pearson["PH1","PH2"])
e <- loglog(plotdat$PH1, plotdat$PH3, "#D55E00", spearman["PH1","PH3"], pearson["PH1","PH3"])
f <- loglog(plotdat$PH2, plotdat$PH3, "#D55E00", spearman["PH2","PH3"], pearson["PH2","PH3"])
g <- loglog(plotdat$RCD1, plotdat$RCD2, "#7acfff", spearman["RCD1","RCD2"], pearson["RCD1","RCD2"])
h <- loglog(plotdat$RHD1, plotdat$RHD2, "#0072B2", spearman["RHD1","RHD2"], pearson["RHD1","RHD2"])

```

## log log RNAseq vs PRO-seq
```{r}
require(tidyverse)
require(stats)
require(regutools)

plotdat2 <- counts_mat_zeros_width %>%
  as_tibble() %>%
  mutate(PC = PC1 + PC2 + PC3) %>%
  mutate(PH = PH1 + PH2 + PH3) %>%
  mutate(RC = RCD1 + RCD2) %>%
  mutate(RH = RHD1 + RHD2) %>%
  mutate(index = row.names(.)) %>% 
  mutate(name = featurelist_sense$name) %>%
  mutate(type = featurelist_sense$product_type) %>%
  select(PC,PH,RC,RH,width,index,name,type) %>%
  mutate_at(vars(-c(index, width, name, type)),
            funs(10^6 * (((.) / (width / 10^3)) / sum(.)))) %>%
  arrange(type) # makes all ncRNA plotted last

toCorr <- counts_mat_zeros_width %>%
  as_tibble() %>%
  mutate(PC = PC1 + PC2 + PC3) %>%
  mutate(PH = PH1 + PH2 + PH3) %>%
  mutate(RC = RCD1 + RCD2) %>%
  mutate(RH = RHD1 + RHD2) %>%
  select(PC,PH,RC,RH) %>%
  as.matrix()

loglog2 <- function(lib1, lib2, color, spearman, pearson) {

  pc <- ggplot(data = plotdat2,
               mapping = aes(x = log10(lib1),
                             y = log10(lib2))) +
    geom_point(mapping = aes(color = type),
               size = 1.5,
               alpha = 1) +
    scale_color_manual(values = c("#cccccc","#faa80f","#ff0022","#6622cc")) +
    geom_label(x = 0.25, y = 4.5, size = 3, label.size = NA, 
               label = paste0("ρ = ", round(spearman,3),
                              "\n", "r = ", round(pearson,3)),
               hjust = 0) +
    theme_classic() +
    xlab("PRO-seq log10(RPKM)") +
    ylab("RNAseq log10(RPKM)") +
    theme(axis.title = element_text(size = 14),
          axis.text = element_text(size = 14),
          legend.position = "none") +
    xlim(0,5) +
    ylim(0,5) +
    geom_abline(slope = 1, color = "black", intercept = 0)
  
  print(pc)

}

# palettes
# "808080","000000","ff0022","6622cc"
# #808080","#eca400","#ff4a1c","#5f0a87"
# "cccccc","faa80f","ff0022","6622cc"

spearman <- cor(toCorr, method = "spearman")
pearson <- cor(toCorr, method = "pearson")

pcrc <- loglog2(plotdat2$PC, plotdat2$RC, "#E69F00", spearman["PC","RC"], pearson["PC","RC"])
phrh <- loglog2(plotdat2$PH, plotdat2$RH, "#E69F00", spearman["PH","RH"], pearson["PH","RH"])
```

## barplot with plotdat2 data
```{r}
require(tidyverse)
require(ggpubr)
require(scales)

plotdat3 <- plotdat2 %>%
         pivot_longer(cols = c("PC","PH","RC","RH"),
                      names_to = "treatment") %>%
         filter(type != "gene" & type != "rRNA") %>%
  mutate(treatment = factor(treatment, levels = c("PC","RC","PH","RH")))

plain <- function(x,...) {
  format(x, ..., scientific = FALSE, drop0trailing = TRUE)
}

rbar <- ggplot(data = plotdat3,
       mapping = aes(x = treatment, y = value + 1)) +
  geom_boxplot(outlier.shape = NA) +
  geom_jitter(mapping = aes(color = type),
              width = 0.1,
              alpha = 0.5) +
  scale_color_manual(values = c("#ff0022","#6622cc")) +
  scale_y_log10(labels = function(x) format(x, scientific = TRUE),
                breaks = c(1 %o% 10^(0:6))) +
  facet_wrap(. ~ type) +
  theme_classic() +
  ylab("RPKM + 1") +
  xlab("") +
  theme(strip.background = element_blank(),
        strip.text.x = element_blank(),
        legend.position = "none") +
  stat_compare_means(comparisons = list(c("PC", "RC")), 
                     label = "p.format", method = "wilcox.test", paired = T, tip.length = 0) +
  stat_compare_means(comparisons = list(c("PH", "RH")), 
                     label = "p.format", method = "wilcox.test", paired = T, tip.length = 0)

rbar <- rbar + annotation_logticks(sides = "l") 


setwd("/workdir/users/acv46/EC_PROSeq/figures/correlation/")
ggsave(plot = rbar,
       filename = "barplot_log10_rpkm_RNAtype_v3.pdf",
       width = 3, height = 3, useDingbats = F)

```

### ggsave
```{r}
setwd("/workdir/users/acv46/EC_PROSeq/figures/correlation/")

ggsave_pngpdf <- function(plot,sample1,sample2) {

  # ggsave(filename = paste0(sample1, "v", sample2, "_loglogRPKM_v5.png"),
  #        plot = plot, width = 3, height = 3)
  ggsave(filename = paste0(sample1, "v", sample2, "_loglogRPKM_v1_nolegend.pdf"),
         plot = plot, width = 3, height = 3, useDingbats = F)

}

# ggsave_pngpdf(a, "PC1", "PC2")
# ggsave_pngpdf(b, "PC1", "PC3")
# ggsave_pngpdf(c, "PC2", "PC3")
# ggsave_pngpdf(d, "PH1", "PH2")
# ggsave_pngpdf(e, "PH1", "PH3")
# ggsave_pngpdf(f, "PH2", "PH3")
# ggsave_pngpdf(g, "RCD1", "RCD2")
# ggsave_pngpdf(h, "RHD1", "RHD2")

ggsave_pngpdf(pcrc, "PC", "RC")
ggsave_pngpdf(phrh, "PH", "RH")

```



# Pause sites, take 2
## read in coverage data, bedtools corrected
```{r}
library(tidyverse)
setwd("/workdir/users/acv46/EC_PROSeq")

# PRO-seq and RNA-seq coverage data (as read in above)
# use interation 2, see readme in file directory
coverage <- read_delim(file = "pileup/iter_correct/all_coverage.txt",
                       delim = "\t")

colnames(coverage) <- colnames(coverage) %>% gsub("merge_","",.) %>% gsub("q30_","",.)
coverage <- pivot_longer(coverage, -c(contig, position)) %>%
  select(-contig) %>% mutate(type = ifelse(grepl("P", name), "PRO-seq", "RNA-seq")) %>%
  mutate(end = ifelse(grepl("3p", name), "3", ifelse(grepl("5p", name), "5", "full"))) %>%
  mutate(treatment = ifelse(grepl("H", name), "heat shock", "control")) %>%
  mutate(strand = ifelse(grepl("plus", name), "plus", "minus")) %>% select(-name)

write_csv(coverage, "pileup/iter_correct/all_coverage_formatted.txt")
```

### read in coverage if already written
```{r}
coverage <- read_csv("/workdir/users/acv46/EC_PROSeq/pileup/iter_correct/all_coverage_formatted.txt")
# flip orintation of plus and minus, just for fun
# 3' and 5' ends must also be flipped for correct orientation
# orientation and end flippinf supported by tRNA mapping
# get normalized values by grouping lib types
## normalize based on full coverage values
coverage <- coverage %>% mutate(strand1 = ifelse(strand == "plus", "minus", "plus")) %>%
  select(-strand) %>% dplyr::rename(strand = strand1) %>%
  mutate(end1 = ifelse(end == "3", "5", ifelse(end == "5", "3", "full"))) %>%
  select(-end) %>% dplyr::rename(end = end1)
  # group_by(type, treatment, end) %>%
  # mutate(norm = (value / sum(value)) * 10^6) %>%
  # ungroup()

cp_sum <- coverage %>% filter(end == "3" & treatment == "control" & type == "PRO-seq") %>% select(value) %>% sum()
hp_sum <- coverage %>% filter(end == "3" & treatment == "heat shock" & type == "PRO-seq") %>% select(value) %>% sum()
cr_sum <- coverage %>% filter(end == "full" & treatment == "control" & type == "RNA-seq") %>% select(value) %>% sum()
hr_sum <- coverage %>% filter(end == "full" & treatment == "heat shock" & type == "RNA-seq") %>% select(value) %>% sum()

coverage <- coverage %>% mutate(norm = ifelse(treatment == "control" & type == "PRO-seq", (value / cp_sum) * 10^6,
                                              ifelse(treatment == "heat shock" & type == "PRO-seq", (value / hp_sum) * 10^6,
                                                     ifelse(treatment == "control" & type == "RNA-seq", (value / cr_sum) * 10^6,
                                                            ifelse(treatment == "heat shock" & type == "RNA-seq", (value / hr_sum) * 10^6, NA)
                                                            )
                                                     )
                                              )
                                )

pro_covdat <- coverage %>% filter(type == "PRO-seq") %>% filter(end %in% c("3","5"))
rm(coverage)
```

## read in fasta
```{r}
get_fasta <- function(file) {
  
  require(Biostrings)
  fasta <- readDNAStringSet(filepath = file,
                            format = "fasta")
  
  fasta
  
}

ec_fasta <- get_fasta("/workdir/users/acv46/EC_PROSeq/index/U00096.3/GCF_000005845.2_ASM584v2_genomic.fna")
```

## identify pause sites, filter by score, pull sequences
```{r}
# from Sun 2021 -- "ends of all uniquely mapped RNA reads (bottom lane) were determined and the read count for each 3′ end position was calculated and plotted (top lane). The genomic positions where 3’ end/3’ end median (51-bp window) read counts ratio (pause score) was ≥ 20 and read counts/10^6 reads was ≥ 10 satisfied our stringent definition for a pause site."

# main function to process each contig in the chosen bin set
get_motifs <- function(covdat, seqdat, end, range, mincov, minpause, context) {
  
  # INPUTS
  ## covdat is coverage data
  ## bindat is all metadata
  ## seqdat is genomic ranges object containing all sequence data
  ## gtf is a gtf annotation file
  ## end is either 3 or 5
  ## range is the context around a position to use in pause score calculation
  ## mincov is the minimum raw coverage value at a position to determine whether a pause score should be calculated
  ## minpause is the the minimum Z score for a position to call it as significantly paused
  ## context is the number of bases surrounding a significant peak
  
  require(tidyverse)
  require(stats)
  require(Biostrings)
  require(pbapply)
  
  # helper function to get pause site z score
  pause_score <- function(row, full, range, con_len){
    
    pos <- row[1] %>% as.numeric()
  
    # this code works with both circular and linear sequences
    fullrange <- sort(c(
      c(((pos - 1) - c(1:range)) %% con_len + 1),
      c(((pos - 1) + c(1:range)) %% con_len + 1)
      ))
    
    mean <- full %>%
      filter(position %in% fullrange) %>%
      select(norm) %>% abs() %>% 
      unlist() %>% mean()
  
    std <- full %>%
      filter(position %in% fullrange) %>%
      select(norm) %>% abs() %>% 
      unlist() %>% sd()
  
    # calculate z score for pause sites passing raw cov threshold
    zscore <- (abs(as.numeric(row[7])) - mean) / std
  
    list(zscore, as.numeric(row[1]))
  
  }
  
  con_cov <- covdat %>%
    filter(end == end)
  
  con_len <- max(con_cov$position) 
  index <- c((range + 1):(con_len - range - 1))
  
  # create separate datasets for plus and minus positions
  # filter for minimum absolute 
  plus_set <- con_cov %>%
    filter(strand == "plus" & abs(value) >= mincov & position %in% index)
  
  message(paste0("\n","> plus strand has ", nrow(plus_set), " hits over coverage threshold"))
  
  minus_set <- con_cov %>%
    filter(strand == "minus" & abs(value) >= mincov & position %in% index)
  
  message(paste0("\n","> minus strand has ", nrow(minus_set), " hits over coverage threshold"))
  
  cseq <- seqdat["NC_000913.3"][[1]]
  
  # get strand-wise z scores for peaks passing raw coverage threshold
  # eliminate peaks with overlapping ranges by only keeping larger peak
  ## this is needed to prevent the same sequence from being pulled more than once

  # plus strand
  if (nrow(plus_set) > 0) {

    plus_z <- tibble(z = rep(NA, nrow(plus_set)),
                     position = rep(NA, nrow(plus_set)))
    hold <- pbapply(X = plus_set,
                    MARGIN = 1,
                    FUN = pause_score,
                    full = con_cov %>% filter(strand == "plus"),
                    range = range,
                    con_len = con_len)

    plus_z$z <- do.call(rbind, hold)[,1] %>% unlist()
    plus_z$position <- do.call(rbind, hold)[,2] %>% unlist()
    plus_z <- plus_z %>%
      mutate(startrng = position - context) %>%
      mutate(endrng = position + context) %>%
      arrange(startrng) %>%
      filter(z >= minpause)

    message(paste0("\n","--> plus strand has ", nrow(plus_z), " hits over Z-score threshold"))

    plus_z$grp <- 1
    if (nrow(plus_z) > 1) {
      for (k in 2:nrow(plus_z)) {

        if (plus_z$endrng[k - 1] >= plus_z$startrng[k]) {

          plus_z$grp[k] <- plus_z$grp[k - 1]

        } else {

          plus_z$grp[k] <- plus_z$grp[k - 1] + 1

        }
      }
    }

    message(paste0("\n","----> plus strand has ", nrow(plus_z), " hits remaining after overlap removal"))

    if (nrow(plus_z) > 0) {
      plus_z <- plus_z %>%
        group_by(grp) %>%
        top_n(1, z) %>%
        ungroup() %>%
        mutate(strand = "plus")
        plus_z$sequence <- apply(X = plus_z, MARGIN = 1,
                                 FUN = function(x) {
                                   cseq[x[3]:x[4]] %>%
                                     as.character()
                                   }
                                 )

    }

  }
  
  if (nrow(minus_set) > 0) {

    minus_z <- tibble(z = rep(NA, nrow(minus_set)),
                      position = rep(NA, nrow(minus_set)))
    hold <- pbapply(X = minus_set,
                    MARGIN = 1,
                    FUN = pause_score,
                    full = con_cov %>% filter(strand == "minus"),
                    range = range,
                    con_len = con_len)

    minus_z$z <- do.call(rbind, hold)[,1] %>% unlist()
    minus_z$position <- do.call(rbind, hold)[,2] %>% unlist()
    minus_z <- minus_z %>%
      mutate(startrng = position - context) %>%
      mutate(endrng = position + context) %>%
      arrange(startrng) %>%
      filter(z >= minpause)

    message(paste0("\n","--> minus strand has ", nrow(minus_z), " hits over Z-score threshold"))

    minus_z$grp <- 1
    if (nrow(minus_z) > 1) {
      for (k in 2:nrow(minus_z)) {

        if (minus_z$endrng[k - 1] >= minus_z$startrng[k]) {

          minus_z$grp[k] <- minus_z$grp[k - 1]

        } else {

          minus_z$grp[k] <- minus_z$grp[k - 1] + 1

        }
      }
    }

    message(paste0("\n","----> minus strand has ", nrow(minus_z), " hits remaining after overlap removal"))

    if (nrow(minus_z) > 0) {
      minus_z <- minus_z %>%
        group_by(grp) %>%
        top_n(1, z) %>%
        ungroup() %>%
        mutate(strand = "minus")
        minus_z$sequence <- apply(X = minus_z, MARGIN = 1,
                                 FUN = function(x) {
                                   cseq[x[3]:x[4]] %>%
                                     reverseComplement() %>%
                                     as.character()
                                   }
                                 )

    }

  }
                    
  bind_rows(plus_z, minus_z)
  
}

```

## run get_motifs
```{r}
setwd("/workdir/users/acv46/EC_PROSeq/figures/motifs")

# control, 3', 25 range, 20 min norm cov, 5 min pause, output 20 nt context
ec_motifs <- get_motifs(covdat = pro_covdat %>% filter(treatment == "control"),
                        seqdat = ec_fasta,
                        end = 3,
                        range = 25,
                        mincov = 20,
                        minpause = 5,
                        context = 20)

write_csv(ec_motifs, "PRO-seq_motifs_control_3p_25_20_5_20_flipped_redo2.csv", col_names = T)

# heat shock, 3', 25 range, 20 min norm cov, 5 min pause, output 20 nt context
ec_motifs <- get_motifs(covdat = pro_covdat %>% filter(treatment == "heat shock"),
                        seqdat = ec_fasta,
                        end = 3,
                        range = 25,
                        mincov = 20,
                        minpause = 5,
                        context = 20)

write_csv(ec_motifs, "PRO-seq_motifs_heat-shock_3p_25_20_5_20_flipped_redo2.csv", col_names = T)
```


## group motifs by locus
### read in regulondb
```{r}
require(regutools)
require(tidyverse)
## Build a regulondb object
## stores database at /home/acv46/.cache/AnnotationHub
e_coli_regulondb_10.9 <- regulondb(database_conn = connect_database(),
                              organism = "E.coli",
                              database_version = "10.9",
                              genome_version = "NC_000913.3")

#list_datasets(e_coli_regulondb)
#list_attributes(e_coli_regulondb, dataset = "PROMOTER")

## datasets

promoters <- get_dataset(e_coli_regulondb_10.9, 
            dataset = "PROMOTER",
            attributes = c("id","name","strand","tss","sigma_factor","regulated_operon")) %>%
  as_tibble()

# promoters_sub <- promoters[-grep(",",promoters$sigma_factor),] # remove promoters controlled by multiple sigma factors
# promoters_sub$sigma_factor[is.na(promoters_sub$sigma_factor)] <- "unknown"

ops <- get_dataset(e_coli_regulondb_10.9, 
            dataset = "OPERON") %>%
            #attributes = c("id","name","total_sigma","sigma_name")) %>%
  as_tibble()

dna_objects <- get_dataset(e_coli_regulondb_10.9, dataset = "DNA_OBJECTS") %>%
  as_tibble()

# genes
genes <- get_dataset(e_coli_regulondb_10.9, "GENE") %>% as_tibble() %>%
  select(name, posleft, posright, strand, operon_name, sigma_factor, gene_tf, product_name, go_desc_bp, tu_promoter)

# get object with tss and firstgeneposleft for all operons
tss2op <- promoters %>% separate(col = regulated_operon, into = c("op_id","op_name"), sep = "\t") %>%
  base::merge(., ops %>% select(id, firstgeneposleft, lastgeneposright, tf_name) %>% dplyr::rename("op_id" = "id"),
        by = "op_id") %>% drop_na(-tf_name) %>% as_tibble()

# reduce tss2op object to single regulatory range encompassing all promoters
reg_ranges <-
rbind(
  tss2op %>% filter(strand == "forward") %>%
    group_by(op_id) %>% arrange(tss) %>%
    dplyr::slice(1) %>% select(-lastgeneposright) %>%
    dplyr::rename("op_start" = "firstgeneposleft"),
  tss2op %>% filter(strand == "reverse") %>%
    group_by(op_id) %>% arrange(desc(tss)) %>%
    dplyr::slice(1) %>% select(-firstgeneposleft) %>%
    dplyr::rename("op_start" = "lastgeneposright")
)

reg_ranges <- reg_ranges %>% mutate(op_start = as.numeric(op_start)) %>% ungroup
reg_ranges_100 <- reg_ranges %>%
  mutate(op_start = ifelse(strand == "forward", as.numeric(op_start) + 100, as.numeric(op_start) - 100)) %>%
  ungroup

```

### find peaks that overlap tss
```{r}
# known sigma 
tss_peak <- function(peakdat, tssdat) {
  
  pdat <- read_csv(file = peakdat, col_names = T)
  merge(pdat, tssdat %>% rename(., "tss" = "position"), by = "position") %>%
    filter(sigma_factor != "unknown")
  
}

setwd("/workdir/users/acv46/EC_PROSeq/figures/motifs")
ec_control_tss_nounk <- tss_peak("PRO-seq_motifs_control_3p_25_20_5_20_flipped_redo2.csv", promoters_sub)
ec_hs_tss_nounk <- tss_peak("PRO-seq_motifs_heat-shock_3p_25_20_5_20_flipped_redo2.csv", promoters_sub)

# unknown sigma factor
tss_peak <- function(peakdat, tssdat) {
  
  pdat <- read_csv(file = peakdat, col_names = T)
  merge(pdat, tssdat %>% rename(., "tss" = "position"), by = "position") %>%
    filter(sigma_factor == "unknown")
  
}

setwd("/workdir/users/acv46/EC_PROSeq/figures/motifs")
ec_control_tss_unk <- tss_peak("PRO-seq_motifs_control_3p_25_20_5_20_flipped_redo2.csv", promoters_sub)
ec_hs_tss_unk <- tss_peak("PRO-seq_motifs_heat-shock_3p_25_20_5_20_flipped_redo2.csv", promoters_sub)
```

### find peaks that overlap any DNA object
```{r}
require(tidyverse)

map_peaks <- function(peakdat, objdat) {
  
  pdat <- read_csv(file = peakdat, col_names = T)
  numo <- nrow(objdat) 
  nump <- nrow(pdat)
  
  pdat$type <- NA
  pdat$obj_name <- NA
  pdat$obj_posleft <- NA
  pdat$obj_posright <- NA
  pdat$obj_strand <- NA
  
  # loop through peaks
  for (i in 1:nump) {
    
    message(paste0("processing peak ", i, " of ", nump))
    
    # loops through regulon db dna objects 
    for (j in 1:numo) {
      
      # if peak position falls within object bounds, write object to peak data
      if (isTRUE(between(x = pdat$position[i],
                         left = objdat$posleft[j],
                         right = objdat$posright[j])) &
          is.na(pdat$type[i])) {
        
        pdat$type[i] <- objdat$type[j]
        pdat$obj_name[i] <- objdat$name[j]
        pdat$obj_posright[i] <- objdat$posright[j]
        pdat$obj_posleft[i] <- objdat$posleft[j]
        pdat$obj_strand[i] <- objdat$strand[j]
        
      # if peak position already has an associated object, append another to list  
      } else if (isTRUE(between(x = pdat$position[i],
                         left = objdat$posleft[j],
                         right = objdat$posright[j])) &
                 !is.na(pdat$type[i])) {

        pdat$type[i] <- paste0(pdat$type[i], ", ", objdat$type[j])
        pdat$obj_name[i] <- paste0(pdat$obj_name[i], ", ", objdat$name[j])
        pdat$obj_posright[i] <- paste0(pdat$obj_posright[i], ", ", objdat$posright[j])
        pdat$obj_posleft[i] <- paste0(pdat$obj_posleft[i], ", ", objdat$posleft[j])
        pdat$obj_strand[i] <- paste0(pdat$obj_strand[i], ", ", objdat$strand[j])
        
      }
    }
  }
  
  pdat
  
}
  
setwd("/workdir/users/acv46/EC_PROSeq/figures/motifs")
ec_control_peak_all <- map_peaks("PRO-seq_motifs_control_3p_25_20_5_20_flipped_redo2.csv", dna_objects)
ec_hs_peak_all <- map_peaks("PRO-seq_motifs_heat-shock_3p_25_20_5_20_flipped_redo2.csv", dna_objects)

setwd("/workdir/users/acv46/EC_PROSeq/figures/motifs")
write_tsv(ec_control_peak_all, "PRO-seq_motifs_control_3p_25_20_5_20_flipped_redo2_DNA_objects.tsv")
write_tsv(ec_hs_peak_all, "PRO-seq_motifs_hs_3p_25_20_5_20_flipped_redo2_DNA_objects.tsv")
```

### find peaks that fall within regulatory regions
```{r}
# from Sun 2020 -- "Many E. coli genes appear to contain clusters of strong backtracked pauses at 10-20-bp distance from the transcription start site caused by retention of σ70 subunit in RNA polymerase"

reg_peak <- function(peakdat, tssdat) {
  
  require(dplyr)
  
  tdat <- tssdat %>% mutate(peakcount = 0)
  tlen <- nrow(tssdat)
  pdat <- read_csv(file = peakdat, col_names = T) %>%
    mutate(strand = ifelse(strand == "plus", "forward", "reverse"))
  for (i in 1:nrow(tdat)) {
    
    message(paste0("processing range ", i, "/", tlen))
    
    for(j in 1:nrow(pdat)) {
     
      if (as.numeric(pdat$position[j]) %in% as.numeric(tdat$tss[i]):as.numeric(tdat$op_start[i]) &
          pdat$strand[j] == tdat$strand[i]) {
        
        tdat$peakcount[i] <- tdat$peakcount[i] + 1
        
      } 
      
    }
  }
  
  tdat
  
}

setwd("/workdir/users/acv46/EC_PROSeq/figures/motifs")
ec_c_peak_reg <- reg_peak("PRO-seq_motifs_control_3p_25_20_5_20_flipped_redo2.csv", reg_ranges_100) %>% ungroup()
#write_tsv(ec_c_peak_genes, "PRO-seq_motifs_control_3p_25_20_5_20_flipped_redo2_regranges.tsv")
ec_h_peak_reg <- reg_peak("PRO-seq_motifs_heat-shock_3p_25_20_5_20_flipped_redo2.csv", reg_ranges_100) %>% ungroup()
#write_tsv(ec_h_peak_genes, "PRO-seq_motifs_hs_3p_25_20_5_20_flipped_redo2_regranges.tsv")
```

### get sequence logos of peaks overlapping regulatory regions
```{r}
reg_peak <- function(peakdat, tssdat) {
  
  require(dplyr)
  require(ggseqlogo)
  
  seqdat <- tibble()
  tdat <- tssdat #%>% filter(sigma_factor == sigma)
  tlen <- nrow(tdat)
  pdat <- read_csv(file = peakdat, col_names = T) %>%
    mutate(strand = ifelse(strand == "plus", "forward", "reverse"))
  for (i in 1:nrow(tdat)) {
    
    message(paste0("processing range ", i, "/", tlen))
    
    for(j in 1:nrow(pdat)) {
     
      if (as.numeric(pdat$position[j]) %in% as.numeric(tdat$tss[i]):as.numeric(tdat$op_start[i]) &
          pdat$strand[j] == tdat$strand[i]) {
        
        seqdat <- rbind(seqdat, pdat$sequence[j])
        
      } 
      
    }
  }
  
  # message(paste0(nrow(seqdat)))
  trimseqs <- seqdat %>% #filter(bin == xbin) %>%
    as_vector() %>%
    str_sub(start = 10, end = 25)
    
    
  trimseqs
  
}

setwd("/workdir/users/acv46/EC_PROSeq/figures/motifs")
peakc <- reg_peak("PRO-seq_motifs_control_3p_25_20_5_20_flipped_redo2.csv", reg_ranges_100)
peakh <- reg_peak("PRO-seq_motifs_heat-shock_3p_25_20_5_20_flipped_redo2.csv", reg_ranges_100)
```
```{r}
library(patchwork)

p1 <- ggseqlogo(peakc,
                    #col_scheme = cs1,
                    method = "bits") +
      theme(plot.margin = unit(c(0.1,0.1,0.1,0.1),"cm"),
            #plot.title = element_text(size = 10),
            aspect.ratio = 1/5,
            axis.text.x = element_blank()) +
  annotate('text', label = paste0("Control","\n","410 peaks"),
            x = 1, y = 0.35, hjust = 0)
      # ggtitle(paste0(sample, ", bin = ", xbin, "\n", 
      #                numcontigs, " contigs, ", numpeaks, " pause sites passing cutoff\n",
      #                "phylum = ", phy, "\n",
      #                "kraken species annotation = ", k_species, "\n",
      #                "gtdbtk species annotation = ", g_species, "\n",
      #                complete, "% complete, ", contam, "% contaminated"))
    
    p2 <- ggseqlogo(peakh,
                    #col_scheme = cs1,
                    method = "bits") +
      theme(plot.margin = unit(c(0.1,0.1,0.1,0.1),"cm"),
            #plot.title = element_text(size = 10),
            aspect.ratio = 1/5) +
  annotate('text', label = paste0("Heat Shock","\n","271 peaks"),
            x = 1, y = 0.15, hjust = 0)
    
    p2$scales$scales[[1]] <- scale_x_continuous(breaks = c(1:16),
                                                labels = c(seq(from = -11, to = -1), c(1:5)))
    
    
    mergep <- p1 / p2
    
    mergep
    
    ggsave(filename = "/workdir/users/acv46/EC_PROSeq/figures/motifs/PRO-seq_motifs_reg100_3p_25_20_5_20_flipped_redo2_v2.pdf", plot = mergep, device = "pdf", useDingbats = F, dpi = 400, width = 6, height = 3, units = "in")

```

### get barplots of sigma factors distributions corresponding to regulatory region sequence logos
```{r}
require(tidyverse)
require(ggtext)
#require(glue)

control_sigdat <- ec_c_peak_reg %>% filter(peakcount > 0) %>%
  select(sigma_factor) %>% mutate(sigma = ifelse(grepl(",",sigma_factor), "mixed", sigma_factor)) %>%
  select(sigma) %>% table %>% as_data_frame() %>% dplyr::rename("sigma" = ".", "count" = "n")

hs_sigdat <- ec_h_peak_reg %>% filter(peakcount > 0) %>%
  select(sigma_factor) %>% mutate(sigma = ifelse(grepl(",",sigma_factor), "mixed", sigma_factor)) %>%
  select(sigma) %>% table %>% as_data_frame() %>% dplyr::rename("sigma" = ".", "count" = "n") %>%
  rbind(c("Sigma28",0))

all_sigdat <- rbind(control_sigdat %>% mutate(sample = "control"),
                    hs_sigdat %>% mutate(sample = "heat_shock"))

siglist <- c("Sigma70", "Sigma32", "Sigma24", "Sigma38", "Sigma54", "Sigma28", "mixed")

control_sigdat <- control_sigdat %>% mutate(sigma = factor(sigma, levels = rev(siglist))) %>% mutate(count = as.numeric(count))
hs_sigdat <- hs_sigdat %>% mutate(sigma = factor(sigma, levels = rev(siglist))) %>% mutate(count = as.numeric(count))
all_sigdat <- all_sigdat %>% mutate(sigma = factor(sigma, levels = rev(siglist))) %>% mutate(count = as.numeric(count))

# plot it
get_bars <- function(sigdat) {

  # highlight = function(x, pat, color = "black", family = "") {
  #   ifelse(grepl(pat, x),
  #          glue("<b style='font-family:{family}; color:{color}'>{x}</b>"),
  #          x)
  #   }
  
  barpal <- c("#56a3a6","#ffc857","#e9724c","#c5283d","#4e4187","#d30c7b","gray50")
  ggplot(sigdat, mapping = aes(x = sigma, fill = sigma, y = count)) +
        geom_bar(stat = "identity") +
        geom_text(mapping = aes(label = count, position = sigma), hjust = -0.2) +
        theme_classic() +
        xlab("") +
        theme(legend.position = "none",
              #aspect.ratio = 2,
              axis.text.y = element_markdown(size = 12),
              #axis.text.y = element_text(size = 12),
              axis.text.x = element_text(size = 10)) +
        scale_y_continuous(breaks = seq(0,175,25), limits = c(0,175),
                           name = "count") +
        #scale_x_discrete(labels = function(x) highlight(x, sigma, color = "red")) +
        scale_fill_manual(values = rev(barpal)) +
        coord_flip()

}
get_bars2 <- function(sigdat) {

  # highlight = function(x, pat, color = "black", family = "") {
  #   ifelse(grepl(pat, x),
  #          glue("<b style='font-family:{family}; color:{color}'>{x}</b>"),
  #          x)
  #   }
  
  barpal <- c("#56a3a6","#ffc857","#e9724c","#c5283d","#4e4187","#d30c7b","gray50")
  sampal <- c("#E69F00FF","#D55E00FF")
  ggplot(sigdat, mapping = aes(x = sigma, fill = sample, y = count)) +
        geom_bar(stat = "identity",
                 position = position_dodge2(reverse = TRUE, width = 1),
                 color = "black") +
        geom_text(mapping = aes(label = count, position = sigma, group = sample),
                  hjust = -0.2,
                  position = position_dodge2(reverse = TRUE, width = 1)) +
        theme_classic() +
        xlab("") +
        theme(legend.position = "none",
              #aspect.ratio = 2,
              axis.text.y = element_markdown(size = 12),
              #axis.text.y = element_text(size = 12),
              axis.text.x = element_text(size = 10)) +
        scale_y_continuous(breaks = seq(0,175,25), limits = c(0,175),
                           name = "count") +
        #scale_x_discrete(labels = function(x) highlight(x, sigma, color = "red")) +
        scale_fill_manual(values = sampal) +
        coord_flip(clip = "off")

}

cnp <- get_bars(sigdat = control_sigdat)
hnp <- get_bars(sigdat = hs_sigdat)
anp <- get_bars2(sigdat = all_sigdat)

cnp
hnp
anp
```
```{r}
setwd("/workdir/users/acv46/EC_PROSeq/figures/promoters")
ggsave(plot = anp, filename = "PRO-seq_sigma_bargraph_regregions_v2.pdf", device = "pdf",
       width = 4, height = 2.5, units = "in", dpi = 300, useDingbats = FALSE)
```

### operon intersection between reg peak datasets
```{r}
require(dplyr)
require(ggvenn)
require(ggplot2)
library(eulerr)

op_int <- list(
  control = ec_c_peak_reg %>% filter(peakcount > 0) %>% select(op_name) %>% as_vector(),
  heat_shock = ec_h_peak_reg %>% filter(peakcount > 0) %>% select(op_name) %>% as_vector()
  )

ggvenn(op_int,
       fill_color = c("#7acfff","#0072B2FF"),
       fill_alpha = 0.3,
       text_size = 7,
       show_percentage = F)

setwd("/workdir/users/acv46/EC_PROSeq/figures/promoters")
ggsave(plot = plot(euler(op_int, shape = "circle"),
                   fills = c("#E69F00FF","#D55E00FF"),
                   edges = T,
                   fontsize = 20,
                   quantities = list(fontsize = 30),
                   fill_alpha = 0.2,
                   lwd = 5),
       filename = "promoter_reg100_venn_v2.pdf",
       device = "pdf", dpi = 300,
       useDingbats = F,
       height = 2,
       width = 3,
       units = "in")
```

### get GO description and TFs for operons with peak-containing reg regions
```{r}
require(dplyr)

# see "find peaks that fall within regulatory regions" section for ec_c_peak_reg object
# generate object with reg_ranges_100 object

op_int_id <- list(
  control = ec_c_peak_reg %>% filter(peakcount > 0) %>% select(op_id) %>% as_vector(),
  heat_shock = ec_h_peak_reg %>% filter(peakcount > 0) %>% select(op_id) %>% as_vector()
  )

# get GO terms for genes in operons

go_table <- function(op = op_int_id,
                     regdb = get_dataset(e_coli_regulondb_10.9, list_datasets(e_coli_regulondb_10.9)[2])) {
  
  getset <- function(set) {
    
    mf <- regdb %>% as_tibble %>%
      filter(operon_id %in% set) %>% select(operon_id, go_desc_mf)
    bp <- regdb %>% as_tibble %>%
      filter(operon_id %in% set) %>% select(operon_id, go_desc_bp)
    cc <- regdb %>% as_tibble %>%
      filter(operon_id %in% set) %>% select(operon_id, go_desc_cc)
    
    left_join(mf, bp) %>% left_join(., cc, by = "operon_id") %>% 
      select(operon_id, go_desc_bp) %>% unique() %>%
      select(go_desc_bp) %>% mutate(bplist = strsplit(go_desc_bp, "\t")) %>%
      unnest(bplist) %>% arrange(bplist) %>% select(bplist) %>%
      table %>% sort(decreasing = T) %>% head(n = 10)
    
  }
  
  list(
    both = getset(intersect(op_int_id$control, op_int_id$heat_shock)),
    cont = getset(setdiff(op_int_id$control, op_int_id$heat_shock)),
    heat = getset(setdiff(op_int_id$heat_shock, op_int_id$control))
  )
  
}

op_go <- go_table()

write_csv(x = tibble(heat_shock = paste0(names(op_go$heat), " (",op_go$heat,")"),
                     control = paste0(names(op_go$cont), " (",op_go$cont,")"),
                     both = paste0(names(op_go$both), " (",op_go$both,")")),
          file = "/workdir/users/acv46/EC_PROSeq/figures/promoters/table_reg100_GO_molFunc_top10_v1.csv",
          col_names = T)

# op_go$both %>% select(operon_id, go_desc_bp) %>% unique() %>% select(go_desc_bp) %>% mutate(bplist = strsplit(go_desc_bp, "\t")) %>% unnest(bplist) %>% arrange(bplist) %>% select(bplist) %>% table %>% sort

# get TF controlling expression of operons

op_int_id <- list(
  control = ec_c_peak_reg %>% filter(peakcount > 0) %>% select(op_id) %>% as_vector(),
  heat_shock = ec_h_peak_reg %>% filter(peakcount > 0) %>% select(op_id) %>% as_vector()
  )

# get GO terms for genes in operons

tf_table <- function(op = op_int_id,
                     regdb = get_dataset(e_coli_regulondb_10.9, list_datasets(e_coli_regulondb_10.9)[4])) {
  
  getset <- function(set) {
    
    tf <- regdb %>% as_tibble %>%
      filter(id %in% set) %>% select(id, tf_name) %>%
      unique() %>% select(tf_name) %>% mutate(tflist = strsplit(tf_name, ",")) %>%
      unnest(tflist) %>% arrange(tflist) %>% select(tflist) %>%
      table %>% sort(decreasing = T) %>% head(n = 10)
    
  }
  
  list(
    both = getset(intersect(op_int_id$control, op_int_id$heat_shock)),
    cont = getset(setdiff(op_int_id$control, op_int_id$heat_shock)),
    heat = getset(setdiff(op_int_id$heat_shock, op_int_id$control))
  )
  
}

op_tf <- tf_table()

```

### get transcription regulator identities of peak-containing regulatory regions
```{r}
reg_peak <- function(peakdat, tssdat) {
  
  require(dplyr)
  
  tdat <- tssdat %>% mutate(peakcount = 0)
  tlen <- nrow(tssdat)
  pdat <- read_csv(file = peakdat, col_names = T) %>%
    mutate(strand = ifelse(strand == "plus", "forward", "reverse"))
  for (i in 1:nrow(tdat)) {
    
    message(paste0("processing range ", i, "/", tlen))
    
    for(j in 1:nrow(pdat)) {
     
      if (as.numeric(pdat$position[j]) %in% as.numeric(tdat$tss[i]):as.numeric(tdat$op_start[i]) &
          pdat$strand[j] == tdat$strand[i]) {
        
        tdat$peakcount[i] <- tdat$peakcount[i] + 1
        
      } 
      
    }
  }
  
  tdat %>% ungroup %>% filter(peakcount > 0) %>%
    select(tf_name) %>% mutate(tflist = strsplit(tf_name, ",")) %>%
    unnest(tflist) %>% arrange(tflist) %>%
    select(tflist) %>% table %>% sort
  
}

setwd("/workdir/users/acv46/EC_PROSeq/figures/motifs")
ec_c_peak_reg_tf <- reg_peak("PRO-seq_motifs_control_3p_25_20_5_20_flipped_redo2.csv", reg_ranges)
#write_tsv(ec_c_peak_genes, "PRO-seq_motifs_control_3p_25_20_5_20_flipped_redo2_regranges.tsv")
ec_h_peak_reg_tf <- reg_peak("PRO-seq_motifs_heat-shock_3p_25_20_5_20_flipped_redo2.csv", reg_ranges)
#write_tsv(ec_h_peak_genes, "PRO-seq_motifs_hs_3p_25_20_5_20_flipped_redo2_regranges.tsv")

```

### barplot tallying peaks overlapping 5' UTR
```{r}
ec_c_peak_reg %>% mutate(sigma_factor = ifelse(grepl(",",sigma_factor), "mixed", sigma_factor)) %>%
  filter(peakcount > 0) %>% select(sigma_factor, peakcount) %>%
  arrange(factor(sigma_factor, levels = c("Sigma70","Sigma32","Sigma24","Sigma28","Sigma38","Sigma54","mixed"))) %>%
  ggplot() +
  geom_bar(mapping = aes(x = sigma_factor, y = peakcount),
           stat = "identity") +
  theme_classic() +
  coord_flip(ylim = c(0,170))

ec_h_peak_reg %>% mutate(sigma_factor = ifelse(grepl(",",sigma_factor), "mixed", sigma_factor)) %>%
  filter(peakcount > 0) %>% select(sigma_factor, peakcount) %>%
  ggplot() +
  geom_bar(mapping = aes(x = sigma_factor, y = peakcount),
           stat = "identity") +
  theme_classic() +
  coord_flip(ylim = c(0,170))
```

### get PRO-seq 3' end coverage +/- 500 bp around TSS, subset by sigma
```{r}
# input: pro_covdat and tss2op objects
# run as a job: 

tss_prox <- tibble()
context <- 500

for (i in 1:nrow(reg_ranges)) {
  
  tot <- nrow(reg_ranges)
  tssdat <- reg_ranges[i,]
  
  if (tssdat$strand == "forward") {
    
    upstrm <- as.numeric(tssdat$tss - context)
    dnstrm <- as.numeric(tssdat$tss + context)
    res <- pro_covdat %>% filter(type == "PRO-seq" &
                            strand == "plus" &
                            end == "3" &
                            position >= upstrm &
                            position <= dnstrm) %>%
      mutate(index = rep(-context:context, each = 2)) %>%
      mutate(sigma = tssdat$sigma_factor) %>%
      mutate(op_name = tssdat$op_name)
    
    tss_prox <- bind_rows(tss_prox, res)
    
  }
  
  if (tssdat$strand == "reverse") {
    
    upstrm <- as.numeric(tssdat$tss + context)
    dnstrm <- as.numeric(tssdat$tss - context)
    res <- pro_covdat %>% filter(type == "PRO-seq" &
                            strand == "minus" &
                            end == "3" &
                            position <= upstrm &
                            position >= dnstrm) %>%
      mutate(index = rep(context:-context, each = 2)) %>%
      mutate(sigma = tssdat$sigma_factor) %>%
      mutate(op_name = tssdat$op_name)
    
    tss_prox <- bind_rows(tss_prox, res)
    
  }
  
  message(paste0(i," / ", tot))
  
}
```

### plot above
```{r}
require(tidyverse)
#tss_prox <- read_csv("/workdir/users/acv46/EC_PROSeq/figures/motifs/PRO-seq_pausing_500bp_centertss.csv", col_names = T)
#trans_prox <- read_csv("/workdir/users/acv46/EC_PROSeq/figures/motifs/PRO-seq_pausing_500bp_centertrans.csv", col_names = T)

plotsigma <- function(plotdat, title, ypos) {

  counts <- plotdat %>% filter(!grepl(",", sigma)) %>%
    filter(index == 0, treatment == "control", strand == "plus", end == "3") %>%
    select(sigma) %>% table %>% as_tibble() %>% rename("sigma" = ".")
  
  plotdat2 <- left_join(plotdat, counts, by = "sigma")
  
  ggplot(data = plotdat2 %>%
           filter(!grepl(",", sigma)) %>%
           filter(index %in% c(-500:500)) %>%
           filter(strand == "plus")) + 
    geom_smooth(mapping = aes(x = index, y = value, color = treatment, fill = treatment)) +
    geom_text(mapping = aes(label = paste0(sigma,"\n","n = ",n)),
              x = -500,
              y = ypos,
              hjust = 0,
              vjust = 1,
              check_overlap = T) + 
    scale_color_manual(values = c("blue", "red")) + 
    scale_fill_manual(values = c("blue", "red")) + 
    geom_hline(yintercept = 0, color = "black") +
    geom_vline(xintercept = 0, color = "black", linetype = "dotted") +
    xlab("position") +
    ylab("Per-base read depth") +
    facet_wrap(~ sigma, nrow = 2) + 
    #theme_classic() + 
    ggtitle(title) +
    theme(strip.background = element_blank(),
          strip.text = element_blank(),
          panel.spacing = unit(0.2, "lines"),
          panel.background = element_rect(fill = "white"),
          panel.border = element_rect(colour = "black", size = 1, fill = NA),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank())
  
}

p1 <- plotsigma(tss_prox, "PRO-seq operon coverage profiles centered at right-most transcription start site", 3.8)
p2 <- plotsigma(trans_prox, "PRO-seq operon coverage profiles centered at first start codon", 4.2)

p1
p2

setwd("/workdir/users/acv46/EC_PROSeq/figures/promoters")
ggsave(filename = "proseq_perOperon_bySigma_centerTSS_500_v4.pdf",
       plot = p1, device = "pdf", width = 8, height = 6, units = "in",
       useDingbats = FALSE)
ggsave(filename = "proseq_perOperon_bySigma_centerStartCodon_500_v4.pdf",
       plot = p2, device = "pdf", width = 8, height = 6, units = "in",
       useDingbats = FALSE)

```

## motif sequence logos
### read in peak sequence data (or use tss-overlapping peaks from above)
```{r}
require(tidyverse)

pull_seqs <- function(plus) {
  
  dat <- read_csv(file = plus, col_names = T)
  dat
  
}

setwd("/workdir/users/acv46/EC_PROSeq/figures/motifs")
control_peaks <- pull_seqs("PRO-seq_motifs_control_3p_25_50_5_20.csv")
hs_peaks <- pull_seqs("PRO-seq_motifs_heat-shock_3p_25_50_5_20.csv")
```

### function to plot ggseqlogos, all peaks
```{r}
get_logos <- function(peaks){
  
  require(ggseqlogo)
  require(patchwork)
  require(tidyverse)
  require(staplr)
  
  # input is _seqs dataframe, CRISPR nameand strand
  
  # binnames <- peaks %>% select(bin) %>%
  #   unique() %>% as_vector()
  # 
  # sapply(binnames, function(xbin) {
    
    # pull data for plot title
    
    # numcontigs <- bindat %>% filter(bin == xbin) %>%
    #   select(contig) %>% nrow()
    # 
    # phy <- bindat %>% filter(bin == xbin) %>%
    #   select(k_name_P) %>% unique()
    # 
    # k_species <- bindat %>% filter(bin == xbin) %>%
    #   select(k_name_S) %>% unique()
    # 
    # g_species <- bindat %>% filter(bin == xbin) %>%
    #   select(g_species) %>% unique()
    # 
    # complete <- bindat %>% filter(bin == xbin) %>%
    #   select(completeness) %>% unique()
    # 
    # contam <- bindat %>% filter(bin == xbin) %>%
    #   select(contamination) %>% unique()
    # 
    # sample <- bindat %>% filter(bin == xbin) %>%
    #   select(sample) %>% unique()
    # 
    # numpeaks <- peaks %>% filter(bin == xbin) %>% nrow()
    
    # # pull full seqs to plot
    # 
    # fullseqs <- peaks %>% filter(bin == xbin) %>%
    #   select(sequence) %>% as_vector()
    
    # pull seqs and trim to -11 to +5 range
    
    trimseqs <- peaks %>% #filter(bin == xbin) %>%
      select(sequence) %>% as_vector() %>%
      str_sub(start = 10, end = 25)
    
    p1 <- ggseqlogo(trimseqs,
                    #col_scheme = cs1,
                    method = "bits") +
      theme(plot.margin = unit(c(0.1,0.1,0.1,0.1),"cm"),
            #plot.title = element_text(size = 10),
            aspect.ratio = 1/5,
            axis.text.x = element_blank())
      # ggtitle(paste0(sample, ", bin = ", xbin, "\n", 
      #                numcontigs, " contigs, ", numpeaks, " pause sites passing cutoff\n",
      #                "phylum = ", phy, "\n",
      #                "kraken species annotation = ", k_species, "\n",
      #                "gtdbtk species annotation = ", g_species, "\n",
      #                complete, "% complete, ", contam, "% contaminated"))
    
    p2 <- ggseqlogo(trimseqs,
                    #col_scheme = cs1,
                    method = "prob") +
      theme(plot.margin = unit(c(0.1,0.1,0.1,0.1),"cm"),
            #plot.title = element_text(size = 10),
            aspect.ratio = 1/5)
    
    p2$scales$scales[[1]] <- scale_x_continuous(breaks = c(1:16),
                                                labels = c(seq(from = -11, to = -1), c(1:5)))
    
    
    mergep <- p1 / p2
    
    mergep
  
}

setwd("/workdir/users/acv46/EC_PROSeq/figures/motifs")
get_logos(control_peaks)
get_logos(hs_peaks)

# pdf(name, useDingbats = FALSE,
#         height = 4,
#         width = 6)
#              
#     print(mergep)
#              
#     dev.off()
```

### function to plot ggseqlogos, tss peaks, promoters with known sigma factors
```{r}
get_logos2 <- function(peaks, sigdat, sigma, covdat) {
  
  # peaks is the subset peak file
  # sigdat is generated below
  # sigma is the chosen sigma factor to plot logo and coverage
  # covdat is the subset coverage data
  
  require(ggseqlogo)
  require(patchwork)
  require(tidyverse)
  require(staplr)
  require(glue)
  require(ggtext)
  
  highlight = function(x, pat, color = "black", family = "") {
    ifelse(grepl(pat, x),
           glue("<b style='font-family:{family}; color:{color}'>{x}</b>"),
           x)
    }
    
  barpal <- c("#56a3a6","#ffc857","#e9724c","#c5283d","#4e4187","#d30c7b")
  cs1 <- make_col_scheme(chars = c('A', 'T', 'C', 'G'),
                         cols = c('#009603', '#bd0010', '#0000bd', 'black'))
    
    # pull seqs and trim to -11 to +5 range
    
    trimseqs <- peaks %>% filter(sigma_factor == sigma) %>% 
      select(sequence) %>% as_vector() %>%
      substr(start = 10, stop = 25)
    
    p1 <- ggseqlogo(trimseqs,
                    col_scheme = cs1,
                    method = "bits") +
      #facet_grid(sigma ~ .) +
      theme(axis.text.x = element_text(size = 8, angle = 0)
            #plot.margin = unit(c(0.1,0.1,0.1,0.1),"cm"),
            #plot.title = element_text(size = 10),
            #aspect.ratio = 1/3,
            ) +
      theme_classic() +
      annotate('rect', xmin = 10.5, xmax = 12.5,
               ymin = -0.05, ymax = Inf,
               alpha = .1, col = 'black', fill = 'yellow')
    
    plotpeaks <- peaks %>% filter(sigma_factor == sigma) %>%
      select(position, strand.x) %>%
      mutate(start = ifelse(strand.x == "plus", as.numeric(position) - 10, as.numeric(position) - 5)) %>%
      mutate(end = ifelse(strand.x == "plus", as.numeric(position) + 5, as.numeric(position) + 10))
    
    peakcov <- apply(plotpeaks, MARGIN = 1, function(pk) {
      
      if (pk[2] == "plus") {
        
        covdat %>% filter(strand == "plus") %>%
          filter(end == "3") %>%
          filter(position %in% c((as.numeric(pk[1]) - 10):(as.numeric(pk[1]) + 5))) %>%
          select(norm) %>% mutate(index = c(1:16))
        
      } else if (pk[2] == "minus") {
        
        covdat %>% filter(strand == "minus") %>%
          filter(end == "3") %>%
          filter(position %in% c((as.numeric(pk[1]) - 5):(as.numeric(pk[1]) + 10))) %>%
          select(norm) %>% mutate(index = c(16:1)) %>% arrange(.,index)
        
      }
      
    }) %>% bind_rows() %>% group_by(index) %>%
      mutate(mean = mean(norm)) %>% mutate(se = (sd(norm))/sqrt(length(norm))) %>%
      select(index, mean, se) %>% distinct()
    
    p2 <- ggplot(data = peakcov,
                 mapping = aes(x = index, y = mean)) +
      geom_bar(stat = "identity", color = "red",
               size = 0.5, fill = "red") +
      geom_errorbar(mapping = aes(ymin = mean - se, ymax = mean + se),
                    width = 0.2) +
      scale_y_continuous(breaks = c(0, 1.2 * max(peakcov$norm), 10),
                         limits = c(0, 1.2 * max(peakcov$norm))) +
      theme_classic() + 
      ggtitle(paste0(sigma, " promoter pausing")) +
      ylab("Per-base RPM") +
      xlab("")
    
    p1$scales$scales[[1]] <- scale_x_continuous(breaks = c(1:16),
                                                labels = c(seq(from = -11, to = -1), c(1:5)))
    p2$scales$scales[[1]] <- scale_x_continuous(breaks = c(1:16),
                                                labels = c(seq(from = -11, to = -1), c(1:5)))
    
    p3 <- ggplot(sigdat, mapping = aes(x = sigma, fill = sigma, y = as.numeric(count))) +
      geom_bar(stat = "identity") +
      geom_text(mapping = aes(label = count, position = sigma), hjust = -0.2) +
      theme_classic() +
      xlab("") +
      theme(legend.position = "none",
            #aspect.ratio = 2,
            axis.text.y = element_markdown(size = 12),
            #axis.text.y = element_text(size = 12),
            axis.text.x = element_text(size = 10)) +
      scale_y_continuous(breaks = seq(0,50,10), limits = c(0,50),
                         name = "count") +
      scale_x_discrete(labels = function(x) highlight(x, sigma, color = "red")) +
      scale_fill_manual(values = barpal) +
      coord_flip()
    
    p3 - (p2 / p1) +
      plot_layout(widths = c(1, 2))
    
    

  
}

cnames <- c("sigma","count")
control_sigdat <- table(ec_control_tss_nounk$sigma_factor) %>% as.data.frame(stringsAsFactors = FALSE)
#control_sigdat <- rbind(control_sigdat, c("Sigma24", "0"))
control_sigdat <- rbind(control_sigdat, c("Sigma54", "0"))
colnames(control_sigdat) <- cnames
control_sigdat$sigma <- as.character(control_sigdat$sigma)
control_sigdat$sigma <- factor(control_sigdat$sigma, levels = rev(c("Sigma70", "Sigma32", "Sigma24", "Sigma38", "Sigma54", "unknown")))


hs_sigdat <- table(ec_hs_tss_nounk$sigma_factor) %>% as.data.frame(stringsAsFactors = FALSE)
colnames(hs_sigdat) <- cnames
hs_sigdat$sigma <- as.character(hs_sigdat$sigma)
hs_sigdat$sigma <- factor(hs_sigdat$sigma, levels = rev(c("Sigma70", "Sigma32", "Sigma24", "Sigma38", "Sigma54", "unknown")))

# plot it

setwd("/workdir/users/acv46/EC_PROSeq/figures/motifs")
cnp <- get_logos2(peaks = ec_control_tss_nounk,
                  sigdat = control_sigdat,
                  sigma = "Sigma70",
                  covdat = pro_covdat %>% filter(treatment == "control"))
hsp <- get_logos2(peaks = ec_hs_tss_nounk,
                  sigdat = hs_sigdat,
                  sigma = "Sigma32",
                  covdat = pro_covdat %>% filter(treatment == "heat shock"))

cnp
hsp

# pdf("control_promoter_peaks_noUnk_v2.pdf", useDingbats = FALSE,
#     height = 3,
#     width = 6)
# 
#     print(cnp)
# 
# dev.off()
# 
# pdf("hs_promoter_peaks_noUnk_v2.pdf", useDingbats = FALSE,
#     height = 3,
#     width = 6)
# 
#     print(hsp)
# 
# dev.off()

```
### function to plot ggseqlogos, tss peaks, all promoters
```{r}
get_logos2 <- function(peaks){
  
  require(ggseqlogo)
  require(patchwork)
  require(tidyverse)
  require(staplr)
    
  #barpal <- c("#56a3a6","#ffc857","#e9724c","#c5283d","#4e4187","#d30c7b")
    
    # pull seqs and trim to -11 to +5 range
    
    trimseqs <- peaks %>% 
      select(sequence) %>% as_vector() %>%
      str_sub(start = 10, end = 25)
    
    p1 <- ggseqlogo(trimseqs,
                    #col_scheme = cs1,
                    method = "bits") +
      theme(plot.margin = unit(c(0.1,0.1,0.1,0.1),"cm"),
            #plot.title = element_text(size = 10),
            aspect.ratio = 1/3,
            axis.text.x = element_blank())
    
    p2 <- ggseqlogo(trimseqs,
                    #col_scheme = cs1,
                    method = "prob") +
      theme(plot.margin = unit(c(0.1,0.1,0.1,0.1),"cm"),
            #plot.title = element_text(size = 10),
            aspect.ratio = 1/3)
    
    p2$scales$scales[[1]] <- scale_x_continuous(breaks = c(1:16),
                                                labels = c(seq(from = -11, to = -1), c(1:5)))
    
    # p3 <- ggplot(sigdat, mapping = aes(x = sigma, fill = sigma, y = as.numeric(count))) +
    #   geom_bar(stat = "identity") +
    #   theme_classic() +
    #   xlab("") +
    #   theme(legend.position = "none",
    #         aspect.ratio = 2,
    #         axis.text.y = element_text(size = 12),
    #         axis.text.x = element_text(size = 10)) +
    #   scale_y_continuous(breaks = seq(0, 20, 5), limits = c(0, 20),
    #                      name = "count") +
    #   scale_fill_manual(values = barpal) +
    #   coord_flip()
    
    mergep <- p1 / p2
    mergep
    
}

# cnames <- c("sigma","count")
# control_sigdat <- table(ec_control_tss$sigma_factor) %>% as.data.frame(stringsAsFactors = FALSE)
# control_sigdat <- rbind(control_sigdat, c("Sigma24", "0"))
# control_sigdat <- rbind(control_sigdat, c("Sigma54", "0"))
# colnames(control_sigdat) <- cnames
# control_sigdat$sigma <- as.character(control_sigdat$sigma)
# control_sigdat$sigma <- factor(control_sigdat$sigma, levels = rev(c("Sigma70", "Sigma32", "Sigma24", "Sigma38", "Sigma54", "unknown")))
# 
# 
# hs_sigdat <- table(ec_hs_tss$sigma_factor) %>% as.data.frame(stringsAsFactors = FALSE)
# colnames(hs_sigdat) <- cnames
# hs_sigdat$sigma <- as.character(hs_sigdat$sigma)
# hs_sigdat$sigma <- factor(hs_sigdat$sigma, levels = rev(c("Sigma70", "Sigma32", "Sigma24", "Sigma38", "Sigma54", "unknown")))

setwd("/workdir/users/acv46/EC_PROSeq/figures/motifs")
cnp <- get_logos2(ec_control_tss_unk)
hsp <- get_logos2(ec_hs_tss_unk)

cnp
hsp

# pdf("control_promoter_peaks_Unkonly_v1.pdf", useDingbats = FALSE,
#     height = 4,
#     width = 6)
# 
#     print(cnp)
# 
# dev.off()
# 
# pdf("hs_promoter_peaks_Unkonly_v1.pdf", useDingbats = FALSE,
#     height = 4,
#     width = 6)
# 
#     print(hsp)
# 
# dev.off()

```
## for peaks overlapping terminators, get terminator sequences for Vienna RNAheat analysis
```{r}
# seqdat from "read in fasta" section above

get_term_seqs <- function(peakdat, seqdat, range) {
  
  peaks <- peakdat %>%
    filter(type == "terminator") %>%
    arrange(as.numeric(obj_posleft)) %>%
    na.omit()
  
  apply(X = peaks, MARGIN = 1,
        FUN = function(pk) {
          
          start <- as.numeric(pk[10]) 
          end   <- as.numeric(pk[11])
          startex <- as.numeric(pk[10]) - range
          endex   <- as.numeric(pk[11]) + range
          strand <- as.character(pk[12])
          peakpos <- as.numeric(pk[2])
          
          if (strand == "forward") {
            
            term <- seqdat["NC_000913.3"][[1]][start:end] %>%
              as.character() %>%
              gsub(pattern = "T", replacement = "U")
            
            termextra <- seqdat["NC_000913.3"][[1]][startex:endex] %>%
              as.character() %>%
              gsub(pattern = "T", replacement = "U")
            
            conpos <- (peakpos - start) + 1
            
            tvec <- c(terminator = term,
                      context = termextra,
                      start = start,
                      end = end, 
                      peak_position = peakpos,
                      relative_position = conpos,
                      strand = strand)
            tvec
            
          } else if (strand == "reverse") {
            
            term <- seqdat["NC_000913.3"][[1]][start:end] %>%
              reverseComplement() %>%
              as.character() %>%
              gsub(pattern = "T", replacement = "U")
            
            termextra <- seqdat["NC_000913.3"][[1]][startex:endex] %>%
              reverseComplement() %>%
              as.character() %>%
              gsub(pattern = "T", replacement = "U")
            
            conpos <- (end - peakpos) + 1
            
            tvec <- c(terminator = term,
                      context = termextra,
                      start = start,
                      end = end, 
                      peak_position = peakpos,
                      relative_position = conpos,
                      strand = strand)
            tvec
            
          }
          
        }) %>% as.matrix() %>% t() %>% as.tibble()
  
}

c_terms <- get_term_seqs(ec_control_peak_all, ec_fasta, 10)
h_terms <- get_term_seqs(ec_hs_peak_all, ec_fasta, 10)
```

## for peaks overlapping genes, get sequences flanking peak (subset)
```{r}
# seqdat from "read in fasta" section above

get_term_seqs <- function(peakdat, seqdat, range) {
  
  require(tidyverse)
  require(Biostrings)
  
  peaks <- peakdat %>%
    filter(type == "gene") %>%
    arrange(as.numeric(obj_posleft)) %>%
    na.omit()
  
  apply(X = peaks, MARGIN = 1,
        FUN = function(pk) {
          
          start <- as.numeric(pk[10]) 
          end   <- as.numeric(pk[11])
          startex <- as.numeric(pk[10]) - range
          endex   <- as.numeric(pk[11]) + range
          strand <- as.character(pk[12])
          peakpos <- as.numeric(pk[2])
          name <- pk[9]
          
          if (strand == "forward") {
            
            term <- seqdat["NC_000913.3"][[1]][start:end] %>%
              as.character() %>%
              gsub(pattern = "T", replacement = "U")
            
            termextra <- seqdat["NC_000913.3"][[1]][startex:endex] %>%
              as.character() %>%
              gsub(pattern = "T", replacement = "U")
            
            conpos <- (peakpos - start) + 1
            
            tvec <- c(terminator = term,
                      context = termextra,
                      start = start,
                      end = end, 
                      peak_position = peakpos,
                      relative_position = conpos,
                      strand = strand,
                      name = name)
            tvec
            
          } else if (strand == "reverse") {
            
            term <- seqdat["NC_000913.3"][[1]][start:end] %>%
              reverseComplement() %>%
              as.character() %>%
              gsub(pattern = "T", replacement = "U")
            
            termextra <- seqdat["NC_000913.3"][[1]][startex:endex] %>%
              reverseComplement() %>%
              as.character() %>%
              gsub(pattern = "T", replacement = "U")
            
            conpos <- (end - peakpos) + 1
            
            tvec <- c(terminator = term,
                      context = termextra,
                      start = start,
                      end = end, 
                      peak_position = peakpos,
                      relative_position = conpos,
                      strand = strand,
                      name = name)
            tvec
            
          }
          
        }) %>% as.matrix() %>% t() %>% as_tibble()
  
}

c_peak_genes <- get_term_seqs(ec_control_peak_all, ec_fasta, 10)
h_peak_genes <- get_term_seqs(ec_hs_peak_all, ec_fasta, 10)
```

## function to plot coverage over input range
```{r}
plot_range <- function(cov, peakdat, range) {
  
  name <- peakdat[8]
  
  xmin <- as.numeric(peakdat[5]) - range
  xmax <- as.numeric(peakdat[5]) + range
  
  plotcov <- cov %>% filter(position %in% c(xmin:xmax))
  ymax <- max(abs(plotcov$norm))
  
  # tbox <- data.frame(x1 = as.numeric(peakdat[5]),
  #                    x2 = as.numeric(peakdat[5]),
  #                    y1 = -ymax * 0.2,
  #                    y2 = ymax * 0.2,
  #                    stringsAsFactors = F)
  
  if (peakdat[7] == "forward") {
    
    tpeak <- data.frame(xend = as.numeric(peakdat[5]),
                        x = as.numeric(peakdat[5]),
                        yend = -1 * ymax * 0.1,
                        y = -1 * ymax * 0.3,
                        index = "PRO-seq_3",
                        stringsAsFactors = F)
    
  } else if (peakdat[7] == "reverse") {
    
    tpeak <- data.frame(xend = as.numeric(peakdat[5]),
                        x = as.numeric(peakdat[5]),
                        yend = ymax * 0.1,
                        y = ymax * 0.3,
                        index = "PRO-seq_3",
                        stringsAsFactors = F)
    
  }
  
  pc <- ggplot() +
             geom_area(data = plotcov,
                       mapping = aes(x = position, y = norm, fill = strand)) +
    facet_grid(index ~ treatment) +
    scale_fill_manual(values = c("blue","red")) +
    # coord_cartesian(xlim = c(xmin, xmax),
    #                 ylim = c(-ymax - (0.02 * ymax), ymax + (0.02 * ymax))) +
    # geom_rect(data = tbox,
    #           mapping = aes(xmin = x1, xmax = x2,
    #                         ymin = y1, ymax = y2),
    #           fill = "yellow",
    #           alpha = 0.2) +
    geom_segment(data = tpeak,
                 mapping = aes(x = x, y = y, xend = xend, yend = yend),
                 size = 1,
                 arrow = arrow(length = unit(0.05, "npc")),
                 lineend = "butt", linejoin = "mitre", color = "black") +
    theme_classic() +
    ggtitle(paste0(name, ", terminator ", peakdat[3],
                   " - ", peakdat[4], ", ", peakdat[7])) +
    geom_hline(yintercept = 0, color = "black")
           
  print(pc)
  
}

```

### constrain data to plot
```{r}
# read in coverage object from "read in coverage data, bedtools corrected" chunk above

subcov <- coverage %>% mutate(norm = ifelse(strand == "plus", norm, -1 * norm)) %>%
  mutate(index = paste0(type,"_",end)) %>%
  filter(index %in% c("PRO-seq_3", "PRO-seq_full", "RNA-seq_full"))

# setwd("/workdir/users/acv46/EC_PROSeq/pileup/iter_correct")
# write_csv(subcov, "sub_coverage_formatted.txt")
#rm(coverage)
```

### run plot function
```{r}

apply(c_peak_genes[200:220,], MARGIN = 1, FUN = plot_range, cov = ungroup(subcov), range = 100)
apply(h_peak_genes[200:220,], MARGIN = 1, FUN = plot_range, cov = ungroup(subcov), range = 100)

#plot_range(ungroup(subcov), c_terms, 100)

# DNAK test
# plot_range(subcov, peakdat = c("AAA","GGG",12163,15298,12887,1,"forward"), 100)
# plot_range(subcov, peakdat = c("AAA","GGG",12850,12950,12887,1,"forward"), 100)
# plot_range(subcov, peakdat = c("AAA","GGG",274,310,284,1,"forward"), 100)
# plot_range(subcov, peakdat = c("AAA","GGG",274,310,307,1,"forward"), 100)
```



# small RNA trancripts

## get small RNA coords from regulonDB
```{r}
require(tidyverse)
e_coli_regulondb_10.9 <- regulondb(database_conn = connect_database(),
                              organism = "E.coli",
                              database_version = "10.9",
                              genome_version = "NC_000913.3")

svec <- get_dataset(e_coli_regulondb_10.9, list_datasets(e_coli_regulondb_10.9)[1]) %>%
                         as_tibble %>% filter(type == "sRNA interaction") %>% select(name) %>%
                         as_vector() %>% str_remove(pattern = " sRNA.*") %>% unique()

ec_sRNAs <- get_dataset(e_coli_regulondb_10.9, list_datasets(e_coli_regulondb_10.9)[1]) %>%
  as_tibble %>% filter(name %in% svec)
```

## read in coverage data (from "Pause Sites, take 2")
```{r}
coverage <- read_csv("/workdir/users/acv46/EC_PROSeq/pileup/iter_correct/all_coverage_formatted.txt")
# flip orintation of plus and minus, just for fun
# 3' and 5' ends must also be flipped for correct orientation
# get normalized values by grouping lib types
## normalize based on full coverage values
coverage <- coverage %>% mutate(strand1 = ifelse(strand == "plus", "minus", "plus")) %>%
  select(-strand) %>% dplyr::rename(strand = strand1) %>%
  mutate(end1 = ifelse(end == "3", "5", ifelse(end == "5", "3", "full"))) %>%
  select(-end) %>% dplyr::rename(end = end1)
  # group_by(type, treatment, end) %>%
  # mutate(norm = (value / sum(value)) * 10^6) %>%
  # ungroup()

cp_sum <- coverage %>% filter(end == "full" & treatment == "control" & type == "PRO-seq") %>% select(value) %>% sum()
hp_sum <- coverage %>% filter(end == "full" & treatment == "heat shock" & type == "PRO-seq") %>% select(value) %>% sum()
cr_sum <- coverage %>% filter(end == "full" & treatment == "control" & type == "RNA-seq") %>% select(value) %>% sum()
hr_sum <- coverage %>% filter(end == "full" & treatment == "heat shock" & type == "RNA-seq") %>% select(value) %>% sum()

coverage <- coverage %>% mutate(norm = ifelse(treatment == "control" & type == "PRO-seq", (value / cp_sum) * 10^9,
                                              ifelse(treatment == "heat shock" & type == "PRO-seq", (value / hp_sum) * 10^9,
                                                     ifelse(treatment == "control" & type == "RNA-seq", (value / cr_sum) * 10^9,
                                                            ifelse(treatment == "heat shock" & type == "RNA-seq", (value / hr_sum) * 10^9, NA)
                                                            )
                                                     )
                                              )
                                )

covdat <- coverage %>%
  mutate(value = ifelse(strand == "minus", -value, value)) %>%
  mutate(norm = ifelse(strand == "minus", -norm, norm)) %>%
  mutate(type = ifelse(type == "RNA-seq", "RNAseq", type)) %>%
  mutate(lab = ifelse(end == "full",
                      paste0(type," ",end),
                      paste0(type," ",end,"' end")))
```

## plot coverage
```{r}
require(patchwork)
require(staplr)
require(tidyverse)
require(regutools)
require(ggrepel)

setwd("/workdir/users/acv46/EC_PROSeq/figures/sRNA")
oldfiles <- dir(path = ".", pattern = "*_partial.pdf")
file.remove(file.path(".", oldfiles))

apply(X = ec_sRNAs[1,], MARGIN = 1, function(sRNA) {
  
  tL <- as.numeric(sRNA[4])
  tR <- as.numeric(sRNA[5])
  
  # just sRNA and buffer
  buffer <- 30
  xmin <- ifelse(tL - buffer > 0, tL - buffer, 1)
  xmax <- ifelse(tR + buffer <= max(covdat$position), tR + buffer, max(covdat$position))
  cov <- covdat %>% filter(position >= xmin & position <= xmax) %>%
    select(-c(type,end))
  ymax <- max(abs(cov$norm))
  str <- ifelse(sRNA[6] == "forward", -1, 1)
  
  b1 <- round(xmin,nchar(xmin - 4))
  b2 <- round(xmax,nchar(xmin - 4))
  breaks <- seq(from = b1, to = b2, by = (b2 - b1) / 3)
  breaks <- breaks[which(breaks >= xmin & breaks <= xmax)]
  
  # https://livebook.manning.com/book/exploring-data-with-r/chapter-10/v-5/38
  
  pt <- ggplot(data = cov) +
    geom_area(mapping  = aes(x = position, y = norm, linetype = strand),
              fill = "red") +
    geom_text(mapping = aes(x = xmin,
                            y = str * 0.75 * ymax,
                            label = lab),
             size = 3,
             check_overlap = TRUE,
             hjust = 0) +
    scale_linetype_manual(values = c(1,1)) +
    facet_grid(lab ~ treatment) + 
    scale_x_continuous(breaks = breaks,
                       labels = sprintf("%.2f", (breaks / 1000))) +
    coord_cartesian(ylim = c(-ymax - (0.05 * ymax), ymax + (0.05 * ymax))) +
    theme_classic() + 
    theme(legend.position = "none",
          strip.background.y = element_blank(),
          strip.text.y = element_blank()) +
    geom_hline(yintercept = 0,
               color = "black") +
    xlab("position (kb)") +
    ylab("coverage per nt per 10^9 nt sequenced") +
    annotate("segment",
             x = ifelse(sRNA[6] == "forward", tL, tR),
             xend = ifelse(sRNA[6] == "forward", tR, tL),
             y = str * ymax * 0.3,
             yend = str * ymax * 0.3,
             size = 0.7,
             arrow = arrow(type = "closed", length = unit(0.075, "npc")),
             color = "black",
             alpha = 1) +
    ggtitle(paste0(sRNA[3]))
  
  # sRNA and more context
  buffer2 <- 2000
  xmin2 <- ifelse(tL - buffer2 > 0, tL - buffer2, 1)
  xmax2 <- ifelse(tR + buffer2 <= max(covdat$position), tR + buffer2, max(covdat$position))
  cov2 <- covdat %>% filter(position >= xmin2 & position <= xmax2) %>%
    select(-c(type)) %>% filter(end == "full") %>%
    mutate(lab2 = paste0(lab," ", treatment))
  ymax2 <- max(abs(cov2$norm))
  
  b1_ <- round(xmin2,nchar(xmin2 - 4))
  b2_ <- round(xmax2,nchar(xmin2 - 4))
  breaks2 <- seq(from = b1_, to = b2_, by = (b2_ - b1_) / 2)
  breaks2 <- breaks2[which(breaks2 >= xmin2 & breaks <= xmax2)]
  
  # https://livebook.manning.com/book/exploring-data-with-r/chapter-10/v-5/38
  
  pt2 <- ggplot(data = cov2) +
    geom_area(mapping  = aes(x = position, y = norm, linetype = strand),
              fill = "red") +
    geom_text(mapping = aes(x = xmin2,
                            y = str * 0.75 * ymax2,
                            label = lab2),
             size = 3,
             check_overlap = TRUE,
             hjust = 0) +
    scale_linetype_manual(values = c(1,1)) +
    facet_grid(lab2 ~ .) + 
    scale_x_continuous(breaks = breaks2,
                       labels = sprintf("%.2f", (breaks2 / 1000))) +
    coord_cartesian(ylim = c(-ymax2 - (0.05 * ymax2), ymax2 + (0.05 * ymax2))) +
    theme_classic() + 
    theme(legend.position = "none",
          strip.background.y = element_blank(),
          strip.text.y = element_blank(),
          axis.text.x = element_blank()) +
    geom_hline(yintercept = 0,
               color = "black") +
    xlab("") +
    ylab("") +
    annotate("segment",
             x = abs(tL + tR) / 2,
             xend = abs(tL + tR) / 2,
             y = str * ymax2 * 0.6,
             yend = str * ymax2 * 0.2,
             size = 0.7,
             arrow = arrow(type = "closed", length = unit(0.075, "npc")),
             color = "black",
             alpha = 1)
  
  pg <- get_dataset(e_coli_regulondb_10.9, list_datasets(e_coli_regulondb_10.9)[1]) %>%
    as_tibble %>% filter(posleft >= xmin2 & posright <= xmax2 & type == "gene") %>%
    mutate(molecule = "NC_000913.3") %>%
    mutate(orientation = ifelse(strand == "forward", 1, -1)) %>%
    mutate(start = posleft) %>% mutate(end = posright) %>% select(-c(id,type,description,posleft,posright)) %>%
    mutate(middle = as.numeric(start + end) / 2) %>%
             ggplot(data = .,
                        mapping = aes(xmin = start,
                         xmax = end,
                         x = middle,
                         y = molecule,
                         fill = name,
                         label = name,
                         forward = orientation)) +
             geom_gene_arrow(arrowhead_width = grid::unit(2, "mm"),
                    arrowhead_height = grid::unit(4, "mm"),
                    arrow_body_height = grid::unit(4, "mm")) +
              geom_label_repel(mapping = aes(x = middle, label = name),
                        angle = 90, size = 2.5, vjust = 0, hjust = -0.5) +
    scale_y_discrete(expand = expand_scale(mult = c(2,4))) +
              #scale_fill_manual(values = pal) +
    coord_cartesian(xlim = c(xmin2, xmax2),
                    clip = "off") +
    scale_x_continuous(breaks = breaks2,
                       labels = sprintf("%.2f", (breaks2 / 1000))) +
              theme_genes() +
              theme(legend.position = "none",
                    axis.text.y = element_blank(),
                    axis.ticks.y = element_blank(),
                    #axis.text.x = element_blank(),
                    #axis.ticks.x = element_blank(),
                    axis.title.y = element_blank()) +
    xlab("position (kb)") +
    ylab("")
  
  merge1 <- pt2 / pg +
    plot_layout(ncol = 1, nrow = 2,
                heights = c(5,1))
  
  merge2 <- pt + merge1 + 
    plot_layout(ncol = 2, nrow = 1,
                heights = c(5,5))
  
  merge2
  
  # ggsave(filename = paste(sRNA[1], "partial.pdf", sep = "_"),
  #        plot = merge2,
  #        device = cairo_pdf,
  #        dpi = 400,
  #        width = 6,
  #        height = 4)
  
})


# pdflist <- list.files(path = ".", pattern = "partial.pdf")
# staple_pdf(input_files = pdflist,
#            output_filepath = file.path(".", "ec_sRNA_merged_v7.pdf"))
# do.call(file.remove, list(pdflist))
```
